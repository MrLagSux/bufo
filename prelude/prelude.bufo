// All libc functions are unsafe, because C-compliance is not guaranteed yet.

// TODO: Implement safe wrapper for everything :^)
// TODO: Move all of the externals into `libc.bufo`

// Intrinsics
// They are safe because we can directly define their behavior
extern GLOBAL_GET_ARGC() -> usize;
extern GLOBAL_GET_ARGV() -> &&char;

// Strings
unsafe extern strlen(string: &char) -> usize;
unsafe extern strcmp(s1: &char, s2: &char) -> i32;

unsafe comptime func comptimeStrlen(str: &char) -> usize {
    mut len: usize = 0;
    while (*(str + len) != '\0') len = len + 1;
    return len;
}

// Memory
// TODO: IMPORTANT: Some way to do null checks
unsafe extern malloc(bytes: usize) -> Any;
unsafe extern calloc(num: usize, size: usize) -> Any;
unsafe extern realloc(ptr: Any, new_size: usize) -> Any;
unsafe extern free(ptr: Any);
unsafe extern memcpy(dest: Any, src: Any, count: usize) -> Any;

unsafe func isNull(ptr: Any) -> bool {
    let bfr: [char; 20] = ['\0'; 20];
    let _a: Any = &bfr;
    let _s: &char = _a;
    snprintf(&bfr, 17, "%p", ptr);
    let win: i32 = strcmp(_s, "0000000000000000");
    if (win == 0) return true;
    let posix: i32 = strcmp(_s, "(nil)");
    return posix == 0;
}

// File IO
unsafe extern fopen(filename: &char, mode: &char) -> Any;
// FIXME: Any ignores Mutability :^) We should probably only write to mutable buffers tho...
unsafe extern fread(buffer: Any, size: usize, count: usize, stream: Any) -> usize;
unsafe extern fclose(stream: Any) -> i32;
unsafe extern fprintf(stream: Any, msg: &char, ...);

unsafe func NULL() -> Any {
    // FIXME: This is cursed
    let p: Any = fopen("kjnasduiwqe", "r");
    assert_with_msg(isNull(p), "Could not get valid NullPointer.");
    return p;
}

unsafe extern snprintf(buffer: Any, size: usize, format: &char, ...) -> usize;

// Console IO
unsafe extern printf(msg: &char, ...) -> usize;
unsafe extern fdopen(fd: i32, mode: &char) -> Any;
unsafe extern putchar(ch: char) -> char;
unsafe extern puts(s: &char) -> usize;

unsafe extern exit(code: i32);

unsafe func getChar(s: &char, index: usize) -> char {
    let _idk: Any = s;
    let _ch: &char = _idk;
    let c: char = *(_ch + index);
    return c;
}

func isNumeric(ch: char) -> bool {
    unsafe {
        // Safety: Safe as long as char is always one byte :^)
        let _idk: Any = &ch;
        let _i8: i8 = *_idk;
        return (_i8 >= 48) && (_i8 <= 57);
    }
}

func isAlphabetic(ch: char) -> bool {
    unsafe {
        // Safety: Safe as long as char is always one byte :^)
        let _idk: Any = &ch;
        let _i8: i8 = *_idk;
        return (_i8 >= 65) && (_i8 <= 90) || (_i8 >= 97) && (_i8 <= 122);
    }
}

func isWhitespace(ch: char) -> bool {
    return ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t';
}

func isAlphanumeric(ch: char) -> bool {
    return isAlphabetic(ch) || isNumeric(ch);
}

// Internal Runtime Errors
func index_oob(msg: &char, index: i64) {
    unsafe {
        let stderr: Any = fdopen(2, "w");
        fprintf(stderr, msg, index);
        exit(1);
    }
}

func assert(cond: bool) {
    unsafe {
        if (!cond) {
            let stderr: Any = fdopen(2, "w");
            fprintf(stderr, "ASSERTION FAILED\n");
            exit(1);
        }
    }
}

func assert_with_msg(cond: bool, msg: &char) {
    unsafe {
        if (!cond) {
            let stderr: Any = fdopen(2, "w");
            fprintf(stderr, "ASSERTION FAILED: %s\n", msg);
            exit(1);
        }
    }
}

func todo_with_msg(msg: &char) {
    unsafe {
        let stderr: Any = fdopen(2, "w");
        fprintf(stderr, "TODO: %s\n", msg);
        exit(1);
    }
}