class Test {
    a: i64;
    b: i64;
    c: i64;
    d: u64;

    // new() is equivalent to:
    // func new(na: i64, nb: i64, nc: i64) -> Test {
    //     let this: Test = alloc(some bytes);
    //     this.a.b = na;
    //     this.b = nb;
    //     this.c = nc;
    //     return this;
    // }
    // -> Every Function in a class has hidden parameter `this` (no static for now)
    feat new(na: i64, nb: i64, nc: i64) {
        this.a = na;
        this.b = nb;
        this.c = nc;
        // this.d gets 0 initialized
    }
    
    // foo() is equivalent to:
    // func foo(this: Test) -> u64 { ... }
    // test.foo() is equivalent to:
    // Test::foo(test)
    func foo() -> u64 {
        return this.d;
    }
}

class Idee {
    a: u64;
    t: Test;

    feat new(na: u64) {
        this.a = na;
        // Test(this.a, 5, 10) is equivalent to Test::new(this.a, 5, 10)
        this.t = Test(this.a, 5, 10);
        this.t.b = 10;
    }
}

func bla(t: Test, t1: Test) -> u64 {
    return t.d + t1.d;
}

func retInstance(t: Test) -> Idee {
    return Idee(t.d);
}

func main() {
    let a: u64[3] = [
        1 - 3, 2 * 4, 3 / 5
    ];
    // Test() works because `new()` has been implemented
    let test: Test = Test(2, 3, 4);
    let d: i32 = 9;
    d = 0;
    test.d = 10;
    let idee: Idee = retInstance(test);
    // let f: u64 = test.foo();
}