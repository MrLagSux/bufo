/*
Battle Plan:
- Quirks
- Strong Type System
  - Type Inference
- Ownership
- Multiple Stages -> Parsing, Typechecks, Ownerchecks, etc.
- Multiple IRs -> AST, Middle-IR for Ownerchecks, etc.
- Handwritten ASM, no LLVM for now (Debatable)
- C-Style imports -> Just paste the code
- Expressions: Blocks, If
- Statements: return, while, let, for, defer

24-06-07: We can parse the below test file
*/

quirk ABC {}

struct Idk<T> {
    field: i32,
    val: T,
}

type Irdk = Idk<i32>;

struct Foo<T> {
    v: T,
}

struct Vec<Elems> {
    elems: &mut Elems,
}

realize Idk<T> {
    func foo(&self) {
        let b: T = 0;
    }
}

quirk Add<T: ABC> {
    type Output = T;
    func add(&self, other: &T) -> Output;
}

realize Add<i32> for i32 {
}

realize<T: Add<T>> Add<Vec<T>> for Vec<T> {
    type Output = Vec<T>;
    func add(&self, other: &Vec<T>) -> Output {
        let a: i32 = 12;
    }
}
realize ABC for i32 {}

type a = i32;

func main() {
    let a = 5;
    let b = a + 1;
    let c: i32 = b + a;
    let val = c;
    let i1 = Idk { val };
    let i2 = Idk { val: b };
    let i3 = i1 + i2;
    // Line below should work because Irdk==Idk<i32>
    // They are exactly the same type.
    let i4: Irdk = i1;
}

