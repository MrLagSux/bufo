// While this code is not used, we keep it here to reduce compile times :^)

unsafe func printSubStr(sub: &SubStr, indent: usize) {
    let s: String = sub.toString();
    if (indent == 0) printf("%s\n", s.buffer);
    else printf("%*c%s\n", indent, ' ', s.buffer);
    s.drop();
}
unsafe func printQuirk(quirk: &Quirk, indent: usize) {
    printf("%*cQuirk\n", indent, ' ');
    printType(&quirk.typ, indent + 2);
    printf("%*cTypes\n", indent, ' ');
    for (mut i: usize = 0; i < quirk.typeDefs.len(); i = i + 1) {
        printTypeDef(quirk.typeDefs.getTypeDef(i), indent + 2);
    }
    printf("%*cFuncDecls\n", indent, ' ');
    for (mut i: usize = 0; i < quirk.funcDecls.len(); i = i + 1) {
        printFuncDecl(quirk.funcDecls.getFuncDecl(i), indent + 2);
    }
}
unsafe func printStructType(st: &StructType, indent: usize) {
    printf("%*cStructType ", indent, ' ');
    printSubStr(&st.name, 0);
    if (st.generics.len() > 0) {
        printf("%*cGenerics\n", indent + 2, ' ');
        for (mut i: usize = 0; i < st.generics.len(); i = i + 1) {
            printType(st.generics.getType(i), indent + 4);
        }
    }
}
unsafe func printGenericType(gt: &GenericType, indent: usize) {
    printf("%*cGenericType ", indent, ' ');
    printSubStr(&gt.name, 0);
    if (gt.bounds.len() > 0) {
        printf("%*cBounds\n", indent, ' ');
        for (mut i: usize = 0; i < gt.bounds.len(); i = i + 1) {
            printType(gt.bounds.getType(i), indent + 2);
        }
    }
}
unsafe func printRefType(rt: &RefType, indent: usize) {
    if (rt.mutable) {
        printf("%*c&mut", indent, ' ');
    } else {
        printf("%*c&", indent, ' ');
    }
    printType(&rt.typ, 0);
}
unsafe func printType(typ: &Type, indent: usize) {
    if (typ.kind == TYPE_KIND_PRIMITIVE()) {
        printSubStr(typ.data, indent);
    } else if (typ.kind == TYPE_KIND_STRUCT()) {
        let _s: &StructType = typ.data;
        printStructType(_s, indent);
    } else if (typ.kind == TYPE_KIND_GENERIC()) {
        let _g: &GenericType = typ.data;
        printGenericType(_g, indent);
    } else if (typ.kind == TYPE_KIND_REFERENCE()) {
        let _r: &RefType = typ.data;
        printRefType(_r, indent);
    } else if (typ.kind == TYPE_KIND_SELF()) {
        printf("%*cSelf\n", indent, ' ');
    } else {
        assert_with_msg(false, "printType: Unreachable");
    }
}
unsafe func printFuncDecl(fnDecl: &FuncDecl, indent: usize) {
    printf("%*cFuncDecl ", indent, ' ');
    printSubStr(&fnDecl.name, 0);
    if (fnDecl.params.len() > 0) {
        printf("%*cParams\n", indent, ' ');
        for (mut i: usize = 0; i < fnDecl.params.len(); i = i + 1) {
            printFuncParam(fnDecl.params.getFuncParam(i), indent + 2);
        }
    }
    if (fnDecl.retType.isSome()) {
        let t: &Type = fnDecl.retType.asType();
        printf("%*cReturn Type\n", indent, ' ');
        printType(t, indent + 2);
    }
}
unsafe func printFuncDef(fnDef: &FuncDef, indent: usize) {
    printf("%*cFuncDef ", indent, ' ');
    printSubStr(&fnDef.name, 0);
    if (fnDef.params.len() > 0) {
        printf("%*cParams\n", indent, ' ');
        for (mut i: usize = 0; i < fnDef.params.len(); i = i + 1) {
            printFuncParam(fnDef.params.getFuncParam(i), indent + 2);
        }
    }
    if (fnDef.retType.isSome()) {
        let t: &Type = fnDef.retType.asType();
        printf("%*cReturn Type\n", indent, ' ');
        printType(t, indent + 2);
    }
    printBlock(&fnDef.body, indent + 2);
}
unsafe func printFuncParam(param: &FuncParam, indent: usize) {
    printf("%*cFuncParam ", indent, ' ');
    printSubStr(&param.name, 0);
    printType(&param.typ, indent + 2);
}
unsafe func printStmt(stmt: &Stmt, indent: usize) {
    if (stmt.kind == STMT_KIND_LET()) {
        printf("%*cLetStmt\n", indent, ' ');
        let _l: &LetStmt = stmt.data;
        printSubStr(&_l.name, indent + 2);
        if (_l.typeDef.isSome()) {
            let _t: &Type = _l.typeDef.asType();
            printType(_t, indent + 2);
        }
        printExpr(&_l.expr, indent + 2);
    } else {
        assert_with_msg(false, "printStmt: Unreachable");
    }
}
unsafe func printExpr(expr: &Expr, indent: usize) {
    if (expr.kind == EXPR_INVALID()) todo_with_msg("Print invcalid");
    else if (expr.kind == EXPR_KIND_NUM_LIT()) {
        printf("%*cExprNumLit ", indent, ' ');
        let _e: &ExprNumLit = expr.data;
        printSubStr(&_e.number, 0);
    } else if (expr.kind == EXPR_KIND_IDENT()) {
        printf("%*cExprIdent ", indent, ' ');
        let _e: &ExprIdent = expr.data;
        printSubStr(&_e.name, 0);
    } else if (expr.kind == EXPR_KIND_BINARY()) {
        printf("%*cExprBinary\n", indent, ' ');
        let _e: &ExprBinary = expr.data;
        printf("%*cOperator ", indent + 2, ' ');
        printSubStr(&_e.op.getSubStr(), 0);
        printExpr(&_e.lhs, indent + 2);
        printExpr(&_e.rhs, indent + 2);
    } else if (expr.kind == EXPR_KIND_STRUCT_LIT()) {
        printf("%*cExprStructLit\n", indent, ' ');
        let _e: &ExprStructLit = expr.data;
        printSubStr(&_e.name.getSubStr(), indent + 2);
        for (mut i: usize = 0; i < _e.fields.len(); i = i + 1) {
            printf("%*cField ", indent, ' ');
            let _pse: &PairTokenExpr = _e.fields.getPairTokenExpr(i);
            printSubStr(&_pse.name.getSubStr(), 0);
            printExpr(&_pse.value, indent + 2);
        }
    } else {
        assert_with_msg(false, "printExpr: Unreachable");
    }
}
unsafe func printBlock(block: &Block, indent: usize) {
    printf("%*cBlock\n", indent, ' ');
    if (block.stmts.len() > 0) {
        for (mut i: usize = 0; i < block.stmts.len(); i = i + 1) {
            printStmt(block.stmts.getStmt(i), indent + 2);
        }
    } else {
        printf("%*c<empty>\n", indent + 2, ' ');
    }
}
unsafe func printRealize(realize: &Realize, indent: usize) {
    printf("%*cRealize\n", indent, ' ');
    if (realize.qType.isSome()) {
        printf("%*cQuirk\n", indent + 2, ' ');
        printType(realize.qType.asType(), indent + 4);
        printf("%*cStruct\n", indent + 2, ' ');
    } else {
        printf("%*cStruct\n", indent + 2, ' ');
        printType(&realize.sType, indent + 4);
    }
    if (realize.generics.len() > 0) {
        printf("%*cGenerics\n", indent, ' ');
        for (mut i: usize = 0; i < realize.generics.len(); i = i + 1) {
            printType(realize.generics.getType(i), indent + 2);
        }
    }
    if (realize.fnDefs.len() > 0) {
        printf("%*cFuncDefs\n", indent + 2, ' ');
        for (mut i: usize = 0; i < realize.fnDefs.len(); i = i + 1) {
            printFuncDef(realize.fnDefs.getFuncDef(i), indent + 4);
        }
    }
}
unsafe func printStruct(strukt: &Struct, indent: usize) {
    printf("%*cStruct\n", indent, ' ');
    printType(&strukt.typ, indent + 2);
    if (strukt.fields.len() > 0) {
        printf("%*cFields\n", indent + 2, ' ');
        for (mut i: usize = 0; i < strukt.fields.len(); i = i + 1) {
            printField(strukt.fields.getField(i), indent + 4);
        }
    } else {
        printf("%*c<empty>\n", indent + 2);
    }
}
unsafe func printTypeDef(typeDef: &TypeDef, indent: usize) {
    printf("%*cTypeDef\n", indent, ' ');
    printf("%*cAlias\n", indent + 2, ' ');
    printType(&typeDef.name, indent + 4);
    printf("%*cOriginal\n", indent + 2, ' ');
    printType(&typeDef.rhs, indent + 4);
}
unsafe func printField(field: &Field, indent: usize) {
    printf("%*cField ", indent, ' ');
    printSubStr(&field.name, 0);
    printType(&field.typ, indent + 2);
}
unsafe func printModule(module: &Module, indent: usize) {
    printf("%*cModule ", indent, ' ');
    printSubStr(&module.name, 0);
    printf("%*cSubmodules\n", indent, ' ');
    for (mut i: usize = 0; i < module.modules.len(); i = i + 1) {
        printModule(module.modules.getModule(i), indent + 2);
    }
    printf("%*cFunctions\n", indent, ' ');
    for (mut i: usize = 0; i < module.funcs.len(); i = i + 1) {
        printFuncDef(module.funcs.getFuncDef(i), indent + 2);
    }
    printf("%*cStructs\n", indent, ' ');
    for (mut i: usize = 0; i < module.structs.len(); i = i + 1) {
        printStruct(module.structs.getStruct(i), indent + 2);
    }
    printf("%*cTypeDefs\n", indent, ' ');
    for (mut i: usize = 0; i < module.types.len(); i = i + 1) {
        printTypeDef(module.types.getTypeDef(i), indent + 2);
    }
    printf("%*cQuirks\n", indent, ' ');
    for (mut i: usize = 0; i < module.quirks.len(); i = i + 1) {
        printQuirk(module.quirks.getQuirk(i), indent + 2);
    }
    printf("%*cRealizations\n", indent, ' ');
    for (mut i: usize = 0; i < module.reals.len(); i = i + 1) {
        printRealize(module.reals.getRealize(i), indent + 2);
    }
}
unsafe func printAST(module: &Module) {
    printf("AST:\n");
    printModule(module, 2);
}
