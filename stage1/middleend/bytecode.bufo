
struct VarIndex { _i: usize; }
struct FnIndex {
    _i: usize;
    func isGlobalFn(&this) -> bool {
        return this._i == 0;
    }
}
struct InstrIndex { _i: usize; }
struct RegIndex {
    _i: usize;

    func toString(&mut this) -> String {
        mut s: String = newStringFromStrLit("@");
        s.pushNumber(this._i);
        return s;
    }
}

struct TypeIndex {
    _i: usize;
    func toString(&mut this) -> String {
        return types[assertValidType(*this, "TypeIndex.toString")].toString();
    }

    func getSize(&mut this) -> usize {
        if (this._i == 0) return 8;
        if (this._i == 1) return 1;
        todo_with_msg("actually implement TypeIndex.getSize");
        return types[assertValidType(*this, "TypeIndex.getSize")].getSize();
    }

    func equals(this, other: TypeIndex) -> bool {
        // REVIEW: Is this short-circuit valid?
        if (this._i == other._i) return true;
        let _t: &mut BCType = &mut types[assertValidType(this, "TypeIndex.equals")];
        let _o: &mut BCType = &mut types[assertValidType(other, "TypeIndex.equals")];
        return _t.equals(_o);
    }
}

struct NameRegPair {
    name: SubStr;
    reg: RegIndex;
}

struct BCReg {
    origin: Span;
    value: &mut u8;
    size: usize;
    typ: TypeIndex;

    func toString(&mut this) -> String {
        assert(sizeof char == sizeof u8);
        if (this.size == 0) return newStringFromStrLit("<uninit>");
        mut s: String = newString();
        let _t: String = this.typ.toString();
        s.pushString(&_t);
        let size: usize = this.typ.getSize();
        s.pushStr(", raw-value=");
        for (mut i: usize = 0; i < size; i = i + 1) unsafe {
            if (i >= 25 && size - i > 0) {
                s.pushStr(" <and ");
                s.pushNumber(size - i);
                s.pushStr(" more...>");
                break;
            }
            s.pushChar(*(this.value + i * sizeof u8) as char);
        }
        _t.drop();
        return s;
    }

    func isInitialized(&mut this) -> bool {
        return this.size != 0;
    }
}

comptime TYPE_INVALID: usize = 0;
comptime TYPE_INTEGER: usize = 1;
struct BCTypeInt {
    bitsize: u32;
    signed: bool;
}
struct BCType {
    kind: usize;
    intInfo: BCTypeInt;

    func isValid(&mut this) -> bool {
        return this.kind != TYPE_INVALID;
    }

    func toString(&mut this) -> String {
        if (this.kind == TYPE_INTEGER) {
            mut s: String = newString();
            if (this.intInfo.signed) s.pushChar('i');
            else s.pushChar('u');
            s.pushNumber(this.intInfo.bitsize as usize);
            return s;
        } else {
            let id: TypeIndex = getTypeID(this);
            if (id._i == 1) return newStringFromStrLit("bool");
            assert_with_msg(false, "unreachable in BCType.toString()");
            return blank;
        }
    }

    func makeIntegerType(&mut this, bitsize: u32, signed: bool) {
        assert_with_msg(this.kind == TYPE_INVALID, "attempted to turn valid type into integer type");
        this.kind = TYPE_INTEGER;
        this.intInfo.bitsize = bitsize;
        this.intInfo.signed = signed;
    }

    func getSize(&mut this) -> usize {
        todo_with_msg("BCType.getSize");
        return 0;
    }

    func equals(&mut this, other: &mut BCType) -> bool {
        warning("Can't really do BCTypes.equals() yet");
        return false;
    }
}

struct BCFunction {
    origin: Span;
    variables: &mut NameRegPair;
    varLength: usize;
    varCapacity: usize;
    registers: &mut BCReg;
    regLength: usize;
    regCapacity: usize;
    instructions: &mut BCInstr;
    instrLength: usize;
    instrCapacity: usize;

    func getVarAtIndex(&mut this, index: VarIndex) -> &mut NameRegPair {
        trace("BCFunction.getVarAtIndex");
        assert_with_msg(index._i < this.varLength, "Out of bounds access in BCFunction.getVarAtIndex");
        unsafe {
            return this.variables + index._i * sizeof NameRegPair;
        }
    }

    func getInstrAtIndex(&mut this, index: InstrIndex) -> &mut BCInstr {
        trace("BCFunction.getInstrAtIndex");
        assert_with_msg(index._i < this.instrLength, "Out of bounds access in BCFunction.getInstrAtIndex");
        unsafe {
            return this.instructions + index._i * sizeof BCInstr;
        }
    }

    func getRegAtIndex(&mut this, index: RegIndex) -> &mut BCReg {
        trace("BCFunction.getRegAtIndex");
        assert_with_msg(index._i < this.regLength, "Out of bounds access in BCFunction.getRegAtIndex");
        unsafe {
            return this.registers + index._i * sizeof BCReg;
        }
    }

    func appendInstr(&mut this, instr: BCInstr) {
        trace("BCFunction.appendInstr");
        if (this.instrLength >= this.instrCapacity) unsafe {
            mut newCap: usize = this.instrCapacity * 2;
            if (newCap == 0) newCap = newCap + 1;
            this.instructions = realloc(this.instructions, newCap * sizeof BCInstr);
            assert_with_msg(this.instructions != null, "Could not resize instructions");
            this.instrCapacity = newCap;
        }
        let id: usize = this.instrLength;
        unsafe {
            *(this.instructions + id * sizeof BCInstr) = instr;
        }
        this.instrLength = this.instrLength + 1;
    }

    func allocateVariable(&mut this, name: SubStr, reg: RegIndex) {
        trace("BCFunction.allocateVariable");
        if (this.varLength >= this.varCapacity) unsafe {
            mut newCap: usize = this.varCapacity * 2;
            if (newCap == 0) newCap = newCap + 1;
            this.variables = realloc(this.variables, newCap * sizeof NameRegPair);
            assert_with_msg(this.variables != null, "Could not resize variables");
            this.varCapacity = newCap;
        }
        let index: usize = this.varLength;
        unsafe {
            let entry: NameRegPair = NameRegPair {
                name: name,
                reg: reg
            };
            *(this.variables + index * sizeof NameRegPair) = entry;
        }
        this.varLength = this.varLength + 1;
    }

    func allocateRegister(&mut this, span: Span) -> RegIndex {
        trace("BCFunction.allocateRegister");
        if (this.regLength >= this.regCapacity) unsafe {
            mut newCap: usize = this.regCapacity * 2;
            if (newCap == 0) newCap = newCap + 1;
            this.registers = realloc(this.registers, newCap * sizeof BCReg);
            assert_with_msg(this.registers != null, "Could not resize registers");
            this.regCapacity = newCap;
        }
        let index: usize = this.regLength;
        unsafe {
            mut reg: BCReg = blank;
            reg.origin = span;
            *(this.registers + index * sizeof BCReg) = reg;
        }
        this.regLength = this.regLength + 1;
        return RegIndex { _i: index };
    }

    func buildLoad(&mut this, span: Span, name: SubStr, target: &mut RegIndex) -> bool {
        trace("BCFunction.buildLoad");
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let var: &mut NameRegPair = this.getVarAtIndex(VarIndex { _i: i });
            if (var.name.equals(&name)) {
                let reg: RegIndex = this.allocateRegister(span);
                let load: BCInstr = newLoadInstr(span, reg, var.reg);
                this.appendInstr(load);
                *target = reg;
                return true;
            }
        }
        return false;
    }

    func buildConstStore(&mut this, span: Span, name: SubStr, value: RegIndex) -> bool {
        trace("BCFunction.buildConstStore");
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let var: &mut NameRegPair = this.getVarAtIndex(VarIndex { _i: i });
            if (var.name.equals(&name)) {
                todo_with_msg("redecl");
                return false;
            }
        }
        let var: RegIndex = this.allocateRegister(span);
        let store: BCInstr = newStoreConstInstr(span, var, value);
        this.appendInstr(store);
        this.allocateVariable(name, var);
        return true;
    }

    func buildNumberLiteral(&mut this, span: Span, val: i64) -> RegIndex {
        trace("BCFunction.buildNumberLiteral");
        let index: RegIndex = this.allocateRegister(span);
        let n: BCInstr = newLoadNumberInstr(span, index, val);
        this.appendInstr(n);
        return index;
    }

    func buildBinaryOp(&mut this, span: Span, lhs: RegIndex, rhs: RegIndex, op: usize) -> RegIndex {
        trace("BCFunction.buildBinaryOp");
        let dst: RegIndex = this.allocateRegister(span);
        mut binop: BCInstr = blank;
        if (op == BINARY_OP_PLUS) binop = newAddInstr(span, dst, lhs, rhs);
        else if (op == BINARY_OP_EQUAL) binop = newEqualInstr(span, dst, lhs, rhs);
        else if (op == BINARY_OP_NOT_EQUAL) binop = newNotEqualInstr(span, dst, lhs, rhs);
        else todo_with_msg("build binary op");
        this.appendInstr(binop);
        return dst;
    }

    func buildConstAssert(&mut this, span: Span, what: RegIndex) -> RegIndex {
        trace("BCFunction.buildConstAssert");
        let dst: RegIndex = this.allocateRegister(span);
        let assert: BCInstr = newConstAssertInstr(span, dst, what);
        this.appendInstr(assert);
        return dst;
    }

    func buildCreateInteger(&mut this, span: Span, size: RegIndex, signed: RegIndex) -> RegIndex {
        trace("BCFunction.buildCreateInteger");
        let dst: RegIndex = this.allocateRegister(span);
        let int: BCInstr = newCreateIntType(span, dst, size, signed);
        this.appendInstr(int);
        return dst;
    }
    func dump(&mut this) {
        unsafe {
            printf(" --- REGISTERS ---\n");
            for (mut i: usize = 0; i < this.regLength; i = i + 1) {
                let _reg: String = (*(this.registers + i * sizeof BCReg)).toString();
                printf(" @%llu: %.*s\n", i, _reg.len(), _reg.chars());
                _reg.drop();
            }
            printf(" --- INSTRUCTIONS ---\n");
            for (mut i: usize = 0; i < this.instrLength; i = i + 1) {
                let _ins: String = (*(this.instructions + i * sizeof BCInstr)).toString();
                printf("  %llu: %.*s\n", i, _ins.len(), _ins.chars());
                _ins.drop();
            }
        }
    }
}

func newEmptyFunction(span: Span) -> BCFunction {
    unsafe {
        return BCFunction {
            origin: span,
            variables: null,
            varLength: 0,
            varCapacity: 0,
            registers: null,
            regLength: 0,
            regCapacity: 0,
            instructions: null,
            instrLength: 0,
            instrCapacity: 0,
        };
    }
}

comptime INSTR_KIND_INVALID: usize = 0;
comptime INSTR_KIND_LOAD_NUMBER: usize = 1;
comptime INSTR_KIND_STORE_CONST: usize = 2;
comptime INSTR_KIND_LOAD: usize = 3;
comptime INSTR_KIND_ADD: usize = 4;
comptime INSTR_KIND_EQUAL: usize = 5;
comptime INSTR_KIND_NOT_EQUAL: usize = 6;
comptime INSTR_KIND_CONST_ASSERT: usize = 7;
comptime INSTR_KIND_CREATE_INT_TYPE: usize = 8;
struct BCInstr {
    origin: Span;
    kind: usize;
    dst: RegIndex;
    src: RegIndex;
    // FIXME: Maybe it's better to not waste this memory for any instruction that doesn't need it
    op1: RegIndex;

    func toString(&mut this) -> String {
        mut ret: String = blank;
        if (this.kind == INSTR_KIND_INVALID) {
            ret = newStringFromStrLit("<invalid>");
        } else if (this.kind == INSTR_KIND_STORE_CONST) {
            let _dst: String = this.dst.toString();
            let _src: String = this.src.toString();
            mut s: String = newStringFromStrLit("StoreConst ");
            s.pushString(&_dst);
            s.pushStr(", ");
            s.pushString(&_src);
            _src.drop();
            _dst.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_LOAD) {
            let _dst: String = this.dst.toString();
            let _src: String = this.src.toString();
            mut s: String = newString();
            s.pushString(&_dst);
            s.pushStr(" = Load ");
            s.pushString(&_src);
            _src.drop();
            _dst.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_LOAD_NUMBER) unsafe {
            let n: i64 = *(&this.src._i as &i64);
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            s.pushString(&_dst);
            _dst.drop();
            s.pushStr(" = LoadNumber ");
            s.pushI64(n);
            ret = s;
        } else if (this.kind == INSTR_KIND_ADD) {
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            let _src: String = this.src.toString();
            let _op1: String = this.op1.toString();
            s.pushString(&_dst);
            s.pushStr(" = Add ");
            s.pushString(&_src);
            s.pushStr(", ");
            s.pushString(&_op1);
            _dst.drop();
            _src.drop();
            _op1.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_EQUAL) {
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            let _src: String = this.src.toString();
            let _op1: String = this.op1.toString();
            s.pushString(&_dst);
            s.pushStr(" = Equal ");
            s.pushString(&_src);
            s.pushStr(", ");
            s.pushString(&_op1);
            _dst.drop();
            _src.drop();
            _op1.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_NOT_EQUAL) {
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            let _src: String = this.src.toString();
            let _op1: String = this.op1.toString();
            s.pushString(&_dst);
            s.pushStr(" = NotEqual ");
            s.pushString(&_src);
            s.pushStr(", ");
            s.pushString(&_op1);
            _dst.drop();
            _src.drop();
            _op1.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_CONST_ASSERT) {
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            let _what: String = this.src.toString();
            s.pushString(&_dst);
            s.pushStr(" = ConstAssert ");
            s.pushString(&_what);
            _dst.drop();
            _what.drop();
            ret = s;
        } else if (this.kind == INSTR_KIND_CREATE_INT_TYPE) {
            mut s: String = newString();
            let _dst: String = this.dst.toString();
            let _size: String = this.src.toString();
            let _sign: String = this.op1.toString();
            s.pushString(&_dst);
            s.pushStr(" = CreateIntType ");
            s.pushString(&_size);
            s.pushStr(", ");
            s.pushString(&_sign);
            _dst.drop();
            _size.drop();
            _sign.drop();
            ret = s;
        } else unsafe {
            printf("%llu\n", this.kind);
            assert_with_msg(false, "exhaustive handling in BCInstr.toString");
            ret = blank;
        }
        return ret;
    }
}

func newLoadNumberInstr(span: Span, dst: RegIndex, val: i64) -> BCInstr {
    unsafe {
        return BCInstr {
            origin: span,
            kind: INSTR_KIND_LOAD_NUMBER,
            dst: dst,
            src: RegIndex { _i: *(&val as &usize) },
            op1: blank,
        };
    }
}

func newStoreConstInstr(span: Span, dst: RegIndex, src: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_STORE_CONST,
        dst: dst,
        src: src,
        op1: blank,
    };
}

func newLoadInstr(span: Span, dst: RegIndex, src: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_LOAD,
        dst: dst,
        src: src,
        op1: blank,
    };
}

func newAddInstr(span: Span, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_ADD,
        dst: dst,
        src: lhs,
        op1: rhs
    };
}

func newEqualInstr(span: Span, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_EQUAL,
        dst: dst,
        src: lhs,
        op1: rhs
    };
}

func newNotEqualInstr(span: Span, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_NOT_EQUAL,
        dst: dst,
        src: lhs,
        op1: rhs
    };
}

func newConstAssertInstr(span: Span, dst: RegIndex, what: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_CONST_ASSERT,
        dst: dst,
        src: what,
        op1: blank
    };
}

func newCreateIntType(span: Span, dst: RegIndex, size: RegIndex, signed: RegIndex) -> BCInstr {
    return BCInstr {
        origin: span,
        kind: INSTR_KIND_CREATE_INT_TYPE,
        dst: dst,
        src: size,
        op1: signed
    };
}
