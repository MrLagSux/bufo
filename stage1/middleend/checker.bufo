import "stage1/middleend/bytecode.bufo";
import "stage1/middleend/builtins.bufo";

// Statically allocate arrays so we can put the Checker on the stack
// 640.000 functions should be enough for now
// NOTE: Index 0 is reserved for the global scope!
mut functions: [BCFunction; 640000] = blank;
mut funcCount: usize = 0;
func assertValidFunction(currFn: FnIndex, what: &char) -> usize {
    trace("assertValidFunction");
    let index: usize = currFn._i;
    assert_with_msg(index < funcCount, what);
    return index;
}
func getFnIndex(fn: &mut BCFunction) -> FnIndex {
    unsafe {
        let base: &mut BCFunction = &mut functions[0];
        let diff: usize = fn - base;
        assert(diff % sizeof BCFunction == 0);
        let id: usize = diff / sizeof BCFunction;
        assert(id < funcCount);
        return FnIndex { _i: id };
    }
}

func createBlankFunction() -> &mut BCFunction {
    let index: usize = funcCount;
    functions[index] = blank;
    funcCount = funcCount + 1;
    return &mut functions[index];
}

// 640.000 Typedefs should be enough for now
mut types: [BCType; 640000] = blank;
mut typeCount: usize = 0;
func assertValidType(ty: TypeIndex, what: &char) -> usize {
    trace("assertValidType");
    let index: usize = ty._i as usize;
    assert_with_msg(index < typeCount, what);
    return index;
}

func initializeGlobalTypes() {
    // FIXME: bool and anytype should create real BCTypes later on
    // FIXME: Maybe it would be cool to have comptime variables instead of magic numbers all over
    //        the place, like `comptime STRING_TYPE: usize = 3;`
    let i64: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(i64)._i == 0, "initializeGlobalTypes() called in wrong context");
    assert_with_msg(!i64.isValid(), "initializeGlobalTypes() called in wrong context");
    i64.makeIntegerType(64, true);
    let bool: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(bool)._i == 1, "initializeGlobalTypes() called in wrong context");
    let anytype: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(anytype)._i == 2, "initializeGlobalTypes() called in wrong context");
    let string: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(string)._i == 3, "initializeGlobalTypes() called in wrong context");
    let fun: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(fun)._i == 4, "initializeGlobalTypes() called in wrong context");
}

func createBlankType() -> &mut BCType {
    let index: usize = typeCount;
    assert_with_msg(!types[index].isValid(), "Attempted to overwrite valid BCType in createBlankType()");
    types[index] = blank;
    typeCount = typeCount + 1;
    return &mut types[index];
}

func getTypeID(typ: &mut BCType) -> TypeIndex {
    unsafe {
        let base: &mut BCType = &mut types[0];
        let diff: usize = typ - base;
        assert(diff % sizeof BCType == 0);
        let id: usize = diff / sizeof BCType;
        assert(id < typeCount);
        return TypeIndex { _i: id as u32, ptrData: 0 };
    }
}

struct NameVarIndexPair {
    name: SubStr;
    index: RegIndex;
}

struct GlobalEntry {
    node: &mut ParsedVarDecl;
    computed: bool;
    register: RegIndex;
}

struct GlobalScope {
    variables: &mut GlobalEntry;
    varLength: usize;
    varCapacity: usize;

    func checkExisting(&mut this, newVar: &mut ParsedVarDecl) -> bool {
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let var: &mut GlobalEntry = this.getEntryAtIndex(i);
            if (var.node.name.content.equals(&newVar.name.content)) {
                return true;
            }
        }
        return false;
    }

    func getEntryAtIndex(&mut this, index: usize) -> &mut GlobalEntry {
        assert_with_msg(index < this.varLength, "Out of bounds access in getEntryAtIndex");
        unsafe {
            return this.variables + index * sizeof GlobalEntry;
        }
    }

    func getVariableByName(&mut this, name: SubStr) -> &mut GlobalEntry {
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let entry: &mut GlobalEntry = this.getEntryAtIndex(i);
            if (entry.node.name.content.equals(&name))
                return entry;
        }
        unsafe {
            return null;
        }
    }

    func addVarDecl(&mut this, decl: &mut ParsedVarDecl) -> bool {
        trace("GlobalScope.addVarDecl");
        if (this.varLength >= this.varCapacity) unsafe {
            mut newCap: usize = this.varCapacity * 2;
            if (newCap == 0) newCap = 1;
            this.variables = realloc(this.variables, newCap * sizeof GlobalEntry);
            assert_with_msg(this.variables != null, "Could not resize variables");
            this.varCapacity = newCap;
        }
        if (this.checkExisting(decl)) unsafe {
            let entry: &mut GlobalEntry = this.getVariableByName(decl.name.content);
            assert(entry != null);
            let stderr: Any = fdopen(2, "a");
            let loc: String = decl.span.toString();
            let oLoc: String = entry.node.span.toString();
            let name: String = decl.name.toString();
            fprintf(stderr, "%s: %s: Redeclaration of global variable `%s`.\n%s: %s: Variable already declared here.\n", loc.chars(), ERR_STR, name.chars(), oLoc.chars(), NOTE_STR);
            loc.drop();
            oLoc.drop();
            name.drop();
            return false;
        }
        unsafe {
            let entry: GlobalEntry = GlobalEntry {
                node: decl,
                computed: false,
                register: blank
            };
            *(this.variables + this.varLength * sizeof GlobalEntry) = entry;
            this.varLength = this.varLength + 1;
        }
        return true;
    }
}

mut interpStack: [u8; 32000000] = blank;
mut argStack: [u8; 640000] = blank;
struct BCInterp {
    stackBase: &mut u8;
    argBase: &mut u8;
    unsafe func getStackAddr(&mut this, offset: usize) -> &mut u8 {
        return this.stackBase + offset;
    }
    func localStackCopy(&mut this, dstOffset: usize, srcOffset: usize, size: usize) {
        unsafe {
            let d: &mut u8 = this.getStackAddr(dstOffset);
            let s: &mut u8 = this.getStackAddr(srcOffset);
            memcpy(d, s, size);
        }
    }
    func typeCheckBCLoadNumber(&mut this, fn: &mut BCFunction, loadNumber: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoadNumber");
        assert(loadNumber.kind == INSTR_KIND_LOAD_NUMBER);
        let dst: RegIndex = loadNumber.dst;
        let reg: &mut BCReg = fn.getRegAtIndex(dst);
        (*reg).size = sizeof i64;
        (*reg).offset = fn.addOffset(reg.size);
        (*reg).typ = TypeIndex { _i: 0, ptrData: 0 };
        unsafe {
            *(this.getStackAddr(reg.offset) as &mut i64) = *(&loadNumber.src._i as &i64);
        }
        return true;
    }

    func typeCheckBCLoadString(&mut this, fn: &mut BCFunction, loadString: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoadString");
        assert(loadString.kind == INSTR_KIND_LOAD_STRING);
        let dst: RegIndex = loadString.dst;
        let ptr: RegIndex = loadString.src;
        let len: RegIndex = loadString.op1;
        let reg: &mut BCReg = fn.getRegAtIndex(dst);
        let size: usize = sizeof SubStr;
        assert_with_msg(size == 16, "LoadString expected sizeof SubStr == 16");
        (*reg).size = size;
        (*reg).offset = fn.addOffset(size);
        // FIXME: This should be a dedicated TYPE_STRING instead of a hardcoded value
        (*reg).typ = TypeIndex { _i: 3, ptrData: 0 };
        unsafe {
            let s: SubStr = SubStr {
                start: ptr._i as &char,
                len: len._i
            };
            *(this.getStackAddr(reg.offset) as &mut SubStr) = s;
        }
        return true;
    }

    func typeCheckBCStoreConst(&mut this, fn: &mut BCFunction, storeConst: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCStoreConst");
        assert(storeConst.kind == INSTR_KIND_STORE_CONST);
        let dst: RegIndex = storeConst.dst;
        let src: RegIndex = storeConst.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid src in StoreConst");
        (*dstReg).size = srcReg.size;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        (*dstReg).typ = srcReg.typ;

        this.localStackCopy(dstReg.offset, srcReg.offset, srcReg.size);

        return true;
    }

    func typeCheckBCLoad(&mut this, fn: &mut BCFunction, load: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoad");
        assert(load.kind == INSTR_KIND_LOAD);
        let dst: RegIndex = load.dst;
        let src: RegIndex = load.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid src in Load");
        (*dstReg).size = srcReg.size;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        (*dstReg).typ = srcReg.typ;

        this.localStackCopy(dstReg.offset, srcReg.offset, srcReg.size);

        return true;
    }

    func typeCheckBCAdd(&mut this, fn: &mut BCFunction, add: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAdd");
        assert(add.kind == INSTR_KIND_ADD);
        let dst: RegIndex = add.dst;
        let lhs: RegIndex = add.src;
        let rhs: RegIndex = add.op1;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let lhsReg: &mut BCReg = fn.getRegAtIndex(lhs);
        let rhsReg: &mut BCReg = fn.getRegAtIndex(rhs);
        assert_with_msg(lhsReg.isInitialized(), "expected valid lhs in Add");
        assert_with_msg(rhsReg.isInitialized(), "expected valid rhs in Add");
        if (!lhsReg.typ.equals(rhsReg.typ)) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = add.origin.toString();
            let lhsLoc: String = lhsReg.origin.toString();
            let rhsLoc: String = rhsReg.origin.toString();
            let lhsTyp: String = lhsReg.typ.toString();
            let rhsTyp: String = rhsReg.typ.toString();
            fprintf(stderr, "%s: %s: Type mismatch in binary addition!\n%s: %s: LHS has type %s.\n%s: %s: RHS has type %s.\n",
                loc.chars(), ERR_STR,
                lhsLoc.chars(), NOTE_STR, lhsTyp.chars(),
                rhsLoc.chars(), NOTE_STR, rhsTyp.chars()
            );
            loc.drop();
            return false;
        }
        assert(lhsReg.size == rhsReg.size);
        if (lhsReg.typ._i == 0) {
            assert(lhsReg.size == 8);
            (*dstReg).size = lhsReg.size;
            (*dstReg).offset = fn.addOffset(dstReg.size);
            (*dstReg).typ = lhsReg.typ;
            unsafe {
                let lhs: i64 = *(this.getStackAddr(lhsReg.offset) as &i64);
                let rhs: i64 = *(this.getStackAddr(rhsReg.offset) as &i64);
                let sum: i64 = lhs + rhs;
                let d: &mut u8 = this.getStackAddr(dstReg.offset);
                memcpy(d, &sum, lhsReg.size);
            }
            return true;
        } else {
            todo_with_msg("add for non-literals");
        }
        return false; // unreachable
    }

    func typeCheckBCEqual(&mut this, fn: &mut BCFunction, equal: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCEqual");
        assert(equal.kind == INSTR_KIND_EQUAL || equal.kind == INSTR_KIND_NOT_EQUAL);
        let not: bool = equal.kind == INSTR_KIND_NOT_EQUAL;
        let dst: RegIndex = equal.dst;
        let lhs: RegIndex = equal.src;
        let rhs: RegIndex = equal.op1;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let lhsReg: &mut BCReg = fn.getRegAtIndex(lhs);
        let rhsReg: &mut BCReg = fn.getRegAtIndex(rhs);
        assert_with_msg(lhsReg.isInitialized(), "expected valid lhs in Equal");
        assert_with_msg(rhsReg.isInitialized(), "expected valid rhs in Equal");
        if (!lhsReg.typ.equals(rhsReg.typ)) {
            todo_with_msg("report error: Type mismatch in typeCheckEqual");
        }
        assert(lhsReg.size == rhsReg.size);
        (*dstReg).size = 1;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        (*dstReg).typ = TypeIndex { _i: 1, ptrData: 0 };
        unsafe {
            let l: &mut u8 = this.getStackAddr(lhsReg.offset);
            let r: &mut u8 = this.getStackAddr(rhsReg.offset);
            let areEqual: bool = memcmp(l, r, lhsReg.size) == 0;
            mut res: u8 = 0;
            if (areEqual) res = 1;
            if (not) res = 1 - res;
            *(this.getStackAddr(dstReg.offset)) = res;
        }
        return true;
    }

    func typeCheckBCConstAssert(&mut this, fn: &mut BCFunction, assert: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCConstAssert");
        assert(assert.kind == INSTR_KIND_CONST_ASSERT);
        let what: RegIndex = assert.src;
        let whatReg: &mut BCReg = fn.getRegAtIndex(what);
        assert_with_msg(whatReg.isInitialized(), "expected valid reg in ConstAssert");
        // FIXME: Better way of detecting if this is a bool
        if (whatReg.typ._i != 1) {
            todo_with_msg("report error: Condition in ConstAssert is not bool");
        }
        unsafe {
            let success: bool = *(this.getStackAddr(whatReg.offset)) == 1;
            if (!success) unsafe {
                let stderr: Any = fdopen(2, "a");
                let loc: String = assert.origin.toString();
                fprintf(stderr, "%s: %s: Static assertion failed!\n", loc.chars(), ERR_STR);
                loc.drop();
                return false;
            }
        }
        return true;
    }

    func typeCheckBCCreateIntType(&mut this, fn: &mut BCFunction, int: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCreateIntType");
        assert(int.kind == INSTR_KIND_CREATE_INT_TYPE);
        let dst: RegIndex = int.dst;
        let size: RegIndex = int.src;
        let sign: RegIndex = int.op1;
        let sizeReg: &mut BCReg = fn.getRegAtIndex(size);
        let signReg: &mut BCReg = fn.getRegAtIndex(sign);
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        assert_with_msg(sizeReg.isInitialized(), "expected valid size in CreateIntType");
        assert_with_msg(signReg.isInitialized(), "expected valid sign in CreateIntType");
        // FIXME: Better way of checking these types
        if (sizeReg.typ._i != 0) {
            todo_with_msg("report error: Size in CreateIntType is not int");
        }
        if (signReg.typ._i != 1) {
            todo_with_msg("report error: Sign in CreateIntType is not bool");
        }
        assert(sizeReg.size == 8);
        assert(signReg.size == 1);
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        // FIXME: This should be indexof(TYPE_TYPE), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 2, ptrData: 0 };
        unsafe {
            let bitsize: i64 = *(this.getStackAddr(sizeReg.offset) as &i64);
            if (bitsize < 0 || bitsize > 65536) {
                todo_with_msg("report error: Integer bitsize invalid");
            }
            let signed: bool = *(this.getStackAddr(sizeReg.offset)) == 1;
            let int: &mut BCType = createBlankType();
            int.makeIntegerType(bitsize as u32, signed);
            let id: TypeIndex = getTypeID(int);
            *(this.getStackAddr(dstReg.offset) as &mut TypeIndex) = id;
        }
        return true;
    }

    func typeCheckBCCreateStructType(&mut this, fn: &mut BCFunction, strukt: &mut BCInstr) -> bool {
        trace("BCStructerp.typeCheckBCCreateStructType");
        assert(strukt.kind == INSTR_KIND_CREATE_STRUCT_TYPE);
        let dst: RegIndex = strukt.dst;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        // FIXME: This should be indexof(TYPE_TYPE), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 2, ptrData: 0 };
        unsafe {
            let sType: &mut BCType = createBlankType();
            sType.makeStructType();
            let id: TypeIndex = getTypeID(sType);
            *(this.getStackAddr(dstReg.offset) as &mut TypeIndex) = id;
        }
        return true;
    }

    func typeCheckBCCreateFuncType(&mut this, fn: &mut BCFunction, createFunc: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCreateFuncType");
        assert(createFunc.kind == INSTR_KIND_CREATE_FUNC_TYPE);
        let dst: RegIndex = createFunc.dst;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        // FIXME: This should be indexof(TYPE_FUNC), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 4, ptrData: 0 };
        unsafe {
            let fType: &mut BCType = createBlankType();
            let fun: &mut BCFunction = createBlankFunction();
            fType.makeFuncType(fun);
            let id: TypeIndex = getTypeID(fType);
            *(this.getStackAddr(dstReg.offset) as &mut TypeIndex) = id;
        }
        return true;
    }

    func typeCheckBCCreateNoneType(&mut this, fn: &mut BCFunction, createNone: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCreateNoneType");
        assert(createNone.kind == INSTR_KIND_CREATE_NONE_TYPE);
        let dst: RegIndex = createNone.dst;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        // FIXME: This should be indexof(TYPE_TYPE), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 2, ptrData: 0 };
        unsafe {
            let fType: &mut BCType = createBlankType();
            fType.makeNoneType();
            let id: TypeIndex = getTypeID(fType);
            *(this.getStackAddr(dstReg.offset) as &mut TypeIndex) = id;
        }
        return true;
    }

    func typeCheckBCCreateAnytypeType(&mut this, fn: &mut BCFunction, createAnytype: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCreateAnytypeType");
        assert(createAnytype.kind == INSTR_KIND_CREATE_ANYTYPE_TYPE);
        let dst: RegIndex = createAnytype.dst;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        // FIXME: This should be indexof(TYPE_TYPE), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 2, ptrData: 0 };
        unsafe {
            // REVIEW: This feels wrong
            let id: TypeIndex = TypeIndex { _i: 2, ptrData: 0 };
            *(this.getStackAddr(dstReg.offset) as &mut TypeIndex) = id;
        }
        return true;
    }

    func typeCheckBCAddrOf(&mut this, fn: &mut BCFunction, addrof: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddrOf");
        assert(addrof.kind == INSTR_KIND_ADDR_OF);
        let dst: RegIndex = addrof.dst;
        let src: RegIndex = addrof.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid size in AddrOf");
        (*dstReg).size = 8;
        (*dstReg).offset = fn.addOffset(dstReg.size);
        (*dstReg).typ = srcReg.typ;
        (*dstReg).typ.makePointer();
        unsafe {
            let addr: &mut u8 = this.getStackAddr(srcReg.offset);
            *(this.getStackAddr(dstReg.offset) as &mut usize) = addr as usize;
        }
        return true;
    }

    func typeCheckBCLoadAddr(&mut this, fn: &mut BCFunction, loadaddr: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoadAddr");
        assert(loadaddr.kind == INSTR_KIND_LOAD_ADDR);
        let dst: RegIndex = loadaddr.dst;
        let src: RegIndex = loadaddr.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid size in LoadAddr");
        if (!srcReg.typ.isPointer()) {
            todo_with_msg("report error: LoadAddr has non-pointer");
        }
        (*dstReg).typ = srcReg.typ.getUnderlying();
        let size: usize = dstReg.typ.getSize();
        (*dstReg).size = size;
        (*dstReg).offset = fn.addOffset(size);
        unsafe {
            let addr: usize = *(*(this.getStackAddr(srcReg.offset) as &usize) as &usize);
            *(this.getStackAddr(dstReg.offset) as &mut usize) = addr;
        }
        return true;
    }

    func typeCheckBCVerifyType(&mut this, fn: &mut BCFunction, verify: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCVerifyType");
        assert(verify.kind == INSTR_KIND_VERIFY_TYPE);
        let src: RegIndex = verify.src;
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid reg in VerifyType");
        if (srcReg.typ._i != 2) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = verify.origin.toString();
            fprintf(stderr, "%s: %s: Expected expression to evaluate to a type.\n", loc.chars(), ERR_STR);
            loc.drop();
            return false;
        }
        return true;
    }

    func typeCheckBCAddField(&mut this, fn: &mut BCFunction, addField: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddField");
        assert(addField.kind == INSTR_KIND_ADD_FIELD);
        let base: RegIndex = addField.dst;
        let name: RegIndex = addField.src;
        let typ: RegIndex = addField.op1;
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        let nameReg: &mut BCReg = fn.getRegAtIndex(name);
        let typReg: &mut BCReg = fn.getRegAtIndex(typ);
        assert_with_msg(baseReg.isInitialized(), "expected valid base in AddField");
        assert_with_msg(nameReg.isInitialized(), "expected valid name in AddField");
        assert_with_msg(typReg.isInitialized(), "expected valid type in AddField");
        // FIXME: Unhardcode the Type IDs
        if (baseReg.typ._i != 2) {
            todo_with_msg("AddField got non-type as base");
        }
        if (nameReg.typ._i != 3) {
            todo_with_msg("AddField got non-string as name");
        }
        unsafe {
            let baseType: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let fieldName: SubStr = *(this.getStackAddr(nameReg.offset) as &SubStr);
            let fieldType: TypeIndex = *(this.getStackAddr(typReg.offset) as &TypeIndex);
            let structType: &mut BCType = &mut types[assertValidType(baseType, "AddField")];
            if (!structType.isStruct()) {
                todo_with_msg("huh, this is actually unreachable. If you see this, there is a compiler bug :^)");
            }
            return structType.addField(addField.origin, fieldName, fieldType);
        }
    }

    func typeCheckBCAddParam(&mut this, fn: &mut BCFunction, addParam: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddParam");
        assert(addParam.kind == INSTR_KIND_ADD_PARAM);
        let base: RegIndex = addParam.dst;
        let name: RegIndex = addParam.src;
        let typ: RegIndex = addParam.op1;
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        let nameReg: &mut BCReg = fn.getRegAtIndex(name);
        let typReg: &mut BCReg = fn.getRegAtIndex(typ);
        assert_with_msg(baseReg.isInitialized(), "expected valid base in AddParam");
        assert_with_msg(nameReg.isInitialized(), "expected valid name in AddParam");
        assert_with_msg(typReg.isInitialized(), "expected valid type in AddParam");
        // FIXME: Unhardcode the Type IDs
        if (baseReg.typ._i != 4) {
            todo_with_msg("AddParam got non-func as base");
        }
        if (nameReg.typ._i != 3) {
            todo_with_msg("AddParam got non-string as name");
        }
        unsafe {
            let baseType: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let fieldName: SubStr = *(this.getStackAddr(nameReg.offset) as &SubStr);
            let fieldType: TypeIndex = *(this.getStackAddr(typReg.offset) as &TypeIndex);
            let funcType: &mut BCType = &mut types[assertValidType(baseType, "AddParam")];
            if (!funcType.isFunc()) {
                todo_with_msg("huh, this is actually unreachable. If you see this, there is a compiler bug :^)");
            }
            return funcType.addParam(addParam.origin, fieldName, fieldType);
        }
    }

    func typeCheckBCAddFuncNode(&mut this, fn: &mut BCFunction, addFn: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddFuncNode");
        assert(addFn.kind == INSTR_KIND_ADD_FUNC_NODE);
        let base: RegIndex = addFn.dst;
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        assert_with_msg(baseReg.isInitialized(), "expected valid base in AddFuncNode");
        if (baseReg.typ._i != 4) {
            todo_with_msg("AddFuncNode got non-func as base");
        }
        unsafe {
            let baseType: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let node: &mut ParsedFuncDecl = addFn.src._i as &mut ParsedFuncDecl;
            let funcType: &mut BCType = &mut types[assertValidType(baseType, "AddFuncNode")];
            assert(funcType.isFunc()); // TypeID is 4, so this is a function
            funcType.funcInfo.function.setFuncNode(node);
        }
        return true;
    }

    func typeCheckBCAddRetType(&mut this, fn: &mut BCFunction, addRetType: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddRetType");
        assert(addRetType.kind == INSTR_KIND_ADD_RET_TYPE);
        let base: RegIndex = addRetType.dst;
        let typ: RegIndex = addRetType.src;
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        let typReg: &mut BCReg = fn.getRegAtIndex(typ);
        assert_with_msg(typReg.isInitialized(), "expected valid type in AddReturnType");
        assert_with_msg(baseReg.isInitialized(), "expected valid base in AddReturnType");
        // FIXME: Unhardcode those IDs :^)
        if (typReg.typ._i != 2) {
            todo_with_msg("AddReturnType got non-type as type???");
        }
        if (baseReg.typ._i != 4) {
            todo_with_msg("AddReturnType got non-func as base");
        }
        unsafe {
            let baseType: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let retType: TypeIndex = *(this.getStackAddr(typReg.offset) as &TypeIndex);
            let funcType: &mut BCType = &mut types[assertValidType(baseType, "AddReturnType")];
            assert(funcType.isFunc()); // TypeID is 4, so this is a function
            funcType.addReturnType(retType);
        }
        return true;
    }

    func typeCheckBCAddCallArg(&mut this, fn: &mut BCFunction, addCallArg: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAddCallArg");
        assert(addCallArg.kind == INSTR_KIND_ADD_CALL_ARG);
        let base: RegIndex = addCallArg.dst;
        let argNr: usize = addCallArg.src._i;
        let arg: RegIndex = addCallArg.op1;
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        let argReg: &mut BCReg = fn.getRegAtIndex(arg);
        assert_with_msg(argReg.isInitialized(), "expected valid arg in AddCallArg");
        assert_with_msg(baseReg.isInitialized(), "expected valid base in AddCallArg");
        if (baseReg.typ._i != 4) {
            todo_with_msg("add call arg not a func");
        }
        unsafe {
            let fnTypeIndex: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let fnType: &mut BCType = &mut types[assertValidType(fnTypeIndex, "func call")];
            assert(fnType.isFunc()); // TypeID is 4
            if (argNr >= fnType.funcInfo.paramCount) unsafe {
                let stderr: Any = fdopen(2, "a");
                let loc: String = addCallArg.origin.toString();
                // FIXME: This is not necessarily a function, it could also be a struct?
                fprintf(stderr, "%s: %s: Received too many arguments for call to function.\n", loc.chars(), ERR_STR);
                return false;
            }
            let argType: TypeIndex = argReg.typ;
            if (!argType.equals(fnType.funcInfo.paramTypes[argNr])) {
                todo_with_msg("call arg type wrong");
            }
            *(this.argBase as &mut TypeIndex) = argType;
            this.argBase = this.argBase + sizeof TypeIndex;
            memcpy(this.argBase, this.getStackAddr(argReg.offset), argReg.size);
            this.argBase = this.argBase + argReg.size;
        }
        return true;
    }

    func typeCheckBCCall(&mut this, checker: &mut Checker, fn: &mut BCFunction, call: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCall");
        assert(call.kind == INSTR_KIND_CALL);
        let dst: RegIndex = call.dst;
        let base: RegIndex = call.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let baseReg: &mut BCReg = fn.getRegAtIndex(base);
        assert_with_msg(baseReg.isInitialized(), "expected valid base in Call");
        if (baseReg.typ._i != 4) {
            todo_with_msg("call base not a func");
        }
        unsafe {
            let fnTypeIndex: TypeIndex = *(this.getStackAddr(baseReg.offset) as &TypeIndex);
            let fnType: &mut BCType = &mut types[assertValidType(fnTypeIndex, "func call")];
            assert(fnType.isFunc()); // TypeID is 4
            let fun: &mut BCFunction = fnType.funcInfo.function;
            if (!fun.isGenerated) {
                assert(fun.varLength == 0);
                assert(fun.regLength == 0);
                assert(fun.instrLength == 0);
                let node: &mut ParsedFuncDecl = fun.funcDecl;
                for (mut i: usize = node.paramCount - 1; i >= 0; i = i - 1) {
                    let _span: Span = fnType.funcInfo.paramSpans[i];
                    let _name: SubStr = fnType.funcInfo.paramNames[i];
                    let _typ: TypeIndex = fnType.funcInfo.paramTypes[i];
                    fun.buildParamStore(_span, _name, _typ);
                }
                for (mut i: usize = 0; i < node.stmtCount; i = i + 1) {
                    if (!checker.generateBytecodeStmt(getFnIndex(fun), node.getStmtAtIndex(i)))
                        return false;
                }
                (*fun).isGenerated = true;
            }
            let stack: &mut u8 = this.stackBase;
            unsafe { this.stackBase = this.stackBase + fn.stackSize; }
            if (!this.typeCheckFunction(checker, getFnIndex(fun))) {
                // Assume error is already reported
                return false;
            }
            this.stackBase = stack;
            mut _retType: TypeIndex = fnType.funcInfo.retType;
            unsafe {
                let size: usize = _retType.getSize();
                (*dstReg).size = size;
                (*dstReg).offset = fn.addOffset(dstReg.size);
                this.argBase = this.argBase - size;
                memcpy(this.getStackAddr(dstReg.offset), this.argBase, size);
                mut retType: TypeIndex = blank;
                mut retStart: &mut u8 = this.argBase - size;
                this.argBase = this.argBase - sizeof TypeIndex;
                memcpy(&mut retType, retStart, sizeof TypeIndex);
                assertValidType(retType, "call return");
                (*dstReg).typ = retType;
            }
        }
        return true;
    }

    func typeCheckBCStoreParam(&mut this, fn: &mut BCFunction, storeParam: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCStoreParam");
        assert(storeParam.kind == INSTR_KIND_STORE_PARAM);
        let dst: RegIndex = storeParam.dst;
        let size: usize = storeParam.src._i;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        unsafe {
            mut paramType: TypeIndex = blank;
            mut paramStart: &mut u8 = this.argBase - size;
            memcpy(&mut paramType, paramStart, sizeof TypeIndex);
            assertValidType(paramType, "store param");
            paramStart = paramStart + sizeof TypeIndex;
            (*dstReg).size = size - sizeof TypeIndex;
            (*dstReg).offset = fn.addOffset(dstReg.size);
            memcpy(this.getStackAddr(dstReg.offset), paramStart, dstReg.size);
            (*dstReg).typ = paramType;
            this.argBase = this.argBase - size;
        }
        return true;
    }

    func typeCheckBCReturn(&mut this, fn: &mut BCFunction, ret: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCReturn");
        assert(ret.kind == INSTR_KIND_RETURN);
        assert(!getFnIndex(fn).isGlobalFn());
        let src: RegIndex = ret.src;
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid src in Return");
        let fnType: TypeIndex = fn.funcType;
        let typ: &mut BCType = &mut types[assertValidType(fnType, "return")];
        assert(typ.isFunc());
        mut retType: TypeIndex = typ.funcInfo.retType;
        if (!retType.equals(srcReg.typ)) {
            todo_with_msg("return type mismatch");
        }
        unsafe {
            let size: usize = retType.getSize();
            assert(size == srcReg.size);
            *(this.argBase as &mut TypeIndex) = retType;
            this.argBase = this.argBase + sizeof TypeIndex;
            memcpy(this.argBase, this.getStackAddr(srcReg.offset), size);
            this.argBase = this.argBase + size;
        }
        return true;
    }

    func typeCheckFunction(&mut this, checker: &mut Checker, fnIndex: FnIndex) -> bool {
        unsafe { assert_with_msg(this.stackBase != null, "typeCheckFunction called in wrong context"); }
        trace("BCInterp.typeCheckFunction");
        let fn: &mut BCFunction = &mut functions[assertValidFunction(fnIndex, "typeCheckFunction")];
        for (mut i: usize = 0; i < fn.instrLength; i = i + 1) {
            let instr: &mut BCInstr = fn.getInstrAtIndex(InstrIndex { _i: i });
            if (PRINT_DEBUG) unsafe {
                printf("%s\n", instr.toString().chars());
            }
            if (instr.kind == INSTR_KIND_LOAD_NUMBER) {
                if (!this.typeCheckBCLoadNumber(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_LOAD_STRING) {
                if (!this.typeCheckBCLoadString(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_STORE_CONST) {
                if (!this.typeCheckBCStoreConst(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_LOAD) {
                if (!this.typeCheckBCLoad(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD) {
                if (!this.typeCheckBCAdd(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_EQUAL || instr.kind == INSTR_KIND_NOT_EQUAL) {
                if (!this.typeCheckBCEqual(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CONST_ASSERT) {
                if (!this.typeCheckBCConstAssert(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_INT_TYPE) {
                if (!this.typeCheckBCCreateIntType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_STRUCT_TYPE) {
                if (!this.typeCheckBCCreateStructType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_FUNC_TYPE) {
                if (!this.typeCheckBCCreateFuncType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_NONE_TYPE) {
                if (!this.typeCheckBCCreateNoneType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_ANYTYPE_TYPE) {
                if (!this.typeCheckBCCreateAnytypeType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADDR_OF) {
                if (!this.typeCheckBCAddrOf(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_LOAD_ADDR) {
                if (!this.typeCheckBCLoadAddr(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_VERIFY_TYPE) {
                if (!this.typeCheckBCVerifyType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD_FIELD) {
                if (!this.typeCheckBCAddField(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD_PARAM) {
                if (!this.typeCheckBCAddParam(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD_FUNC_NODE) {
                if (!this.typeCheckBCAddFuncNode(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD_RET_TYPE) {
                if (!this.typeCheckBCAddRetType(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD_CALL_ARG) {
                if (!this.typeCheckBCAddCallArg(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CALL) {
                if (!this.typeCheckBCCall(checker, fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_STORE_PARAM) {
                if (!this.typeCheckBCStoreParam(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_RETURN) {
                if (!this.typeCheckBCReturn(fn, instr)) {
                    return false;
                }
            } else {
                debug(instr.toString().chars());
                todo_with_msg("can't check unknown BCInstr");
            }
        }
        if (PRINT_DEBUG) unsafe {
            printf("--- AFTER TYPE CHECK ---\n");
            fn.dump();
        }
        return true;
    }
}

func newBCInterp() -> BCInterp {
    return BCInterp {
        stackBase: &mut interpStack[0],
        argBase: &mut argStack[0],
    };
}

struct Checker {
    globalScope: GlobalScope;
    func dumpAllFunctions(&mut this) {
        unsafe {
            printf("GLOBAL SCOPE:\n");
            functions[0].dump();
            for (mut i: usize = 1; i < funcCount; i = i + 1) {
                printf("Function %llu:\n", i);
                functions[i].dump();
            }
        }
    }
    func addFunction(&mut this, span: Span) -> FnIndex {
        // FIXME: This function should be in the global scope
        trace("Checker.addFunction");
        let index: FnIndex = FnIndex { _i: funcCount };
        functions[funcCount] = newEmptyFunction(span);
        funcCount = funcCount + 1;
        return index;
    }
    func leaveFunction(&mut this, fn: FnIndex) {
        trace("Checker.leaveFunction");
    }
    func storeVariable(&mut this, currFn: FnIndex, origin: Span, name: SubStr, val: RegIndex, isConst: bool) -> bool {
        trace("Checker.storeVariable");
        let index: usize = assertValidFunction(currFn, "Can not generate store in invalid fn index");
        if (isConst) {
            return functions[index].buildConstStore(origin, name, val);
        } else {
            todo_with_msg("storeVariable let");
            return false;
        }
    }
    func loadVariable(&mut this, currFn: FnIndex, ident: &mut ParsedDeclValueIdent, wantsAddr: bool) -> RegIndex {
        let index: usize = assertValidFunction(currFn, "Can not generate load in invalid fn index");
        mut reg: RegIndex = blank;
        let success: bool = functions[index].buildLoad(ident.span, ident.name, &mut reg, wantsAddr);
        if (!success) unsafe {
            let entry: &mut GlobalEntry = this.globalScope.getVariableByName(ident.name);
            if (entry == null) {
                ident.name.print();
                todo_with_msg("no variable found");
            }
            if (entry.computed) {
                // NOTE: Register Index 0 implies that the value that we'd store was located at Index -1 or lower.
                //       We can use it for this check, because GlobalEntry's are initialized with `blank`, setting the register to 0.
                if (entry.register._i == 0) unsafe {
                    assert_with_msg(entry.node != null, "fatal error when trying to report an error: GlobalEntry-Node is null :^) Can't get location");
                    let stderr: Any = fdopen(2, "a");
                    let loc: String = entry.node.span.toString();
                    fprintf(stderr, "%s: %s: Recursive global declaration.\n", loc.chars(), ERR_STR);
                    loc.drop();
                    exit(1);
                }
                return entry.register;
            }
            (*entry).computed = true;
            let global: FnIndex = FnIndex { _i: 0 };
            let success: bool = this.generateBytecodeVarDecl(global, entry.node);
            if (!success) todo_with_msg("failed to generate global");
            assert(functions[index].buildLoad(ident.span, ident.name, &mut reg, wantsAddr));
            (*entry).register = reg;
        }
        return reg;
    }

    func warnUnusedGlobals(&mut this) {
        mut any: bool = false;
        for (mut i: usize = 0; i < this.globalScope.varLength; i = i + 1) {
            let entry: &mut GlobalEntry = this.globalScope.getEntryAtIndex(i);
            if (!entry.computed) unsafe {
                let loc: String = entry.node.name.span.toString();
                let name: String = entry.node.name.content.toString();
                printf("%s: warning: Unused global constant `%s`.\n", loc.chars(), name.chars());
                name.drop();
                loc.drop();
                any = true;
            }
        }
        if (any) unsafe {
            printf("note: Unused variables are not considered for further validation steps.\n");
        }
    }

    func generateGlobalDeclarations(&mut this, project: &mut ParsedModule) -> bool {
        trace("Checker.generateGlobalDeclarations");
        let globalFn: FnIndex = this.addFunction(project.span);
        assert_with_msg(globalFn.isGlobalFn(), "generateGlobalDeclarations called in wrong context");
        for (mut i: usize = 0; i < project.declCount; i = i + 1) {
            let decl: &mut ParsedGlobalDecl = project.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL) {
                if (!this.globalScope.addVarDecl(decl.data))
                    return false;
            }
        }
        for (mut i: usize = 0; i < project.declCount; i = i + 1) {
            let decl: &mut ParsedGlobalDecl = project.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL) unsafe {
                let data: &mut ParsedVarDecl = decl.data;
                let entry: &mut GlobalEntry = this.globalScope.getVariableByName(data.name.content);
                assert(entry != null);
                if (entry.computed) continue;
                (*entry).computed = true;
                if (!this.generateBytecodeVarDecl(globalFn, decl.data))
                    return false;
            } else if (decl.kind == GLOBAL_DIR) {
                if (!this.generateBytecodeDirective(globalFn, decl.data))
                    return false;
            }
        }
        this.leaveFunction(globalFn);
        return true;
    }

    func generateBytecode(&mut this, project: &mut ParsedModule) -> bool {
        trace("Checker.generateBytecode");
        initializeGlobalTypes();
        if (!this.generateGlobalDeclarations(project))
            return false;
        this.warnUnusedGlobals();
        if (PRINT_DEBUG) this.dumpAllFunctions();
        return true;
    }

    func generateBytecodeStmt(&mut this, currFn: FnIndex, stmt: &mut ParsedStmt) -> bool {
        trace("Checker.generateBytecodeStmt");
        if (stmt.kind == STMT_VAR_DECL) {
            return this.generateBytecodeVarDecl(currFn, stmt.data);
        } else if (stmt.kind == STMT_RETURN) unsafe {
            let reg: RegIndex = this.generateBytecodeDeclValue(currFn, stmt.data, false);
            return functions[assertValidFunction(currFn, "return")].buildReturn(stmt.span, reg);
        }
        todo_with_msg("stmt");
        return true;
    }

    func generateBytecodeDirective(&mut this, currFn: FnIndex, dir: &mut ParsedDeclValue) -> bool {
        trace("Checker.generateBytecodeDirective");
        if (dir.kind != DECL_VALUE_BUILTIN) todo_with_msg("only builtins are supported in a global context");
        this.generateBytecodeBuiltin(currFn, dir.data);
        return true;
    }

    func generateBytecodeVarDecl(&mut this, currFn: FnIndex, decl: &mut ParsedVarDecl) -> bool {
        trace("Checker.generateBytecodeVarDecl");
        let isConst: bool = decl.isConst;
        if (!currFn.isGlobalFn()) {
            todo_with_msg("local var");
            // Global declarations have already been added
        }
        let register: RegIndex = this.generateBytecodeDeclValue(currFn, &mut decl.value, false);
        return this.storeVariable(currFn, decl.name.span, decl.name.content, register, isConst);
    }
    func generateBytecodeDeclValue(&mut this, currFn: FnIndex, expr: &mut ParsedDeclValue, wantsAddr: bool) -> RegIndex {
        trace("Checker.generateBytecodeDeclValue");
        if (expr.kind == DECL_VALUE_INVALID) todo_with_msg("bytecode DECL_VALUE_INVALID");
        else if (expr.kind == DECL_VALUE_MODULE) todo_with_msg("bytecode DECL_VALUE_MODULE");
        else if (expr.kind == DECL_VALUE_FUNC_DECL) {
            return this.generateBytecodeFuncDecl(currFn, expr.data);
        } else if (expr.kind == DECL_VALUE_STRUCT_DECL) {
            return this.generateBytecodeStructDecl(currFn, expr.data);
        } else if (expr.kind == DECL_VALUE_ENUM_DECL) todo_with_msg("bytecode DECL_VALUE_ENUM_DECL");
        else if (expr.kind == DECL_VALUE_UNION_DECL) todo_with_msg("bytecode DECL_VALUE_UNION_DECL");
        else if (expr.kind == DECL_VALUE_BUILTIN)
            return this.generateBytecodeBuiltin(currFn, expr.data);
        else if (expr.kind == DECL_VALUE_CALL) unsafe {
            let call: &mut ParsedDeclValueCall = expr.data;
            let base: RegIndex = this.generateBytecodeDeclValue(currFn, &mut call.fn, false); // REVIEW: Do we want addr?
            for (mut i: usize = 0; i < call.argCount; i = i + 1) {
                let arg: RegIndex = this.generateBytecodeDeclValue(currFn, &mut call.args[i], false);
                functions[assertValidFunction(currFn, "func call")].buildAddCallArgument(call.args[i].span, base, i, arg);
            }
            return functions[assertValidFunction(currFn, "func call")].buildCall(call.span, base);
        } else if (expr.kind == DECL_VALUE_IDENT) unsafe {
            let ident: &mut ParsedDeclValueIdent = expr.data;
            return this.loadVariable(currFn, ident, wantsAddr);
        } else if (expr.kind == DECL_VALUE_BINARY)
            return this.generateBytecodeBinary(currFn, expr.data);
        else if (expr.kind == DECL_VALUE_NUMBER) unsafe {
            let number: &mut ParsedDeclValueNumber = expr.data;
            let _n: String = number.number.toString();
            let int: i64 = _n.toI64();
            _n.drop();
            return functions[assertValidFunction(currFn, "number literal")].buildNumberLiteral(number.span, int);
        } else if (expr.kind == DECL_VALUE_STRING) unsafe {
            let number: &mut ParsedDeclValueString = expr.data;
            return functions[assertValidFunction(currFn, "number literal")].buildStringLiteral(number.span, number.string);
        } else if (expr.kind == DECL_VALUE_BLOCK) todo_with_msg("bytecode DECL_VALUE_BLOCK");
        else if (expr.kind == DECL_VALUE_IF) todo_with_msg("bytecode DECL_VALUE_IF");
        else if (expr.kind == DECL_VALUE_UNARY) unsafe {
            return this.generateBytecodeUnary(currFn, expr.data);
        } else {
            assert_with_msg(false, "exhaustive handling in generateBytecodeDeclValue");
        }
        todo_with_msg("decl value");
        return blank;
    }

    func generateBytecodeFuncDecl(&mut this, currFn: FnIndex, funcDecl: &mut ParsedFuncDecl) -> RegIndex {
        trace("Checker.generateBytecodeFuncDecl");
        let base: RegIndex = functions[assertValidFunction(currFn, "func decl")].buildCreateFunc(funcDecl.span);
        for (mut i: usize = 0; i < funcDecl.paramCount; i = i + 1) {
            let param: &mut ParsedParam = funcDecl.getParamAtIndex(i);
            let reg: RegIndex = this.generateBytecodeTypeExpr(currFn, &mut param.typ);
            let name: RegIndex = functions[assertValidFunction(currFn, "func decl param name")].buildStringLiteral(param.span, param.name);
            functions[assertValidFunction(currFn, "func decl param")].buildAddParam(param.span, base, name, reg);
        }
        let ret: RegIndex = this.generateBytecodeTypeExpr(currFn, &mut funcDecl.retType);
        functions[assertValidFunction(currFn, "func decl ret type")].buildAddReturnType(funcDecl.retType.span, base, ret);
        functions[assertValidFunction(currFn, "func decl node")].buildAddFuncNode(funcDecl.span, base, funcDecl);
        return base;
    }

    func generateBytecodeStructDecl(&mut this, currFn: FnIndex, structDecl: &mut ParsedStructDecl) -> RegIndex {
        trace("Checker.generateBytecodeStructDecl");
        let base: RegIndex = functions[assertValidFunction(currFn, "struct decl")].buildCreateStruct(structDecl.span);
        for (mut i: usize = 0; i < structDecl.fieldCount; i = i + 1) {
            let field: &mut ParsedStructField = structDecl.getFieldAtIndex(i);
            let reg: RegIndex = this.generateBytecodeTypeExpr(currFn, &mut field.typ);
            let name: RegIndex = functions[assertValidFunction(currFn, "struct decl field name")].buildStringLiteral(field.span, field.name);
            functions[assertValidFunction(currFn, "struct decl field")].buildAddField(structDecl.span, base, name, reg);
        }
        // REVIEW: Do we want to have assets?
        for (mut i: usize = 0; i < structDecl.assetCount; i = i + 1) {
            let asset: &mut ParsedStructAsset = structDecl.getAssetAtIndex(i);
            todo_with_msg("struct asset");
        }
        return base;
    }

    func generateBytecodeTypeExpr(&mut this, currFn: FnIndex, typeExpr: &mut ParsedTypeExpr) -> RegIndex {
        trace("Checker.generateBytecodeTypeExpr");
        let expr: RegIndex = this.generateBytecodeDeclValue(currFn, &mut typeExpr.expr, false);
        functions[assertValidFunction(currFn, "type expr")].buildVerifyType(typeExpr.span, expr);
        return expr;
    }

    func generateBytecodeUnary(&mut this, currFn: FnIndex, unary: &mut ParsedDeclValueUnary) -> RegIndex {
        trace("Checker.generateBytecodeUnary");
        if (unary.op == UNARY_OP_REF) {
            let reg: RegIndex = this.generateBytecodeDeclValue(currFn, &mut unary.expr, true);
            return functions[assertValidFunction(currFn, "unary operation")].buildAddrOf(unary.span, reg);
        } else {
            let reg: RegIndex = this.generateBytecodeDeclValue(currFn, &mut unary.expr, false);
            return functions[assertValidFunction(currFn, "unary operation")].buildLoadAddr(unary.span, reg);
        }
    }

    func generateBytecodeBinary(&mut this, currFn: FnIndex, binary: &mut ParsedDeclValueBinary) -> RegIndex {
        trace("Checker.generateBytecodeBinary");
        if (binary.op == BINARY_OP_ASSIGN) todo_with_msg("binary assignment");
        let lhs: RegIndex = this.generateBytecodeDeclValue(currFn, &mut binary.lhs, false);
        let rhs: RegIndex = this.generateBytecodeDeclValue(currFn, &mut binary.rhs, false);
        return functions[assertValidFunction(currFn, "binary operation")].buildBinaryOp(binary.span, lhs, rhs, binary.op);
    }

    func generateBytecodeBuiltin(&mut this, currFn: FnIndex, builtin: &mut ParsedDeclValueBuiltin) -> RegIndex {
        trace("Checker.generateBytecodeBuiltin");
        let name: SubStr = builtin.name;
        if (name.equals(&BUILTIN_INTEGER)) {
            if (builtin.argCount != 2) todo_with_msg("@integer() wrong arg count");
            let size: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[0], false);
            let signed: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[1], false);
            return functions[assertValidFunction(currFn, "@integer()")].buildCreateInteger(builtin.span, size, signed);
        } else if (name.equals(&BUILTIN_FLOAT)) todo_with_msg("BUILTIN_FLOAT");
        else if (name.equals(&BUILTIN_BOOLEAN)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_SELF)) todo_with_msg("BUILTIN_SELF");
        else if (name.equals(&BUILTIN_ANYTYPE)) {
            if (builtin.argCount != 0) todo_with_msg("@anytype() wrong arg count");
            return functions[assertValidFunction(currFn, "@anytype()")].buildCreateAnytype(builtin.span);
        } else if (name.equals(&BUILTIN_ANYVALUE)) todo_with_msg("BUILTIN_ANYVALUE");
        else if (name.equals(&BUILTIN_NONE)) {
            if (builtin.argCount != 0) todo_with_msg("@none() wrong arg count");
            return functions[assertValidFunction(currFn, "@none()")].buildCreateNone(builtin.span);
        } else if (name.equals(&BUILTIN_ENTRY)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_ASSERT)) {
            if (builtin.argCount != 1) todo_with_msg("@assert() wrong arg count");
            let what: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[0], false);
            return functions[assertValidFunction(currFn, "@assert()")].buildConstAssert(builtin.span, what);
        } else if (name.equals(&BUILTIN_TYPEOF)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_CHECK)) {
            // FIXME: This "leaks" registers, which are then <uninit> in the end
            for (mut i: usize = 0; i < builtin.argCount; i = i + 1) {
                let _what: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[i], false);
            }
            return blank;
        } else todo_with_msg("unknown builtin");
        return blank;
    }

    func verifyBytecode(&mut this) -> bool {
        trace("Checker.verifyBytecode");
        mut interp: BCInterp = newBCInterp();
        let globalFn: FnIndex = FnIndex { _i: 0 };
        return interp.typeCheckFunction(this, globalFn);
    }
}

func newChecker() -> Checker {
    return Checker {
        globalScope: blank,
    };
}
