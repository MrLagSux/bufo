import "stage1/middleend/bytecode.bufo";
import "stage1/middleend/builtins.bufo";

// Statically allocate arrays so we can put the Checker on the stack
// 640.000 functions should be enough for now
// NOTE: Index 0 is reserved for the global scope!
mut functions: [BCFunction; 640000] = blank;
mut funcCount: usize = 0;
func assertValidFunction(currFn: FnIndex, what: &char) -> usize {
    trace("assertValidFunction");
    let index: usize = currFn._i;
    assert_with_msg(index < funcCount, what);
    return index;
}

// 640.000 Typedefs should be enough for now
mut types: [BCType; 640000] = blank;
mut typeCount: usize = 0;
func assertValidType(ty: TypeIndex, what: &char) -> usize {
    trace("assertValidType");
    let index: usize = ty._i;
    assert_with_msg(index < typeCount, what);
    return index;
}

func initializeGlobalTypes() {
    // FIXME: bool and anytype should create real BCTypes later on
    let i64: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(i64)._i == 0, "initializeGlobalTypes() called in wrong context");
    assert_with_msg(!i64.isValid(), "initializeGlobalTypes() called in wrong context");
    i64.makeIntegerType(64, true);
    let bool: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(bool)._i == 1, "initializeGlobalTypes() called in wrong context");
    let anytype: &mut BCType = createBlankType();
    assert_with_msg(getTypeID(anytype)._i == 2, "initializeGlobalTypes() called in wrong context");
}

func createBlankType() -> &mut BCType {
    let index: usize = typeCount;
    assert_with_msg(!types[index].isValid(), "Attempted to overwrite valid BCType in createBlankType()");
    types[index] = blank;
    typeCount = typeCount + 1;
    return &mut types[index];
}

func getTypeID(typ: &mut BCType) -> TypeIndex {
    unsafe {
        let base: &mut BCType = &mut types[0];
        let diff: usize = typ - base;
        assert(diff % sizeof BCType == 0);
        let id: usize = diff / sizeof BCType;
        return TypeIndex { _i: id };
    }
}

struct NameVarIndexPair {
    name: SubStr;
    index: RegIndex;
}

struct GlobalEntry {
    node: &mut ParsedVarDecl;
    computed: bool;
    register: RegIndex;
}

struct GlobalScope {
    variables: &mut GlobalEntry;
    varLength: usize;
    varCapacity: usize;

    func checkExisting(&mut this, newVar: &mut ParsedVarDecl) -> bool {
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let var: &mut GlobalEntry = this.getEntryAtIndex(i);
            if (var.node.name.content.equals(&newVar.name.content)) {
                return true;
            }
        }
        return false;
    }

    func getEntryAtIndex(&mut this, index: usize) -> &mut GlobalEntry {
        assert_with_msg(index < this.varLength, "Out of bounds access in getEntryAtIndex");
        unsafe {
            return this.variables + index * sizeof GlobalEntry;
        }
    }

    func getVariableByName(&mut this, name: SubStr) -> &mut GlobalEntry {
        for (mut i: usize = 0; i < this.varLength; i = i + 1) {
            let entry: &mut GlobalEntry = this.getEntryAtIndex(i);
            if (entry.node.name.content.equals(&name))
                return entry;
        }
        unsafe {
            return null;
        }
    }

    func addVarDecl(&mut this, decl: &mut ParsedVarDecl) -> bool {
        trace("GlobalScope.addVarDecl");
        if (this.varLength >= this.varCapacity) unsafe {
            mut newCap: usize = this.varCapacity * 2;
            if (newCap == 0) newCap = 1;
            this.variables = realloc(this.variables, newCap * sizeof GlobalEntry);
            assert_with_msg(this.variables != null, "Could not resize variables");
            this.varCapacity = newCap;
        }
        if (this.checkExisting(decl)) unsafe {
            let entry: &mut GlobalEntry = this.getVariableByName(decl.name.content);
            assert(entry != null);
            let stderr: Any = fdopen(2, "a");
            let loc: String = decl.span.toString();
            let oLoc: String = entry.node.span.toString();
            let name: String = decl.name.toString();
            fprintf(stderr, "%s: %s: Redeclaration of global variable `%s`.\n%s: %s: Variable already declared here.\n", loc.chars(), ERR_STR, name.chars(), oLoc.chars(), NOTE_STR);
            loc.drop();
            oLoc.drop();
            name.drop();
            return false;
        }
        unsafe {
            let entry: GlobalEntry = GlobalEntry {
                node: decl,
                computed: false,
                register: blank
            };
            *(this.variables + this.varLength * sizeof GlobalEntry) = entry;
            this.varLength = this.varLength + 1;
        }
        return true;
    }
}

mut interpStack: [u8; 32000000] = blank;
struct BCInterp {
    stackPtr: &mut u8;

    func typeCheckBCLoadNumber(&mut this, fn: &mut BCFunction, loadNumber: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoadNumber");
        assert(loadNumber.kind == INSTR_KIND_LOAD_NUMBER);
        let dst: RegIndex = loadNumber.dst;
        let reg: &mut BCReg = fn.getRegAtIndex(dst);
        if (reg.isInitialized()) {
            todo_with_msg("impossible: initialized register");
        }
        (*reg).value = this.stackPtr;
        (*reg).size = sizeof i64;
        // FIXME: Where do we actually store typedefs? Idk for now
        //        i64 *must* be the first type we add, or this index is invalid
        (*reg).typ = TypeIndex { _i: 0 };
        unsafe {
            *(this.stackPtr as &mut i64) = *(&loadNumber.src._i as &i64);
            this.stackPtr = this.stackPtr + sizeof i64;
        }
        return true;
    }

    func typeCheckBCStoreConst(&mut this, fn: &mut BCFunction, storeConst: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCStoreConst");
        assert(storeConst.kind == INSTR_KIND_STORE_CONST);
        let dst: RegIndex = storeConst.dst;
        let src: RegIndex = storeConst.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid src in StoreConst");
        if (dstReg.isInitialized()) {
            todo_with_msg("report error: const var is initialized");
        }
        (*dstReg).value = this.stackPtr;
        (*dstReg).size = srcReg.size;
        (*dstReg).typ = srcReg.typ;
        unsafe {
            memcpy(dstReg.value, srcReg.value, srcReg.size);
            this.stackPtr = this.stackPtr + srcReg.size;
        }
        return true;
    }

    func typeCheckBCLoad(&mut this, fn: &mut BCFunction, load: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCLoad");
        assert(load.kind == INSTR_KIND_LOAD);
        let dst: RegIndex = load.dst;
        let src: RegIndex = load.src;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let srcReg: &mut BCReg = fn.getRegAtIndex(src);
        assert_with_msg(srcReg.isInitialized(), "expected valid src in Load");
        if (dstReg.isInitialized()) {
            todo_with_msg("impossible: initialized register");
        }
        (*dstReg).value = this.stackPtr;
        (*dstReg).size = srcReg.size;
        (*dstReg).typ = srcReg.typ;
        unsafe {
            memcpy(dstReg.value, srcReg.value, srcReg.size);
            this.stackPtr = this.stackPtr + srcReg.size;
        }
        return true;
    }

    func typeCheckBCAdd(&mut this, fn: &mut BCFunction, add: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCAdd");
        assert(add.kind == INSTR_KIND_ADD);
        let dst: RegIndex = add.dst;
        let lhs: RegIndex = add.src;
        let rhs: RegIndex = add.op1;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let lhsReg: &mut BCReg = fn.getRegAtIndex(lhs);
        let rhsReg: &mut BCReg = fn.getRegAtIndex(rhs);
        assert_with_msg(lhsReg.isInitialized(), "expected valid lhs in Add");
        assert_with_msg(rhsReg.isInitialized(), "expected valid rhs in Add");
        if (!lhsReg.typ.equals(rhsReg.typ)) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = add.origin.toString();
            let lhsLoc: String = lhsReg.origin.toString();
            let rhsLoc: String = rhsReg.origin.toString();
            let lhsTyp: String = lhsReg.typ.toString();
            let rhsTyp: String = rhsReg.typ.toString();
            fprintf(stderr, "%s: %s: Type mismatch in binary addition!\n%s: %s: LHS has type %s.\n%s: %s: RHS has type %s.\n",
                loc.chars(), ERR_STR,
                lhsLoc.chars(), NOTE_STR, lhsTyp.chars(),
                rhsLoc.chars(), NOTE_STR, rhsTyp.chars()
            );
            loc.drop();
            return false;
        }
        assert(lhsReg.size == rhsReg.size);
        if (lhsReg.typ._i == 0) {
            assert(lhsReg.size == 8);
            (*dstReg).value = this.stackPtr;
            (*dstReg).size = lhsReg.size;
            (*dstReg).typ = lhsReg.typ;
            unsafe {
                let lhs: i64 = *(lhsReg.value as &i64);
                let rhs: i64 = *(rhsReg.value as &i64);
                let sum: i64 = lhs + rhs;
                memcpy(dstReg.value, &sum, lhsReg.size);
                this.stackPtr = this.stackPtr + lhsReg.size;
            }
            return true;
        } else {
            todo_with_msg("add for non-literals");
        }
        return false; // unreachable
    }

    func typeCheckBCEqual(&mut this, fn: &mut BCFunction, equal: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCEqual");
        assert(equal.kind == INSTR_KIND_EQUAL || equal.kind == INSTR_KIND_NOT_EQUAL);
        let not: bool = equal.kind == INSTR_KIND_NOT_EQUAL;
        let dst: RegIndex = equal.dst;
        let lhs: RegIndex = equal.src;
        let rhs: RegIndex = equal.op1;
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        let lhsReg: &mut BCReg = fn.getRegAtIndex(lhs);
        let rhsReg: &mut BCReg = fn.getRegAtIndex(rhs);
        assert_with_msg(lhsReg.isInitialized(), "expected valid lhs in Equal");
        assert_with_msg(rhsReg.isInitialized(), "expected valid rhs in Equal");
        if (!lhsReg.typ.equals(rhsReg.typ)) {
            todo_with_msg("report error: Type mismatch in typeCheckEqual");
        }
        assert(lhsReg.size == rhsReg.size);
        (*dstReg).value = this.stackPtr;
        (*dstReg).size = 1;
        (*dstReg).typ = TypeIndex { _i: 1 };
        unsafe {
            let areEqual: bool = memcmp(lhsReg.value, rhsReg.value, lhsReg.size) == 0;
            mut res: u8 = 0;
            if (areEqual) res = 1;
            if (not) res = 1 - res;
            *((*dstReg).value) = res;
            this.stackPtr = this.stackPtr + 1;
        }
        return true;
    }

    func typeCheckBCConstAssert(&mut this, fn: &mut BCFunction, assert: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCConstAssert");
        assert(assert.kind == INSTR_KIND_CONST_ASSERT);
        let what: RegIndex = assert.src;
        let whatReg: &mut BCReg = fn.getRegAtIndex(what);
        assert_with_msg(whatReg.isInitialized(), "expected valid reg in ConstAssert");
        // FIXME: Better way of detecting if this is a bool
        if (whatReg.typ._i != 1) {
            todo_with_msg("report error: Condition in ConstAssert is not bool");
        }
        unsafe {
            let success: bool = *whatReg.value == 1;
            if (!success) unsafe {
                let stderr: Any = fdopen(2, "a");
                let loc: String = assert.origin.toString();
                fprintf(stderr, "%s: %s: Static assertion failed!\n", loc.chars(), ERR_STR);
                loc.drop();
                return false;
            }
        }
        return true;
    }

    func typeCheckBCCreateIntType(&mut this, fn: &mut BCFunction, int: &mut BCInstr) -> bool {
        trace("BCInterp.typeCheckBCCreateIntType");
        assert(int.kind == INSTR_KIND_CREATE_INT_TYPE);
        let dst: RegIndex = int.dst;
        let size: RegIndex = int.src;
        let sign: RegIndex = int.op1;
        let sizeReg: &mut BCReg = fn.getRegAtIndex(size);
        let signReg: &mut BCReg = fn.getRegAtIndex(sign);
        let dstReg: &mut BCReg = fn.getRegAtIndex(dst);
        assert_with_msg(sizeReg.isInitialized(), "expected valid size in CreateIntType");
        assert_with_msg(signReg.isInitialized(), "expected valid sign in CreateIntType");
        // FIXME: Better way of checking these types
        if (sizeReg.typ._i != 0) {
            todo_with_msg("report error: Size in CreateIntType is not int");
        }
        if (signReg.typ._i != 1) {
            todo_with_msg("report error: Sign in CreateIntType is not bool");
        }
        assert(sizeReg.size == 8);
        assert(signReg.size == 1);
        (*dstReg).value = this.stackPtr;
        (*dstReg).size = 8;
        // FIXME: This should be indexof(TYPE_TYPE), which is currently hardcoded in initializeGlobalTypes()
        (*dstReg).typ = TypeIndex { _i: 2 };
        unsafe {
            let bitsize: i64 = *(sizeReg.value as &i64);
            if (bitsize < 0 || bitsize > 65536) {
                todo_with_msg("report error: Integer bitsize invalid");
            }
            let signed: bool = *signReg.value == 1;
            let int: &mut BCType = createBlankType();
            int.makeIntegerType(bitsize as u32, signed);
            let id: TypeIndex = getTypeID(int);
            *(dstReg.value as &mut usize) = id._i;
            this.stackPtr = this.stackPtr + 8;
        }
        return true;
    }

    func typeCheckFunction(&mut this, fnIndex: FnIndex) -> bool {
        unsafe { assert(this.stackPtr != null); }
        trace("BCInterp.typeCheckFunction");
        let fn: &mut BCFunction = &mut functions[assertValidFunction(fnIndex, "typeCheckFunction")];
        // TODO: We don't want to `getRegAtIndex()` for registers, we want to get their stack values
        //       It's not important for now, but will be once we add functions
        for (mut i: usize = 0; i < fn.instrLength; i = i + 1) {
            if (PRINT_DEBUG) {
                fn.dump();
            }
            let instr: &mut BCInstr = fn.getInstrAtIndex(InstrIndex { _i: i });
            if (instr.kind == INSTR_KIND_LOAD_NUMBER) {
                if (!this.typeCheckBCLoadNumber(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_STORE_CONST) {
                if (!this.typeCheckBCStoreConst(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_LOAD) {
                if (!this.typeCheckBCLoad(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_ADD) {
                if (!this.typeCheckBCAdd(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_EQUAL || instr.kind == INSTR_KIND_NOT_EQUAL) {
                if (!this.typeCheckBCEqual(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CONST_ASSERT) {
                if (!this.typeCheckBCConstAssert(fn, instr)) {
                    return false;
                }
            } else if (instr.kind == INSTR_KIND_CREATE_INT_TYPE) {
                if (!this.typeCheckBCCreateIntType(fn, instr)) {
                    return false;
                }
            } else {
                debug(instr.toString().chars());
                todo_with_msg("can't check unknown BCInstr");
            }
        }
        return true;
    }
}

func newBCInterp() -> BCInterp {
    return BCInterp {
        stackPtr: &mut interpStack[0],
    };
}

struct Checker {
    globalScope: GlobalScope;
    func dumpAllFunctions(&mut this) {
        unsafe {
            printf("GLOBAL SCOPE:\n");
            functions[0].dump();
            for (mut i: usize = 1; i < funcCount; i = i + 1) {
                printf("Function %llu:\n", i);
                functions[i].dump();
            }
        }
    }
    func addFunction(&mut this, span: Span) -> FnIndex {
        // FIXME: This function should be in the global scope
        trace("Checker.addFunction");
        let index: FnIndex = FnIndex { _i: funcCount };
        functions[funcCount] = newEmptyFunction(span);
        funcCount = funcCount + 1;
        return index;
    }
    func leaveFunction(&mut this, fn: FnIndex) {
        trace("Checker.leaveFunction");
    }
    func storeVariable(&mut this, currFn: FnIndex, origin: Span, name: SubStr, val: RegIndex, isConst: bool) -> bool {
        trace("Checker.storeVariable");
        let index: usize = assertValidFunction(currFn, "Can not generate store in invalid fn index");
        if (isConst) {
            return functions[index].buildConstStore(origin, name, val);
        } else {
            todo_with_msg("storeVariable let");
            return false;
        }
    }
    func loadVariable(&mut this, currFn: FnIndex, ident: &mut ParsedDeclValueIdent) -> RegIndex {
        let index: usize = assertValidFunction(currFn, "Can not generate load in invalid fn index");
        mut reg: RegIndex = blank;
        let success: bool = functions[index].buildLoad(ident.span, ident.name, &mut reg);
        if (!success) unsafe {
            let entry: &mut GlobalEntry = this.globalScope.getVariableByName(ident.name);
            if (entry == null) {
                ident.name.print();
                todo_with_msg("no variable found");
            }
            if (entry.computed) return entry.register;
            let global: FnIndex = FnIndex { _i: 0 };
            let success: bool = this.generateBytecodeVarDecl(global, entry.node);
            if (!success) todo_with_msg("failed to generate global");
            assert(functions[index].buildLoad(ident.span, ident.name, &mut reg));
            (*entry).computed = true;
            (*entry).register = reg;
        }
        return reg;
    }

    func warnUnusedGlobals(&mut this) {
        mut any: bool = false;
        for (mut i: usize = 0; i < this.globalScope.varLength; i = i + 1) {
            let entry: &mut GlobalEntry = this.globalScope.getEntryAtIndex(i);
            if (!entry.computed) unsafe {
                let loc: String = entry.node.name.span.toString();
                let name: String = entry.node.name.content.toString();
                printf("%s: warning: Unused global constant `%s`.\n", loc.chars(), name.chars());
                name.drop();
                loc.drop();
                any = true;
            }
        }
        if (any) unsafe {
            printf("note: Unused variables are not considered for further validation steps.\n");
        }
    }

    func generateGlobalDeclarations(&mut this, project: &mut ParsedModule) -> bool {
        trace("Checker.generateGlobalDeclarations");
        let globalFn: FnIndex = this.addFunction(project.span);
        assert_with_msg(globalFn.isGlobalFn(), "generateGlobalDeclarations called in wrong context");
        for (mut i: usize = 0; i < project.declCount; i = i + 1) {
            let decl: &mut ParsedGlobalDecl = project.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL) unsafe {
                if (!this.globalScope.addVarDecl(decl.data))
                    return false;
            } else if (decl.kind == GLOBAL_DIR) unsafe {
                if (!this.generateBytecodeDirective(globalFn, decl.data))
                    return false;
            }
        }
        this.leaveFunction(globalFn);
        return true;
    }

    func generateBytecode(&mut this, project: &mut ParsedModule) -> bool {
        trace("Checker.generateBytecode");
        initializeGlobalTypes();
        if (!this.generateGlobalDeclarations(project))
            return false;
        this.warnUnusedGlobals();
        if (PRINT_DEBUG) this.dumpAllFunctions();
        return true;
    }

    func generateBytecodeDirective(&mut this, currFn: FnIndex, dir: &mut ParsedDeclValue) -> bool {
        trace("Checker.generateBytecodeDirective");
        if (dir.kind != DECL_VALUE_BUILTIN) todo_with_msg("only builtins are supported in a global context");
        this.generateBytecodeBuiltin(currFn, dir.data);
        return true;
    }

    func generateBytecodeVarDecl(&mut this, currFn: FnIndex, decl: &mut ParsedVarDecl) -> bool {
        trace("Checker.generateBytecodeVarDecl");
        let isConst: bool = decl.isConst;
        if (!currFn.isGlobalFn()) {
            todo_with_msg("local var");
            // Global declarations have already been added
        }
        let register: RegIndex = this.generateBytecodeDeclValue(currFn, &mut decl.value);
        return this.storeVariable(currFn, decl.name.span, decl.name.content, register, isConst);
    }
    func generateBytecodeDeclValue(&mut this, currFn: FnIndex, expr: &mut ParsedDeclValue) -> RegIndex {
        trace("Checker.generateBytecodeDeclValue");
        if (expr.kind == DECL_VALUE_INVALID) todo_with_msg("bytecode DECL_VALUE_INVALID");
        else if (expr.kind == DECL_VALUE_MODULE) todo_with_msg("bytecode DECL_VALUE_MODULE");
        else if (expr.kind == DECL_VALUE_FUNC_DECL) todo_with_msg("bytecode DECL_VALUE_FUNC_DECL");
        else if (expr.kind == DECL_VALUE_STRUCT_DECL) todo_with_msg("bytecode DECL_VALUE_STRUCT_DECL");
        else if (expr.kind == DECL_VALUE_ENUM_DECL) todo_with_msg("bytecode DECL_VALUE_ENUM_DECL");
        else if (expr.kind == DECL_VALUE_UNION_DECL) todo_with_msg("bytecode DECL_VALUE_UNION_DECL");
        else if (expr.kind == DECL_VALUE_BUILTIN)
            return this.generateBytecodeBuiltin(currFn, expr.data);
        else if (expr.kind == DECL_VALUE_CALL) todo_with_msg("bytecode DECL_VALUE_CALL");
        else if (expr.kind == DECL_VALUE_IDENT) unsafe {
            let ident: &mut ParsedDeclValueIdent = expr.data;
            return this.loadVariable(currFn, ident);
        } else if (expr.kind == DECL_VALUE_BINARY)
            return this.generateBytecodeBinary(currFn, expr.data);
        else if (expr.kind == DECL_VALUE_NUMBER) unsafe {
            let number: &mut ParsedDeclValueNumber = expr.data;
            let _n: String = number.number.toString();
            let int: i64 = _n.toI64();
            _n.drop();
            return functions[assertValidFunction(currFn, "number literal")].buildNumberLiteral(number.span, int);
        } else if (expr.kind == DECL_VALUE_BLOCK) todo_with_msg("bytecode DECL_VALUE_BLOCK");
        else if (expr.kind == DECL_VALUE_IF) todo_with_msg("bytecode DECL_VALUE_IF");
        else if (expr.kind == DECL_VALUE_UNARY) todo_with_msg("bytecode DECL_VALUE_UNARY");
        else {
            assert_with_msg(false, "exhaustive handling in generateBytecodeDeclValue");
        }
        todo_with_msg("decl value");
        return blank;
    }

    func generateBytecodeBinary(&mut this, currFn: FnIndex, binary: &mut ParsedDeclValueBinary) -> RegIndex {
        trace("Checker.generateBytecodeBinary");
        if (binary.op == BINARY_OP_ASSIGN) todo_with_msg("binary assignment");
        let lhs: RegIndex = this.generateBytecodeDeclValue(currFn, &mut binary.lhs);
        let rhs: RegIndex = this.generateBytecodeDeclValue(currFn, &mut binary.rhs);
        return functions[assertValidFunction(currFn, "binary operation")].buildBinaryOp(binary.span, lhs, rhs, binary.op);
    }

    func generateBytecodeBuiltin(&mut this, currFn: FnIndex, builtin: &mut ParsedDeclValueBuiltin) -> RegIndex {
        trace("Checker.generateBytecodeBuiltin");
        let name: SubStr = builtin.name;
        if (name.equals(&BUILTIN_INTEGER)) {
            if (builtin.argCount != 2) todo_with_msg("@integer() wrong arg count");
            let size: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[0]);
            let signed: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[1]);
            return functions[assertValidFunction(currFn, "@integer()")].buildCreateInteger(builtin.span, size, signed);
        } else if (name.equals(&BUILTIN_FLOAT)) todo_with_msg("BUILTIN_FLOAT");
        else if (name.equals(&BUILTIN_BOOLEAN)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_SELF)) todo_with_msg("BUILTIN_SELF");
        else if (name.equals(&BUILTIN_ANYTYPE)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_ANYVALUE)) todo_with_msg("BUILTIN_ANYVALUE");
        else if (name.equals(&BUILTIN_NONE)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_ENTRY)) todo_with_msg("BUILTIN");
        else if (name.equals(&BUILTIN_ASSERT)) {
            if (builtin.argCount != 1) todo_with_msg("@assert() wrong arg count");
            let what: RegIndex = this.generateBytecodeDeclValue(currFn, &mut builtin.args[0]);
            return functions[assertValidFunction(currFn, "@assert()")].buildConstAssert(builtin.span, what);
        } else if (name.equals(&BUILTIN_TYPEOF)) todo_with_msg("BUILTIN");
        else todo_with_msg("unknown builtin");
        return blank;
    }

    func verifyBytecode(&mut this) -> bool {
        trace("Checker.verifyBytecode");
        mut interp: BCInterp = newBCInterp();
        let globalFn: FnIndex = FnIndex { _i: 0 };
        return interp.typeCheckFunction(globalFn);
    }
}

func newChecker() -> Checker {
    return Checker {
        globalScope: blank,
    };
}
