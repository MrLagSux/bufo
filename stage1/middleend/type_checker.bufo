import "string.bufo";
import "frontend/nodes.bufo";
import "util/span.bufo";
import "middleend/builtins.bufo";

comptime TYPE_INVALID : u8 = 0; // Error
comptime TYPE_TYPE    : u8 = 1; // let a = i32;
comptime TYPE_INTEGER : u8 = 2; // let a = i32(0);
comptime TYPE_BOOLEAN : u8 = 3; // let a = false;
comptime TYPE_POINTER : u8 = 4; // let a = &b;
comptime TYPE_FUNCTION: u8 = 5; // let a = func () {};
comptime TYPE_NONE    : u8 = 6; // let a = @none();
comptime TYPE_ANYTYPE : u8 = 7; // let a = @anytype();
struct IntType {
    signed: bool;
    bitsize: i64;
}
struct PtrType {
    underlying: &Type;
    mutable: bool;
}
struct FuncType {
    funcDecl: &mut ParsedFuncDecl;
    params: &[Type; 8];
    paramCount: usize;
    retType: &Type;
    func containsAnytype(&this) -> bool {
        if (this.retType.isAnytype()) return true;
        for (mut i: usize = 0; i < this.paramCount; i = i + 1) {
            if ((*this.params)[i].isAnytype()) return true;
        }
        return false;
    }
}
struct TypeType {
    actual: &Type;
}
struct Type {
    span: Span;
    kind: u8;
    typ: TypeType;
    int: IntType;
    ptr: PtrType;
    fn: FuncType;

    func toString(&this) -> String {
        if (this.kind == TYPE_INTEGER) {
            mut s: String = newString();
            if (this.int.bitsize < 0) {
                s.pushStr("<raw integer>");
            } else {
                if (this.int.signed) {
                    s.pushChar('i');
                } else {
                    s.pushChar('u');
                }
                s.pushNumber(this.int.bitsize as usize);
            }
            return s;
        } else if (this.kind == TYPE_NONE) {
            return newStringFromStrLit("none");
        } else if (this.kind == TYPE_BOOLEAN) {
            return newStringFromStrLit("bool");
        } else if (this.kind == TYPE_FUNCTION) {
            mut s: String = newStringFromStrLit("func (");
            for (mut i: usize = 0; i < this.fn.paramCount; i = i + 1) {
                if (i != this.fn.paramCount - 1) s.pushStr(", ");
                let _t: String = (*this.fn.params)[i].toString();
                s.pushString(&_t);
                _t.drop();
            }
            s.pushStr(") -> ");
            let _t: String = this.fn.retType.toString();
            s.pushString(&_t);
            _t.drop();
            return s;
        } else if (this.kind == TYPE_TYPE) {
            mut s: String = newStringFromStrLit("type<");
            let _t: String = this.typ.actual.toString();
            s.pushString(&_t);
            _t.drop();
            s.pushChar('>');
            return s;
        } else if (this.kind == TYPE_POINTER) {
            mut s: String = newStringFromStrLit("*");
            if (this.ptr.mutable) s.pushStr("mut ");
            let _t: String = this.ptr.underlying.toString();
            s.pushString(&_t);
            _t.drop();
            return s;
        } else unsafe {
            printf("%hhu\n", this.kind);
            todo_with_msg("Type.toString");
        }
        return blank;
    }

    func equals(&this, other: &Type) -> bool {
        if (this.kind == TYPE_ANYTYPE)
            return true;
        else if (this.kind != other.kind)
            return false;
        else if (this.kind == TYPE_TYPE)
            return true;
        else if (this.kind == TYPE_INTEGER)
            return this.int.signed == other.int.signed
                && this.int.bitsize == other.int.bitsize;
        else if (this.kind == TYPE_POINTER)
            return this.ptr.mutable == other.ptr.mutable
                && this.ptr.underlying.equals(other.ptr.underlying);
        else if (this.kind == TYPE_FUNCTION) {
            if (this.fn.paramCount != other.fn.paramCount) return false;
            for (mut i: usize = 0; i < this.fn.paramCount; i = i + 1) {
                if (!(*this.fn.params)[i].equals(&(*other.fn.params)[i])) return false;
            }
            return this.fn.retType.equals(other.fn.retType);
        }
        else if (this.kind == TYPE_NONE)
            return true;
        else if (this.kind == TYPE_BOOLEAN)
            return true;
        unsafe {
            printf("%hhu\n", this.kind);
            printf("%hhu\n", other.kind);
            printf("%s\n", this.span.toString().chars());
            todo_with_msg("Type.equals");
        }
        return true;
    }

    func isValid(&this) -> bool {
        return this.kind != TYPE_INVALID;
    }

    func isType(&this) -> bool {
        return this.kind == TYPE_TYPE;
    }

    func isInteger(&this) -> bool {
        return this.kind == TYPE_INTEGER;
    }

    func isBool(&this) -> bool {
        return this.kind == TYPE_BOOLEAN;
    }

    func isFunction(&this) -> bool {
        return this.kind == TYPE_FUNCTION;
    }

    func isNone(&this) -> bool {
        return this.kind == TYPE_NONE;
    }

    func isPointer(&this) -> bool {
        return this.kind == TYPE_POINTER;
    }

    func isAnytype(&this) -> bool {
        return this.kind == TYPE_ANYTYPE;
    }
}

func newTypeType(span: Span, actual: &Type) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_TYPE;
    unsafe {
        let mem: Any = calloc(1, sizeof Type);
        assert_with_msg(mem != null, "Could not allocate memory in newPtrType");
        memcpy(mem, actual, sizeof Type);
        let copy: &Type = mem;
        t.typ = TypeType {
            actual: copy
        };
    }
    return t;
}

func newIntType(span: Span, bitsize: i64, signed: bool) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_INTEGER;
    t.int = IntType {
        signed: signed,
        bitsize: bitsize
    };
    return t;
}

func newBoolType(span: Span) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_BOOLEAN;
    return t;
}

func newNoneType(span: Span) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_NONE;
    return t;
}

func newAnytypeType(span: Span) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_ANYTYPE;
    return t;
}

func newPtrType(span: Span, underlying: &Type, mutable: bool) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_POINTER;
    unsafe {
        let mem: Any = calloc(1, sizeof Type);
        assert_with_msg(mem != null, "Could not allocate memory in newPtrType");
        memcpy(mem, underlying, sizeof Type);
        let copy: &Type = mem;
        t.ptr = PtrType {
            underlying: copy,
            mutable: mutable,
        };
    }
    return t;
}

func newFuncType(funcDecl: &mut ParsedFuncDecl, span: Span, params: &[Type; 8], paramCount: usize, retType: &Type) -> Type {
    mut t: Type = invalidType(span);
    t.kind = TYPE_FUNCTION;
    unsafe {
        mut mem: Any = calloc(1, sizeof Type);
        assert_with_msg(mem != null, "Could not allocate memory in newFuncType");
        memcpy(mem, retType, sizeof Type);
        let retTypeCopy: &Type = mem;
        mem = calloc(1, sizeof [Type; 8]);
        assert_with_msg(mem != null, "Could not allocate memory in newFuncType");
        memcpy(mem, params, sizeof [Type; 8]);
        let paramsCopy: &[Type; 8] = mem;
        t.fn = FuncType {
            funcDecl: funcDecl,
            params: paramsCopy,
            paramCount: paramCount,
            retType: retTypeCopy,
        };
    }
    return t;
}

func invalidType(span: Span) -> Type {
    return Type {
        span: span,
        kind: TYPE_INVALID,
        typ: blank,
        int: blank,
        ptr: blank,
        fn: blank,
    };
}

comptime VALUE_INVALID: u8 = 0;
comptime VALUE_INTEGER: u8 = 1;
comptime VALUE_BOOLEAN: u8 = 2;
struct Value {
    kind: u8;
    rawInt: i64;
    bValue: bool;
    func isValid(&this) -> bool {
        return this.kind != VALUE_INVALID;
    }
    func isInteger(&this) -> bool {
        return this.kind == VALUE_INTEGER;
    }
    func isBool(&this) -> bool {
        return this.kind == VALUE_BOOLEAN;
    }
    func intoBoolValue(&this) -> Value {
        if (this.kind == VALUE_INTEGER) return newBoolValue(this.rawInt == 1);
        todo_with_msg("Value.intoBoolValue");
        return invalidValue();
    }
    func applyBinaryOperator(&this, op: usize, rhs: &Value) -> Value {
        trace("Value.applyBinaryOperator");
        if (this.kind != rhs.kind) return invalidValue();
        if (this.isInteger())
            if (op == BINARY_OP_PLUS)
                return newIntValue(this.rawInt + rhs.rawInt);
            else if (op == BINARY_OP_EQUAL)
                return newBoolValue(this.rawInt == rhs.rawInt);
            else
                todo_with_msg("int apply op");
        else
            todo_with_msg("not int apply op");
        return invalidValue();
    }
}

func newIntValue(value: i64) -> Value {
    mut v: Value = invalidValue();
    v.kind = VALUE_INTEGER;
    v.rawInt = value;
    return v;
}

func newBoolValue(value: bool) -> Value {
    mut v: Value = invalidValue();
    v.kind = VALUE_BOOLEAN;
    v.bValue = value;
    return v;
}

func invalidValue() -> Value {
    return blank; // blank sets kind to VALUE_INVALID
}

// TCResult.flags is a combination of the below flags
// TCResult.flags = RESULT_VALID | RESULT_TYPE means TCResult.typ has a valid value
// TCResult.flags = RESULT_VALID | RESULT_VALUE means TCResult.value has a valid value
// Combinations are also possible, i.e. a phase might return a valid value with a valid type
// A default value of 0 indicates error.
comptime RESULT_ERROR: u8 = 0;
comptime RESULT_INCOMPLETE: u8 = 1;
comptime RESULT_VALID: u8 = RESULT_INCOMPLETE * 2;
comptime RESULT_TYPE: u8 = RESULT_VALID * 2;
comptime RESULT_VALUE: u8 = RESULT_TYPE * 2;
comptime RESULT_CONST: u8 = RESULT_VALUE * 2;
struct TCResult {
    flags: u8;
    typ: Type;
    value: Value;

    func isError(&this) -> bool {
        return (this.flags & RESULT_ERROR) != 0;
    }

    func isValid(&this) -> bool {
        return (this.flags & RESULT_VALID) != 0;
    }

    func isType(&this) -> bool {
        return (this.flags & RESULT_TYPE) != 0;
    }

    func isValue(&this) -> bool {
        return (this.flags & RESULT_VALUE) != 0;
    }

    func isConst(&this) -> bool {
        return (this.flags & RESULT_CONST) != 0;
    }

    func isIncomplete(&this) -> bool {
        return (this.flags & RESULT_INCOMPLETE) != 0;
    }

    func markIncomplete(&mut this) {
        this.flags = this.flags | RESULT_INCOMPLETE;
    }
}

func newTCResult(valid: bool, typ: Type, value: Value) -> TCResult {
    mut flags: u8 = 0;
    if (valid) flags = flags | RESULT_VALID;
    if (typ.isValid()) flags = flags | RESULT_TYPE;
    if (value.isValid()) flags = flags | RESULT_VALUE;
    return TCResult {
        flags: flags,
        typ: typ,
        value: value,
    };
}

func invalidTCResult() -> TCResult {
    trace("invalidTCResult");
    return blank; // blank sets flags to 0, which indicates RESULT_ERROR
}

struct ScopeEntry {
    name: SubStr;
    span: Span;
    isChecked: bool;
    result: TCResult;
    node: &mut ParsedVarDecl;
}

func newScopeEntry(decl: &mut ParsedVarDecl) -> ScopeEntry {
    return ScopeEntry {
        name: decl.name.content,
        span: decl.span,
        isChecked: false,
        result: invalidTCResult(),
        node: decl
    };
}

struct Scope {
    entries: &mut ScopeEntry;
    length: usize;
    capacity: usize;

    func getEntryAtIndex(&mut this, index: usize) -> &mut ScopeEntry {
        assert_with_msg(index < this.length, "Out of bounds access in Scope.getEntryAtIndex");
        unsafe {
            return this.entries + index * sizeof ScopeEntry;
        }
    }

    func checkExisting(&mut this, decl: &mut ParsedVarDecl) -> bool {
        trace("Scope.checkExisting");
        let name: SubStr = decl.name.content;
        for (mut i: usize = 0; i < this.length; i = i + 1) {
            let entry: &mut ScopeEntry = this.getEntryAtIndex(i);
            if (entry.name.equals(&name)) {
                return true;
            }
        }
        return false;
    }

    func isKnownIdentifier(&mut this, name: SubStr) -> bool {
        for (mut i: usize = 0; i < this.length; i = i + 1) {
            let entry: &mut ScopeEntry = this.getEntryAtIndex(i);
            if (entry.name.equals(&name)) {
                return true;
            }
        }
        return false;
    }

    func getVariableByName(&mut this, name: SubStr) -> &mut ScopeEntry {
        trace("Scope.getVariableByName");
        for (mut i: usize = 0; i < this.length; i = i + 1) {
            let entry: &mut ScopeEntry = this.getEntryAtIndex(i);
            if (entry.name.equals(&name)) {
                return entry;
            }
        }
        assert_with_msg(!this.isKnownIdentifier(name), "unreachable in Scope.getVariableByName");
        assert_with_msg(false, "unreachable in Scope.getVariableByName");
        unsafe { return null; }
    }

    func addVarDecl(&mut this, decl: &mut ParsedVarDecl) -> bool {
        trace("Scope.addVarDecl");
        if (this.length >= this.capacity) todo_with_msg("resize entries");
        if (this.checkExisting(decl)) return false;
        unsafe {
            let p: &mut ScopeEntry = this.entries + this.length * sizeof ScopeEntry;
            *p = newScopeEntry(decl);
            this.length = this.length + 1;
        }
        return true;
    }
    func addEntry(&mut this, entry: ScopeEntry) -> bool {
        if (this.length >= this.capacity) todo_with_msg("resize entries");
        if (this.isKnownIdentifier(entry.name)) return false;
        unsafe {
            let p: &mut ScopeEntry = this.entries + this.length * sizeof ScopeEntry;
            *p = entry;
            this.length = this.length + 1;
        }
        return true;
    }
}

func newScope() -> Scope {
    trace("newScope");
    unsafe {
        let m: Any = calloc(32, sizeof ScopeEntry);
        assert_with_msg(m != null, "Could not allocate memory in newScope");
        let s: &mut ScopeEntry = &mut *m;
        return Scope {
            entries: s,
            length: 0,
            capacity: 32
        };
    }
}

struct ScopeList {
    s: &mut Scope;
    length: usize;
    capacity: usize;

    func getScopeAtIndex(&mut this, index: usize) -> &mut Scope {
        assert_with_msg(index < this.length, "Out of bounds access in ScopeList.getScopeAtIndex");
        unsafe {
            return this.s + index * sizeof Scope;
        }
    }

    func getCurrentScope(&mut this) -> &mut Scope {
        return this.getScopeAtIndex(this.length - 1);
    }

    func addScope(&mut this) -> &mut Scope {
        trace("ScopeList.addScope");
        if (this.length >= this.capacity) todo_with_msg("resize scopes");
        unsafe {
            let p: &mut Scope = this.s + this.length * sizeof Scope;
            this.length = this.length + 1;
            *p = newScope();
            return p;
        }
    }

    func removeScope(&mut this) -> &mut Scope {
        trace("ScopeList.removeScope");
        assert_with_msg(this.length > 0, "Attempted to remove scope from empty list");
        let s: &mut Scope = this.getCurrentScope();
        this.length = this.length - 1;
        return s;
    }

    func isKnownIdentifier(&mut this, name: SubStr) -> bool {
        trace("ScopeList.isKnownIdentifier");
        for (mut i: usize = this.length - 1; i >= 0; i = i - 1) {
            let s: &mut Scope = this.getScopeAtIndex(i);
            if (s.isKnownIdentifier(name))
                return true;
        }
        return false;
    }

    func getVariableByName(&mut this, name: SubStr) -> &mut ScopeEntry {
        trace("ScopeList.getVariableByName");
        for (mut i: usize = this.length - 1; i >= 0; i = i - 1) {
            let s: &mut Scope = this.getScopeAtIndex(i);
            if (s.isKnownIdentifier(name))
                return s.getVariableByName(name);
        }
        assert_with_msg(this.isKnownIdentifier(name), "unreachable in ScopeList.getVariableByName");
        assert_with_msg(false, "unreachable in ScopeList.getVariableByName");
        unsafe { return null; }
    }
}

func newScopeList() -> ScopeList {
    trace("newScopeList");
    unsafe {
        let m: Any = calloc(32, sizeof Scope);
        assert_with_msg(m != null, "Could not allocate memory in newScopeList");
        let s: &mut Scope = &mut *m;
        return ScopeList {
            s: s,
            length: 0,
            capacity: 32
        };
    }
}

struct TypeChecker {
    errors: &mut String;
    errorCount: usize;
    errorCapacity: usize;
    scopes: ScopeList;
    entry: &mut ParsedDeclValueBuiltin;
    funcStack: &mut Type;
    funcStackLen: usize;
    funcStackCapacity: usize;
    identStack: Scope; // Identifiers that we currently check are in here, so we can find cycles

    func pushFunctionOnStack(&mut this, fn: Type) {
        if (this.funcStackLen >= this.funcStackCapacity) unsafe {
            mut newCap: usize = this.funcStackCapacity * 2;
            if (newCap == 0) newCap = newCap + 1;
            this.funcStack = realloc(this.funcStack, newCap * sizeof Type);
            assert_with_msg(this.funcStack != null, "Could not resize function stack");
            this.funcStackCapacity = newCap;
        }
        unsafe {
            *(this.funcStack + this.funcStackLen * sizeof Type) = fn;
            this.funcStackLen = this.funcStackLen + 1;
        }
    }
    func peekFunctionFromStack(&mut this) -> &mut Type {
        trace("TypeChecker.peekFunctionFromStack");
        assert_with_msg(this.funcStackLen > 0, "Stack underflow in TypeChecker.peekFunctionFromStack");
        unsafe {
            return this.funcStack + (this.funcStackLen - 1) * sizeof Type;
        }
    }
    func popFunctionFromStack(&mut this) {
        trace("TypeChecker.popFunctionFromStack");
        assert_with_msg(this.funcStackLen > 0, "Stack underflow in TypeChecker.popFunctionFromStack");
        this.funcStackLen = this.funcStackLen - 1;
    }
    func addError(&mut this, error: String) {
        if (this.errorCount >= this.errorCapacity) unsafe {
            mut newCap: usize = this.errorCapacity * 2;
            if (newCap == 0) newCap = 1;
            this.errors = realloc(this.errors, newCap * sizeof String);
            assert_with_msg(this.errors != null, "Could not resize error list");
            this.errorCapacity = newCap;
        }
        unsafe {
            *(this.errors + this.errorCount * sizeof String) = error;
            this.errorCount = this.errorCount + 1;
        }
    }

    func warnUnreachableCodeBlock(&mut this, ignoredBranch: &mut ParsedDeclValue) {
        trace("TypeChecker.warnUnreachableCodeBlock");
        let loc: String = ignoredBranch.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": warning: Analysis indicates that this code block is unreachable.\n");
        s.pushString(&loc);
        s.pushStr(": note: Due to the lazy nature of the compiler, unreachable code blocks are not considered for Type Checking and further stages.\n");
        unsafe {
            printf("%.*s", s.len(), s.chars());
        }
        loc.drop();
        s.drop();
    }

    func warnUnusedVarDecl(&mut this, entry: &mut ScopeEntry) {
        if (this.errorCount > 0) return; // Variable might be unused because its expression caused an error
        trace("TypeChecker.warnUnusedVarDecl");
        unsafe {
            assert_with_msg(entry.node != null, "can only warn if ScopeEntry.node is not null");
        }
        let loc: String = entry.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": warning: Unused variable `");
        s.pushSubStr(&entry.node.name.content);
        s.pushStr("`.\n");
        // s.pushString(&loc);
        // s.pushStr(": note: Due to the lazy nature of the compiler, unused variables are not considered for Type Checking and further stages.\n");
        // s.pushString(&loc);
        // s.pushStr(": note: To force the compiler to consider the variable, use `@check(");
        // s.pushSubStr(&entry.node.name.content);
        // s.pushStr(")`.\n");
        unsafe {
            printf("%.*s", s.len(), s.chars());
        }
        loc.drop();
        s.drop();
    }

    func printErrorStaticAssertFailed(&mut this, assert: &mut ParsedDeclValueBuiltin) {
        trace("TypeChecker.printErrorStaticAssertFailed");
        mut s: String = newString();
        let loc: String = assert.span.toString();
        s.pushString(&loc);
        s.pushStr(": error: Static assertion failed!\n");
        this.addError(s);
        loc.drop();
    }

    func printErrorAssignToConst(&mut this, assignOp: &mut ParsedDeclValueBinary) {
        trace("TypeChecker.printErrorAssignToConst");
        assert_with_msg(assignOp.op == BINARY_OP_ASSIGN, "expected assign op");
        mut s: String = newString();
        let binLoc: String = assignOp.span.toString();
        s.pushString(&binLoc);
        s.pushStr(": error: Attempted to assign to a const lvalue.\n");
        this.addError(s);
        binLoc.drop();
    }

    func printErrorTypeDeclWithLet(&mut this, node: &mut ParsedVarDecl, result: TCResult) {
        trace("TypeChecker.printErrorTypeDeclWithLet");
        assert_with_msg(!node.isConst, "expected let-var");
        assert_with_msg(result.isValid(), "expected valid result");
        assert_with_msg(result.isType(), "expected valid result");
        assert_with_msg(result.typ.isType(), "expected valid result");
        mut s: String = newString();
        let loc: String = node.name.span.toString();
        let t: String = result.typ.typ.actual.toString();
        s.pushString(&loc);
        s.pushStr(": error: Attempted to assign type `");
        s.pushString(&t);
        s.pushStr("` to a variable which only exists at runtime.\n");
        s.pushString(&loc);
        s.pushStr(": note: Types only exist at compile time.\n");
        this.addError(s);
        t.drop();
        loc.drop();
    }

    func printErrorLetInConstContext(&mut this, node: &mut ParsedVarDecl) {
        trace("TypeChecker.printErrorLetInConstContext");
        assert_with_msg(!node.isConst, "expected let-var");
        let loc: String = node.name.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": error: Variable `");
        s.pushSubStr(&node.name.content);
        s.pushStr("` is used in a `const` context, however it only exists at runtime.\n");
        s.pushString(&loc);
        s.pushStr(": note: `const` variables only exist at compile time.\n");
        this.addError(s);
        loc.drop();
    }

    func printErrorArgumentCountMismatch(&mut this, call: &mut ParsedDeclValueCall, funcDecl: &mut ParsedFuncDecl) {
        trace("TypeChecker.printErrorArgumentCountMismatch");
        let argCount: usize = call.argCount;
        let paramCount: usize = funcDecl.paramCount;
        let callLoc: String = call.span.toString();
        let declLoc: String = funcDecl.span.toString();
        mut s: String = newString();
        s.pushString(&callLoc);
        s.pushStr(": error: Function call expected ");
        s.pushNumber(paramCount);
        if (paramCount == 1) s.pushStr(" argument");
        else s.pushStr(" arguments");
        s.pushStr(", but got ");
        s.pushNumber(argCount);
        s.pushStr(" instead.\n");
        s.pushString(&declLoc);
        s.pushStr(": note: Function declared here.\n");
        this.addError(s);
        declLoc.drop();
        callLoc.drop();
    }

    func printErrorRecursiveIdentifiers(&mut this, ident: &mut ParsedDeclValueIdent) {
        trace("TypeChecker.printErrorRecursiveIdentifiers");
        assert(this.identStack.length != 0);
        let entry: &mut ScopeEntry = this.identStack.getEntryAtIndex(0);
        let loc: String = entry.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": error: Recursive dependency encountered when evaluating the type of identifier `");
        s.pushSubStr(&entry.name);
        s.pushStr("`.\n");
        for (mut i: usize = 1; i < this.identStack.length; i = i + 1) {
            let e: &mut ScopeEntry = this.identStack.getEntryAtIndex(i);
            let l: String = e.span.toString();
            s.pushString(&l);
            s.pushStr(": note: The previous identifier depends on the type of identifier `");
            s.pushSubStr(&e.name);
            s.pushStr("`.\n");
            l.drop();
        }
        let l: String = ident.span.toString();
        s.pushString(&l);
        s.pushStr(": note: Which itself depends on the type of identifier `");
        s.pushSubStr(&ident.name);
        s.pushStr("`.\n");
        this.addError(s);
        l.drop();
        loc.drop();
    }

    func printErrorCouldNotFindEntryPoint(&mut this) {
        trace("TypeChecker.printErrorCouldNotFindEntryPoint");
        mut s: String = newString();
        s.pushStr("error: Could not find entry point of the program.\n");
        s.pushStr("note: The compiler is lazy and only starts compilation when an entry point is provided.\n");
        s.pushStr("note: Use the `@entry()` builtin to get started, for example:\n");
        s.pushStr("      > `@entry(main)` where `let main = func () -> i32 { return 0; };`\n");
        s.pushStr("      > `@entry(func () -> i32 { return 0; })`\n");
        this.addError(s);
    }

    func printErrorEntryExpectedOneArgument(&mut this, entry: &mut ParsedDeclValueBuiltin) {
        trace("TypeChecker.printErrorEntryExpectedOneArgument");
        let cnt: usize = entry.argCount;
        let loc: String = entry.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": error: Builtin @entry() expected one argument, got ");
        s.pushNumber(cnt);
        s.pushStr(".\n");
        for (mut i: usize = 0; i < cnt; i = i + 1) {
            let arg: ParsedDeclValue = entry.args[i];
            let argLoc: String = arg.span.toString();
            s.pushString(&argLoc);
            s.pushStr(": note: Argument ");
            s.pushNumber(i);
            s.pushStr(" provided here.\n");
            argLoc.drop();
        }
        this.addError(s);
        loc.drop();
    }

    func printErrorUseOfUnknownIdentifier(&mut this, ident: &mut ParsedDeclValueIdent) {
        trace("TypeChecker.printErrorUseOfUnknownIdentifier");
        let loc: String = ident.span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": error: Use of undeclared variable `");
        s.pushSubStr(&ident.name);
        s.pushStr("`.\n");
        loc.drop();
        this.addError(s);
    }

    func printErrorDuplicateIdentifier(&mut this, name: SubStr, newSpan: Span, oldSpan: Span) {
        trace("TypeChecker.printErrorDuplicateIdentifier");
        let newLoc: String = newSpan.toString();
        let oldLoc: String = oldSpan.toString();
        mut s: String = newString();
        s.pushString(&newLoc);
        s.pushStr(": error: Redeclaration of variable ");
        s.pushSubStr(&name);
        s.pushStr(".\n");
        s.pushString(&oldLoc);
        s.pushStr(": note: Variable already declared here.\n");
        oldLoc.drop();
        newLoc.drop();
        this.addError(s);
    }

    func printErrorIfBlocksTypeMismatch(&mut this, ifBlock: Type, elseBlock: Type) {
        trace("TypeChecker.printErrorTypeMismatch");
        let ifName: String = ifBlock.toString();
        let elseName: String = elseBlock.toString();
        let ifLoc: String = ifBlock.span.toString();
        let elseLoc: String = elseBlock.span.toString();
        mut s: String = newString();
        let _s: Span = newSpanBetween(&ifBlock.span, &elseBlock.span);
        let _s1: String = _s.toString();
        s.pushString(&_s1);
        s.pushStr(": error: The blocks of an `if-else` expression must evaluate to the same type.\n");
        s.pushString(&ifLoc);
        s.pushStr(": note: The `if`-block evaluated to type `");
        s.pushString(&ifName);
        s.pushStr("`.\n");
        s.pushString(&elseLoc);
        s.pushStr(": note: The `else`-block evaluated to type `");
        s.pushString(&elseName);
        s.pushStr("`.\n");
        _s1.drop();
        elseLoc.drop();
        ifLoc.drop();
        elseName.drop();
        ifName.drop();
        this.addError(s);
    }

    func printErrorTypeMismatch(&mut this, expected: Type, got: Type) {
        trace("TypeChecker.printErrorTypeMismatch");
        let expName: String = expected.toString();
        let gotName: String = got.toString();
        let expLoc: String = expected.span.toString();
        let gotLoc: String = got.span.toString();
        mut s: String = newString();
        s.pushString(&gotLoc);
        s.pushStr(": error: Type mismatch! Expected type ");
        s.pushString(&expName);
        s.pushStr(", got ");
        s.pushString(&gotName);
        s.pushStr(".\n");
        s.pushString(&expLoc);
        s.pushStr(": note: Expected type evaluated here.\n");
        gotLoc.drop();
        expLoc.drop();
        gotName.drop();
        expName.drop();
        this.addError(s);
    }

    func printErrorBinaryOperationNotDefined(&mut this, span: Span, lhs: Type, rhs: Type, op: usize) {
        trace("TypeChecker.printErrorBinaryOperationNotDefined");
        let opStr: &char = binaryOpToStr(op);
        let lhsName: String = lhs.toString();
        let rhsName: String = rhs.toString();
        let loc: String = span.toString();
        mut s: String = newString();
        s.pushString(&loc);
        s.pushStr(": error: Binary operation `");
        s.pushString(&lhsName);
        s.pushChar(' ');
        s.pushStr(opStr);
        s.pushChar(' ');
        s.pushString(&rhsName);
        s.pushStr("` is not defined.\n");
        this.addError(s);
        loc.drop();
        rhsName.drop();
        lhsName.drop();
    }

    func printErrorUnexpectedReturnValue(&mut this, expected: Type, got: Type) {
        trace("TypeChecker.printErrorUnexpectedReturnValue");
        assert(expected.isNone());
        let gotName: String = got.toString();
        let expLoc: String = expected.span.toString();
        let gotLoc: String = got.span.toString();
        mut s: String = newString();
        s.pushString(&gotLoc);
        s.pushStr(": error: Unexpected return value of type ");
        s.pushString(&gotName);
        s.pushStr(".\n");
        s.pushString(&expLoc);
        s.pushStr(": note: Function declared to return nothing here.\n");
        gotLoc.drop();
        expLoc.drop();
        gotName.drop();
        this.addError(s);
    }

    func getCurrentScope(&mut this) -> &mut Scope {
        trace("TypeChecker.getCurrentScope");
        return this.scopes.getCurrentScope();
    }

    func addScope(&mut this) -> &mut Scope {
        trace("TypeChecker.addScope");
        return this.scopes.addScope();
    }

    func removeScope(&mut this) -> &mut Scope {
        trace("TypeChecker.removeScope");
        return this.scopes.removeScope();
    }

    func isKnownIdentifier(&mut this, name: SubStr) -> bool {
        trace("TypeChecker.isKnownIdentifier");
        return this.scopes.isKnownIdentifier(name);
    }

    func getVariableByName(&mut this, name: SubStr) -> &mut ScopeEntry {
        trace("TypeChecker.getVariableByName");
        return this.scopes.getVariableByName(name);
    }

    func fillLookup(&mut this, project: &mut ParsedModule) -> bool {
        trace("TypeChecker.fillLookup");
        let scope: &mut Scope = this.addScope();
        for (mut i: usize = 0; i < project.declCount; i = i + 1) {
            let decl: &mut ParsedGlobalDecl = project.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL) {
                let decl: &mut ParsedVarDecl = decl.data;
                if (!scope.addVarDecl(decl)) {
                    let entry: &mut ScopeEntry = this.getVariableByName(decl.name.content);
                    this.printErrorDuplicateIdentifier(decl.name.content, decl.name.span, entry.node.name.span);
                    return false;
                }
            }
        }
        return true;
    }

    func evaluateGlobalDirectives(&mut this, project: &mut ParsedModule) -> bool {
        trace("TypeChecker.evaluateGlobalDirectives");
        for (mut i: usize = 0; i < project.declCount; i = i + 1) {
            let decl: &mut ParsedGlobalDecl = project.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_DIR) {
                let dir: &mut ParsedDeclValue = decl.data;
                // context arguments don't really matter, as we instantly overwrite them in
                // checkAndVerifyAndMaybeCalculateBuiltin() anyway
                let res: TCResult = this.checkAndVerifyAndMaybeCalculate(dir, true, true, true);
                if (!res.isValid())
                    return false;
            }
        }
        return true;
    }

    func reportErrors(&mut this) {
        if (this.errorCount > 0) unsafe {
            let stderr: Any = fdopen(2, "a");
            for (mut i: usize = 0; i < this.errorCount; i = i + 1) {
                let s: &String = (this.errors + i * sizeof String) as &String;
                fprintf(stderr, "%.*s", s.len(), s.chars());
                s.drop();
            }
            free(this.errors);
            this.errorCapacity = 0;
            this.errorCount = 0;
        }
    }

    func checkForUnusedVariables(&mut this, scope: &mut Scope) -> bool {
        mut any: bool = false;
        for (mut i: usize = 0; i < scope.length; i = i + 1) {
            let entry: &mut ScopeEntry = scope.getEntryAtIndex(i);
            if (!entry.isChecked) {
                this.warnUnusedVarDecl(entry);
                any = true;
            }
        }
        return any;
    }
    func checkProject(&mut this, project: &mut ParsedModule) -> bool {
        trace("TypeChecker.checkProject");
        if (!this.fillLookup(project)) {
            this.reportErrors();
            return false;
        }
        if (!this.evaluateGlobalDirectives(project)) {
            this.reportErrors();
            return false;
        }
        if (!this.startCheckFromEntry()) {
            this.reportErrors();
            return false;
        }
        trace("--- TypeChecker FINISHED ---");
        // reportErrors() resets this.errorCount
        let success: bool = this.errorCount == 0;
        this.reportErrors();
        return success;
    }

    func startCheckFromEntry(&mut this) -> bool {
        trace("TypeChecker.startCheckFromEntry");
        if (!this.foundEntry()) {
            this.printErrorCouldNotFindEntryPoint();
            return false;
        }
        let entry: &mut ParsedDeclValueBuiltin = this.entry;
        if (entry.argCount != 1) {
            this.printErrorEntryExpectedOneArgument(entry);
            return false;
        }
        let fn: &mut ParsedDeclValue = &mut entry.args[0];
        let res: TCResult = this.checkAndVerifyAndMaybeCalculate(fn, true, false, true);
        assert_with_msg(this.scopes.length == 1, "Expected scope stack to only contain global scope at the end");
        this.checkForUnusedVariables(this.removeScope());
        if (!res.isValid()) return false;
        if (!res.isType()) todo_with_msg("entry point is not a typedef");
        if (!res.typ.isFunction()) todo_with_msg("entry point isnt function");
        return true;
    }

    func foundEntry(&mut this) -> bool {
        trace("TypeChecker.foundEntry");
        unsafe {
            return this.entry != null;
        }
    }

    func matchTypeAndVerify(&mut this, expr: &mut ParsedDeclValue, expected: &Type, constContext: bool) -> TCResult {
        trace("TypeChecker.matchTypeAndVerify");
        mut res: TCResult = blank;
        assert_with_msg(expr.typ.isValid(), "matchTypeAndVerify called in wrong context");
        assert_with_msg(expr.typ.isType(), "matchTypeAndVerify called in wrong context");
        assert_with_msg(expr.typ.typ.isValid(), "matchTypeAndVerify called in wrong context");
        if (expr.kind == DECL_VALUE_MODULE) todo_with_msg("match DECL_VALUE_MODULE");
        else if (expr.kind == DECL_VALUE_FUNC_DECL) todo_with_msg("match DECL_VALUE_FUNC_DECL");
        else if (expr.kind == DECL_VALUE_STRUCT_DECL) todo_with_msg("match DECL_VALUE_STRUCT_DECL");
        else if (expr.kind == DECL_VALUE_ENUM_DECL) todo_with_msg("match DECL_VALUE_ENUM_DECL");
        else if (expr.kind == DECL_VALUE_UNION_DECL) todo_with_msg("match DECL_VALUE_UNION_DECL");
        else if (expr.kind == DECL_VALUE_BUILTIN) todo_with_msg("match DECL_VALUE_BUILTIN");
        else if (expr.kind == DECL_VALUE_CALL) {
            if (expr.typ.typ.equals(expected)) {
                res = newTCResult(true, *expected, blank);
            }
        } else if (expr.kind == DECL_VALUE_IDENT) {
            if (expr.typ.typ.equals(expected)) {
                res = newTCResult(true, *expected, blank);
            }
        } else if (expr.kind == DECL_VALUE_BINARY) unsafe {
            let bin: &mut ParsedDeclValueBinary = expr.data;
            res = this.matchTypeAndVerify(&mut bin.lhs, expected, constContext);
            if (!res.isValid()) return res;
            res = this.matchTypeAndVerify(&mut bin.rhs, expected, constContext);
            if (!res.isValid()) return res;
        } else if (expr.kind == DECL_VALUE_NUMBER) {
            if (expected.isInteger()) {
                res = newTCResult(true, *expected, blank);
            }
        } else if (expr.kind == DECL_VALUE_BLOCK) todo_with_msg("match DECL_VALUE_BLOCK");
        else if (expr.kind == DECL_VALUE_IF) unsafe {
            let iif: &mut ParsedDeclValueIf = expr.data;
            if (!iif.hasElse && !expected.isNone())
                return invalidTCResult();
            res = this.matchTypeAndVerify(&mut iif.ifBody, expected, constContext);
            if (!res.isValid()) return res;
            res = this.matchTypeAndVerify(&mut iif.elseBody, expected, constContext);
            if (!res.isValid()) return res;
        } else if (expr.kind == DECL_VALUE_UNARY) todo_with_msg("match DECL_VALUE_UNARY");
        else {
            assert_with_msg(false, "exhaustive handling of matchTypeAndVerify");
        }
        if (!res.isValid()) return res;
        if (res.isType()) res.typ.span = expr.span;
        if (constContext) res.flags = res.flags | RESULT_CONST;
        (*expr).typ = res;
        return res;
    }

    func checkAndVerifyAndMaybeCalculate(&mut this, expr: &mut ParsedDeclValue, complete: bool, typeContext: bool, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculate");
        mut res: TCResult = blank;
        if (expr.kind == DECL_VALUE_MODULE) todo_with_msg("DECL_VALUE_MODULE");
        else if (expr.kind == DECL_VALUE_FUNC_DECL)
            res = this.checkAndVerifyAndMaybeCalculateFuncDecl(expr.data, complete, false);
        else if (expr.kind == DECL_VALUE_STRUCT_DECL) todo_with_msg("DECL_VALUE_STRUCT_DECL");
        else if (expr.kind == DECL_VALUE_ENUM_DECL) todo_with_msg("DECL_VALUE_ENUM_DECL");
        else if (expr.kind == DECL_VALUE_UNION_DECL) todo_with_msg("DECL_VALUE_UNION_DECL");
        else if (expr.kind == DECL_VALUE_BUILTIN)
            res = this.checkAndVerifyAndMaybeCalculateBuiltin(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_CALL)
            res = this.checkAndVerifyAndMaybeCalculateCall(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_IDENT)
            res = this.checkAndVerifyAndMaybeCalculateIdent(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_BINARY)
            res = this.checkAndVerifyAndMaybeCalculateBinary(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_NUMBER)
            res = this.checkAndVerifyAndMaybeCalculateNumber(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_BLOCK)
            res = this.checkAndVerifyAndMaybeCalculateBlock(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_IF)
            res = this.checkAndVerifyAndMaybeCalculateIf(expr.data, constContext);
        else if (expr.kind == DECL_VALUE_UNARY)
            res = this.checkAndVerifyAndMaybeCalculateUnary(expr.data, typeContext, constContext);
        else {
            assert_with_msg(false, "exhaustive handling of checkAndVerifyAndMaybeCalculate");
        }
        if (!res.isValid()) return res;
        if (res.isType()) res.typ.span = expr.span;
        if (constContext) res.flags = res.flags | RESULT_CONST;
        (*expr).typ = res;
        return res;
    }

    func checkAndVerifyAndMaybeCalculateBlock(&mut this, block: &mut ParsedDeclValueBlock, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateBlock");
        // TODO: Allow blocks to return things -> Modify parser to accept the last statement
        //       missing a semicolon
        this.addScope();
        mut res: TCResult = invalidTCResult();
        for (mut i: usize = 0; i < block.stmtCount; i = i + 1) {
            let stmt: &mut ParsedStmt = block.getStmtAtIndex(i);
            res = this.checkAndVerifyAndMaybeCalculateStmt(stmt, constContext);
            if (!res.isValid()) {
                this.removeScope();
                return res;
            }
        }
        let scope: &mut Scope = this.removeScope();
        for (mut i: usize = 0; i < scope.length; i = i + 1) {
            let entry: &mut ScopeEntry = scope.getEntryAtIndex(i);
            if (!entry.isChecked) {
                this.warnUnusedVarDecl(entry);
            }
        }
        return newTCResult(true, newNoneType(block.span), blank);
    }

    func checkAndVerifyAndMaybeCalculateIf(&mut this, iif: &mut ParsedDeclValueIf, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateIf");
        let cond: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut iif.cond, false, false, constContext);
        if (!cond.isValid()) return cond;
        if (!cond.isType()) todo_with_msg("if cond is not a type");
        let t: Type = cond.typ;
        if (!t.isBool()) todo_with_msg("if cond not bool");
        if (cond.isValue()) {
            let b: bool = cond.value.bValue;
            if (b) {
                let block: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut iif.ifBody, false, false, constContext);
                if (!block.isValid()) return block;
                if (!block.isType()) todo_with_msg("if body is not a type");
                let blockType: Type = block.typ;
                if (iif.hasElse) {
                    this.warnUnreachableCodeBlock(&mut iif.elseBody);
                }
                return block;
            } else if (iif.hasElse) {
                let block: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut iif.elseBody, false, false, constContext);
                if (!block.isValid()) return block;
                if (!block.isType()) todo_with_msg("else body is not a type");
                let blockType: Type = block.typ;
                if (iif.hasElse) {
                    this.warnUnreachableCodeBlock(&mut iif.ifBody);
                }
                return block;
            } else {
                return newTCResult(true, newNoneType(iif.span), blank);
            }
        } else {
            let block: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut iif.ifBody, false, false, constContext);
            if (!block.isValid()) return block;
            if (!block.isType()) todo_with_msg("if body is not a type");
            let blockType: Type = block.typ;
            if (iif.hasElse) {
                let elze: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut iif.elseBody, false, false, constContext);
                if (!elze.isValid()) return elze;
                if (!elze.isType()) todo_with_msg("else body is not a type");
                let elseType: Type = elze.typ;
                if (!blockType.equals(&elseType)) {
                    let res: TCResult = this.matchTypeAndVerify(&mut iif.elseBody, &blockType, constContext);
                    if (!res.isValid()) {
                        let res: TCResult = this.matchTypeAndVerify(&mut iif.ifBody, &elseType, constContext);
                        if (!res.isValid()) {
                            this.printErrorIfBlocksTypeMismatch(blockType, elseType);
                            return invalidTCResult();
                        }
                    }
                }
                return block;
            } else {
                if (!blockType.isNone()) todo_with_msg("if body no else not none");
                return block;
            }
        }
    }

    func checkAndVerifyAndMaybeCalculateBinary(&mut this, binary: &mut ParsedDeclValueBinary, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateBinary");
        let lhsResult: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut binary.lhs, false, false, constContext);
        if (!lhsResult.isValid()) return lhsResult;
        let rhsResult: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut binary.rhs, false, false, constContext);
        if (!rhsResult.isValid()) return rhsResult;
        mut result: TCResult = invalidTCResult();
        if (binary.op == BINARY_OP_EQUAL
            || binary.op == BINARY_OP_NOT_EQUAL
            || binary.op == BINARY_OP_PLUS
            || binary.op == BINARY_OP_MINUS
            || binary.op == BINARY_OP_MULT
            || binary.op == BINARY_OP_DIV) {
            if (lhsResult.isType() && rhsResult.isType()) {
                let lhsType: Type = lhsResult.typ;
                mut rhsType: Type = rhsResult.typ;
                if (!lhsType.equals(&rhsType)) {
                    let res: TCResult = this.matchTypeAndVerify(&mut binary.rhs, &lhsType, constContext);
                    if (!res.isValid()) {
                        // TODO: Operator overloads
                        this.printErrorTypeMismatch(lhsType, rhsType);
                        return invalidTCResult();
                    }
                    rhsType = res.typ;
                }
                assert_with_msg(lhsType.equals(&rhsType), "maybe this assert is wrong, idk");
                mut val: Value = blank;
                if (lhsType.isType() && rhsType.isType()) {
                    if (binary.op == BINARY_OP_EQUAL || binary.op == BINARY_OP_NOT_EQUAL) {
                        mut s: bool = lhsType.typ.actual.equals(rhsType.typ.actual);
                        if (binary.op == BINARY_OP_NOT_EQUAL) s = !s;
                        val = newBoolValue(s);
                    } else {
                        this.printErrorBinaryOperationNotDefined(binary.span, lhsType, rhsType, binary.op);
                        return invalidTCResult();
                    }
                } else if (constContext) {
                    assert(lhsResult.isValue());
                    assert(rhsResult.isValue());
                    let res: Value = lhsResult.value.applyBinaryOperator(binary.op, &rhsResult.value);
                    if (!res.isValid()) todo_with_msg("const bin op not valid");
                    val = res;
                }
                if (binary.op == BINARY_OP_EQUAL || binary.op == BINARY_OP_NOT_EQUAL) {
                    result = newTCResult(true, newBoolType(binary.span), val);
                } else {
                    result = newTCResult(true, lhsType, val);
                }
            } else if (lhsResult.isValue() && rhsResult.isValue()) {
                // possible in expressions such as `10 == 10`
                todo_with_msg("both values");
            } else {
                todo_with_msg("ons is type, one is value?");
            }
        } else if (binary.op == BINARY_OP_ASSIGN) {
            if (lhsResult.isConst()) {
                this.printErrorAssignToConst(binary);
                return invalidTCResult();
            }
            let lhsType: Type = lhsResult.typ;
            mut rhsType: Type = rhsResult.typ;
            if (!binary.lhs.isLValue()) todo_with_msg("assign to non-lvalue");
            if (!lhsType.equals(&rhsType)) {
                let res: TCResult = this.matchTypeAndVerify(&mut binary.rhs, &lhsType, constContext);
                if (!res.isValid()) {
                    // TODO: Operator overloads
                    this.printErrorTypeMismatch(lhsType, rhsType);
                    return invalidTCResult();
                }
            }
            result = newTCResult(true, rhsType, blank);
        } else unsafe {
            printf("%llu\n", binary.op);
            todo_with_msg("binary");
        }
        if (!result.isValid()) return result;
        (*binary).typ = result;
        return result;
    }

    func checkAndVerifyAndMaybeCalculateUnary(&mut this, unary: &mut ParsedDeclValueUnary, typeContext: bool, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateUnary");
        let expr: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut unary.expr, false, typeContext, constContext);
        if (!expr.isValid()) return expr;
        if (unary.op == UNARY_OP_DEREF) {
            if (typeContext) {
                let ptr: Type = newPtrType(unary.span, &expr.typ, false);
                return newTCResult(true, ptr, blank);
            } else {
                assert_with_msg(expr.isType(), "of course this can also be a value");
                let t: Type = expr.typ;
                if (!t.isPointer()) todo_with_msg("deref non ptr");
                let underlying: &Type = t.ptr.underlying;
                return newTCResult(true, *underlying, blank);
            }
        } else if (unary.op == UNARY_OP_REF) {
            if (typeContext) todo_with_msg("& in a type context");
            if (!expr.isType()) todo_with_msg("& uses non type");
            mut t: Type = expr.typ;
            let typeType: bool = t.isType();
            if (typeType) t = *t.typ.actual;
            mut ptr: Type = newPtrType(unary.span, &t, false);
            if (typeType) ptr = newTypeType(unary.span, &ptr);
            return newTCResult(true, ptr, blank);
        } else {
            assert_with_msg(false, "exhaustive handling of unary ops");
            return blank;
        }
    }

    func checkAndVerifyAndMaybeCalculateCall(&mut this, call: &mut ParsedDeclValueCall, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateCall");
        let base: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut call.fn, true, false, constContext);
        if (!base.isValid()) return base;
        if (base.isType()) {
            assert_with_msg(!base.isValue(), "Call is both type and value?");
            let t: Type = base.typ;
            if (t.isType()) {
                let t: &Type = t.typ.actual;
                if (t.isInteger()) {
                    if (call.argCount != 1) todo_with_msg("int() wrong arg count");
                    let size: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut call.args[0], false, false, constContext);
                    if (!size.isValid()) return size;
                    if (!size.isValue()) todo_with_msg("passed type to int()");
                    let _v: Value = size.value;
                    if (!_v.isInteger()) todo_with_msg("passed non-int value to int()");
                    let v: i64 = _v.rawInt;
                    if (!t.int.signed && v < 0) todo_with_msg("negative int in int()");
                    return newTCResult(true, *t, _v);
                } else if (t.isBool()) {
                    if (call.argCount != 1) todo_with_msg("bool() wrong arg count");
                    let size: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut call.args[0], false, false, constContext);
                    if (!size.isValid()) return size;
                    if (!size.isValue()) todo_with_msg("passed type to bool()");
                    let _v: Value = size.value;
                    if (!_v.isInteger()) todo_with_msg("passed non-int value to bool()");
                    let v: i64 = _v.rawInt;
                    if (v == 0 || v == 1) return newTCResult(true, *t, _v.intoBoolValue());
                    todo_with_msg("passed int that's not 0 or 1 to bool()");
                } else unsafe {
                    printf("%hhu\n", t.kind);
                    todo_with_msg("type call idk");
                }
            } else if (t.isFunction()) {
                let fn: FuncType = t.fn;
                if (call.argCount != fn.paramCount) {
                    this.printErrorArgumentCountMismatch(call, fn.funcDecl);
                    return invalidTCResult();
                }
                if (fn.containsAnytype()) {
                    todo_with_msg("we need to get busy now :^)");
                } else {
                    // No generic parameters, no generic return type, we can simply check everything here
                    for (mut i: usize = 0; i < call.argCount; i = i + 1) {
                        let result: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut call.args[i], false, false, constContext);
                        if (!result.isValid()) return result;
                        if (!result.isType()) todo_with_msg("arg is not a type?");
                        let expected: Type = (*fn.params)[i];
                        mut got: Type = result.typ;
                        if (!expected.equals(&got)) {
                            let res: TCResult = this.matchTypeAndVerify(&mut call.args[i], &expected, constContext);
                            if (!res.isValid()) {
                                this.printErrorTypeMismatch(expected, got);
                            }
                        }
                    }
                    let retType: &Type = fn.retType;
                    return newTCResult(true, *retType, blank);
                }
            } else unsafe {
                printf("%hhu\n", t.kind);
                todo_with_msg("cringe");
            }
        }
        todo_with_msg("call");
        return blank;
    }

    func checkAndVerifyAndMaybeCalculateFuncDecl(&mut this, funcDecl: &mut ParsedFuncDecl, complete: bool, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateFuncDecl");
        mut paramTypes: [Type; 8] = blank;
        let scope: &mut Scope = this.addScope();
        for (mut i: usize = 0; i < funcDecl.paramCount; i = i + 1) {
            let param: &mut ParsedParam = funcDecl.getParamAtIndex(i);
            mut result: TCResult = this.checkAndVerifyAndMaybeCalculateTypeExpr(&mut param.typ, constContext);
            if (!result.isValid()) {
                this.removeScope();
                return result;
            }
            if (!result.isType()) todo_with_msg("param is not type");
            let rt: Type = result.typ;
            if (!rt.isType()) todo_with_msg("param type is not Type Type");
            result.typ = *rt.typ.actual;
            unsafe {
                let entry: ScopeEntry = ScopeEntry {
                    name: param.name.content,
                    span: param.span,
                    isChecked: true,
                    result: result,
                    node: null,
                };
                if (!scope.addEntry(entry)) {
                    this.removeScope();
                    return invalidTCResult();
                }
                paramTypes[i] = result.typ;
            }
        }
        let retResult: TCResult = this.checkAndVerifyAndMaybeCalculateTypeExpr(&mut funcDecl.retType, constContext);
        if (!retResult.isValid()) {
            this.removeScope();
            return retResult;
        }
        if (!retResult.isType()) todo_with_msg("return expr is not type");
        let retType: Type = retResult.typ;
        if (!retType.isType()) todo_with_msg("return type is not a Type Type");
        let fn: Type = newFuncType(funcDecl, funcDecl.span, &paramTypes, funcDecl.paramCount, retType.typ.actual);
        mut res: TCResult = newTCResult(true, fn, blank);
        if (complete) {
            this.pushFunctionOnStack(fn);
            mut valid: bool = true;
            for (mut i: usize = 0; i < funcDecl.stmtCount; i = i + 1) {
                let stmt: &mut ParsedStmt = funcDecl.getStmtAtIndex(i);
                let result: TCResult = this.checkAndVerifyAndMaybeCalculateStmt(stmt, constContext);
                if (!result.isValid()) valid = false;
            }
            this.popFunctionFromStack();
        } else {
            res.markIncomplete();
        }
        let _scope: &mut Scope = this.removeScope();
        assert_with_msg(_scope == scope, "Scope inbalance detected");
        this.checkForUnusedVariables(_scope);
        return res;
    }

    func checkAndVerifyAndMaybeCalculateStmt(&mut this, stmt: &mut ParsedStmt, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateStmt");
        if (stmt.kind == STMT_VAR_DECL) {
            trace("TypeChecker.checkAndVerifyAndMaybeCalculateStmt - VarDecl");
            let scope: &mut Scope = this.getCurrentScope();
            let decl: &mut ParsedVarDecl = stmt.data;
            if (!scope.addVarDecl(decl)) {
                let entry: &mut ScopeEntry = this.getVariableByName(decl.name.content);
                this.printErrorDuplicateIdentifier(decl.name.content, decl.name.span, entry.node.name.span);
                return invalidTCResult();
            }
            return newTCResult(true, newNoneType(stmt.span), blank);
        } else if (stmt.kind == STMT_RETURN) {
            trace("TypeChecker.checkAndVerifyAndMaybeCalculateStmt - return");
            // FIXME: 2nd argument (typeContext) is true if the function returns a type
            let result: TCResult = this.checkAndVerifyAndMaybeCalculate(stmt.data, false, false, constContext);
            if (!result.isValid()) return result;
            if (!result.isType()) todo_with_msg("ret expr is not type");
            let _fn: &mut Type = this.peekFunctionFromStack();
            assert((&*_fn).isFunction());
            let fn: &FuncType = &_fn.fn;
            let retType: &Type = fn.retType;
            mut gotType: Type = result.typ;
            if (retType.isNone() && !gotType.isNone()) {
                this.printErrorUnexpectedReturnValue(*retType, gotType);
                return invalidTCResult();
            }
            if (!retType.equals(&gotType)) {
                debug("mismatch in return type and gotten type");
                let res: TCResult = this.matchTypeAndVerify(stmt.data, retType, constContext);
                if (!res.isValid()) {
                    this.printErrorTypeMismatch(*retType, gotType);
                    return invalidTCResult();
                }
            }
            return newTCResult(true, newNoneType(retType.span), blank);
        } else if (stmt.kind == STMT_EXPR) {
            trace("TypeChecker.checkAndVerifyAndMaybeCalculateStmt - expr");
            let result: TCResult = this.checkAndVerifyAndMaybeCalculate(stmt.data, false, false, constContext);
            if (!result.isValid()) return result;
            return result;
        }
        assert_with_msg(false, "exhaustive handling of statements");
        return blank;
    }

    func checkAndVerifyAndMaybeCalculateTypeExpr(&mut this, typeExpr: &mut ParsedTypeExpr, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateTypeExpr");
        let result: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut typeExpr.expr, true, true, constContext);
        if (!result.isValid()) return result;
        if (!result.isType()) todo_with_msg("TypeExpr is not a type");
        return result;
    }

    func addComputedValueToStack(&mut this, span: Span, name: SubStr, value: TCResult) {
        trace("TypeChecker.addComputedValueToStack");
        assert(value.isValid());
        assert(value.isValue());
        mut scope: &mut Scope = this.getCurrentScope();
        assert(!scope.isKnownIdentifier(name));
        unsafe {
            scope.addEntry(ScopeEntry {
                name: name,
                span: span,
                isChecked: true,
                result: value,
                node: null
            });
        }
    }

    func removeLastIdentifierFromList(&mut this) {
        trace("TypeChecker.removeLastIdentifierFromList");
        assert_with_msg(this.identStack.length > 0, "Attempted to remove identifier from empty list");
        this.identStack.length = this.identStack.length - 1;
    }

    func addCurrentIdentifierToList(&mut this, ident: &mut ParsedDeclValueIdent) -> bool {
        trace("TypeChecker.addCurrentIdentifierToList");
        let exists: bool = this.identStack.isKnownIdentifier(ident.name);
        unsafe {
            this.identStack.addEntry(ScopeEntry {
                name: ident.name,
                span: ident.span,
                isChecked: false,
                result: blank,
                node: null
            });
        }
        return exists;
    }

    func checkAndVerifyAndMaybeCalculateIdent(&mut this, ident: &mut ParsedDeclValueIdent, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateIdent");
        let name: SubStr = ident.name;
        if (!this.isKnownIdentifier(name)) {
            this.printErrorUseOfUnknownIdentifier(ident);
            return invalidTCResult();
        }
        let entry: &mut ScopeEntry = this.getVariableByName(name);
        if (entry.isChecked) {
            debug("Identifier is already checked, returning the result");
            debug(entry.name.toString().chars());
            assert_with_msg(entry.result.isValid(), "Attempted to return invalid result from already checked identifier");
            return entry.result;
        }
        let expr: &mut ParsedDeclValue = &mut entry.node.value;
        if (this.addCurrentIdentifierToList(ident)) {
            this.printErrorRecursiveIdentifiers(ident);
            return invalidTCResult();
        }
        let isConst: bool = entry.node.isConst;
        if (constContext && !isConst) {
            this.printErrorLetInConstContext(entry.node);
            return invalidTCResult();
        }
        mut result: TCResult = this.checkAndVerifyAndMaybeCalculate(expr, false, false, isConst);
        this.removeLastIdentifierFromList();
        if (!result.isValid()) {
            return result;
        }
        if (result.isType()) {
            if (result.typ.isType()) {
                if (!isConst) {
                    this.printErrorTypeDeclWithLet(entry.node, result);
                    return invalidTCResult();
                }
            }
        }
        debug("Successfully checked identifier");
        (*entry).result = result;
        (*expr).typ = result;
        mut generic: bool = false;
        if (result.isType()) {
            if (result.typ.isFunction()) {
                if (result.isIncomplete()) {
                    if (!result.typ.fn.containsAnytype()) {
                        (*entry).isChecked = true; // Temporarily set to true so we can check recursive functions
                        result = this.checkAndVerifyAndMaybeCalculate(expr, true, false, isConst);
                    } else {
                        debug("Identifier is generic function");
                        generic = true;
                    }
                }
            }
        }
        let checked: bool = !generic;
        (*entry).isChecked = checked; // We can reuse all identifier types, except generic ones
        (*entry).node.used = checked;
        return result;
    }

    func checkAndVerifyAndMaybeCalculateNumber(&mut this, number: &mut ParsedDeclValueNumber, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateNumber");
        let n: String = number.number.toString();
        let i: i64 = n.toI64();
        n.drop();
        let v: Value = newIntValue(i);
        let t: Type = newIntType(number.span, -1, true);
        return newTCResult(true, t, v);
    }

    func checkAndVerifyAndMaybeCalculateBuiltin(&mut this, builtin: &mut ParsedDeclValueBuiltin, constContext: bool) -> TCResult {
        trace("TypeChecker.checkAndVerifyAndMaybeCalculateBuiltin");
        let name: SubStr = builtin.name;
        if (name.equals(&BUILTIN_INTEGER)) {
            if (builtin.argCount != 2) todo_with_msg("@integer() wrong arg count");
            let size: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut builtin.args[0], false, false, true);
            if (!size.isValid()) return size;
            if (!size.isValue()) todo_with_msg("first arg to @integer() is type");
            let sizeValue: Value = size.value;
            if (!sizeValue.isInteger()) todo_with_msg("first arg to @integer() is non-int");
            let signed: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut builtin.args[1], false, false, true);
            if (!signed.isValid()) return signed;
            if (!signed.isValue()) todo_with_msg("second arg to @integer() is type");
            let signedValue: Value = signed.value;
            if (!signedValue.isBool()) todo_with_msg("second arg to @integer() is non-bool");
            let isSigned: bool = signedValue.bValue;
            let bitsize: i64 = sizeValue.rawInt;
            let int: Type = newIntType(builtin.span, bitsize, isSigned);
            return newTCResult(true, newTypeType(builtin.span, &int), blank);
        } else if (name.equals(&BUILTIN_FLOAT)) todo_with_msg("BUILTIN_FLOAT");
        else if (name.equals(&BUILTIN_BOOLEAN)) {
            if (builtin.argCount != 0) todo_with_msg("@boolean() wrong arg count");
            let boolean: Type = newBoolType(builtin.span);
            return newTCResult(true, newTypeType(builtin.span, &boolean), blank);
        } else if (name.equals(&BUILTIN_SELF)) todo_with_msg("BUILTIN_SELF");
        else if (name.equals(&BUILTIN_ANYTYPE)) { 
            if (builtin.argCount != 0) todo_with_msg("@anytype() wrong arg count");
            let anytype: Type = newAnytypeType(builtin.span);
            return newTCResult(true, newTypeType(builtin.span, &anytype), blank);
        } else if (name.equals(&BUILTIN_ANYVALUE)) todo_with_msg("BUILTIN_ANYVALUE");
        else if (name.equals(&BUILTIN_NONE)) {
            if (builtin.argCount != 0) todo_with_msg("@none() wrong arg count");
            let none: Type = newNoneType(builtin.span);
            return newTCResult(true, newTypeType(builtin.span, &none), blank);
        } else if (name.equals(&BUILTIN_ENTRY)) {
            this.entry = builtin;
            return newTCResult(true, blank, blank);
        } else if (name.equals(&BUILTIN_CHECK)) {
            debug("Evaluating check");
            mut valid: bool = true;
            for (mut i: usize = 0; i < builtin.argCount; i = i + 1) {
                let res: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut builtin.args[i], false, false, false);
                if (!res.isValid()) valid = false;
            }
            if (!valid) {
                debug("--CHECK INVALID--");
                return invalidTCResult();
            }
            return newTCResult(true, newNoneType(builtin.span), blank);
        } else if (name.equals(&BUILTIN_ASSERT)) {
            debug("Evaluating assert");
            if (builtin.argCount != 1) todo_with_msg("@assert() wrong arg count");
            let res: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut builtin.args[0], false, false, true);
            if (!res.isValid()) return res;
            if (!res.isType()) todo_with_msg("assert not a type, but do we care");
            if (!res.isValue()) todo_with_msg("assert not a value, we do care");
            let val: Value = res.value;
            if (!val.isBool()) todo_with_msg("assert value not a bool");
            let success: bool = val.bValue;
            if (!success) {
                this.printErrorStaticAssertFailed(builtin);
                return invalidTCResult();
            }
            return newTCResult(true, newNoneType(builtin.span), blank);
        } else if (name.equals(&BUILTIN_TYPEOF)) {
            if (builtin.argCount != 1) todo_with_msg("@typeof() wrong arg count");
            let res: TCResult = this.checkAndVerifyAndMaybeCalculate(&mut builtin.args[0], false, false, false);
            if (!res.isValid()) return res;
            if (!res.isType()) todo_with_msg("typeof not a type");
            let typ: Type = res.typ;
            if (typ.isType()) todo_with_msg("@typeof(TypeType) == ??? Maybe anytype? Idk");
            return newTCResult(true, newTypeType(builtin.span, &typ), blank);
        } else todo_with_msg("unknown");
        return blank;
    }
}

func newTypeChecker() -> TypeChecker {
    trace("newTypeChecker");
    unsafe {
        return TypeChecker {
            errors: null,
            errorCount: 0,
            errorCapacity: 0,
            scopes: newScopeList(),
            entry: null,
            funcStack: null,
            funcStackLen: 0,
            funcStackCapacity: 0,
            identStack: newScope(),
        };
    }
}
