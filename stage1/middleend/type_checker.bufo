import "string.bufo";
import "frontend/nodes.bufo";
import "middleend/nodes.bufo";
import "util/span.bufo";
import "middleend/builtins.bufo";

func verifyBuiltinArgType(builtin: &ParsedDeclValue, size: &Type, argIndex: usize, expected: usize, builtinName: &char) -> bool {
    if (size.kind != expected) unsafe {
        let stderr: Any = fdopen(2, "a");
        fprintf(stderr, "error: %s: Builtin `%s` expects %s as argument %llu, got %s.\n", builtin.span.toString().chars(), builtinName, evalTypeToStr(expected), argIndex, evalTypeToStr(size.kind));
        return false;
    }
    return true;
}

func verifyBuiltinArgCount(builtin: &ParsedDeclValue, call: &ParsedDeclValueCall, expectedArgCount: usize, builtinName: &char) -> bool {
    if (call.argCount != expectedArgCount) unsafe {
        let stderr: Any = fdopen(2, "a");
        fprintf(stderr, "error: %s: Builtin `%s` expects exactly %llu argument(s).\n", builtin.span.toString().chars(), builtinName, expectedArgCount);
        return false;
    }
    return true;
}

func newBuiltinInteger(size: &Type) -> StructType {
    debug("Creating new integer type");
    mut int: StructType = newStructType();
    int.addField(defaultSpan(), newSubStrOfStrLit("bitsize"), size);
    return int;
}
func newBuiltinFloat(size: &Type) -> StructType {
    debug("Creating new float type");
    mut float: StructType = newStructType();
    float.addField(defaultSpan(), newSubStrOfStrLit("bitsize"), size);
    return float;
}

comptime BUILTIN_KIND_INVALID: usize = 0;
comptime BUILTIN_KIND_ANYTYPE: usize = 1;
comptime BUILTIN_KIND_ANYVALUE: usize = 2;
comptime BUILTIN_KIND_NONE: usize = 3;
comptime BUILTIN_KIND_STRUCT: usize = 4;
struct BuiltinType {
    kind: usize;
    span: Span;
    data: Any;

    func isType(&this) -> bool {
        assert_with_msg(this.kind != BUILTIN_KIND_INVALID, "BuiltinType.isType() got invalid kind");
        return this.kind == BUILTIN_KIND_ANYTYPE
            || this.kind == BUILTIN_KIND_STRUCT
            || this.kind == BUILTIN_KIND_NONE;
    }

    func isAnytype(&this) -> bool {
        return this.kind == BUILTIN_KIND_ANYTYPE;
    }
}

func invalidBuiltin() -> BuiltinType {
    unsafe {
        return BuiltinType {
            kind: BUILTIN_KIND_INVALID,
            span: defaultSpan(),
            data: null
        };
    }
}

func newBuiltinType(span: Span, kind: usize, size: usize, data: Any) -> BuiltinType {
    return BuiltinType {
        kind: kind,
        span: span,
        data: data
    };
}

// in createTypeFromFunc():
// - UNSET means we haven't set the return type yet :) You can expect retData to be null
// - EVAL means that we were able to compute the return type right then and there and
//   store an Type
// - NODE means we are missing information (for example generic parameter) and store
//   the Node for later Interpretation
comptime RET_KIND_UNSET: usize = 0;
comptime RET_KIND_EVAL: usize = 1;
comptime RET_KIND_NODE: usize = 2;
struct FuncType {
    node: &ParsedFuncDecl;
    params: &mut NameTypePair;
    paramLen: usize;
    paramCap: usize;
    retKind: usize;
    retData: Any;
    func hasParameter(&this, name: &SubStr) -> bool {
        for (mut i: usize = 0; i < this.paramLen; i = i + 1) {
            let param: &NameTypePair = this.getParamAtIndex(i);
            if (param.name.equals(name))
                return true;
        }
        return false;
    }
    func addParameter(&mut this, span: Span, name: SubStr, typ: &Type) {
        if (this.paramLen >= this.paramCap) {
            todo_with_msg("Resize params");
        }
        if ((&*this).hasParameter(&name)) {
            todo_with_msg("Report error: Duplicate param");
        }
        let pair: NameTypePair = NameTypePair {
            span: span,
            name: name,
            value: *typ
        };
        unsafe {
            *(this.params + this.paramLen * sizeof NameTypePair) = pair;
        }
        this.paramLen = this.paramLen + 1;
    }
    func getParamAtIndex(&this, index: usize) -> &NameTypePair {
        assert_with_msg(index < this.paramLen, "Out of bounds ac cess in FuncType.getParamAtIndex()");
        unsafe {
            let _param: &mut NameTypePair = this.params + index * sizeof NameTypePair;
            return _param as &NameTypePair;
        }
    }
    func getParamByName(&this, name: &SubStr) -> &NameTypePair {
        for (mut i: usize = 0; i < this.paramLen; i = i + 1) {
            let param: &NameTypePair = this.getParamAtIndex(i);
            if (param.name.equals(name))
                return param;
        }
        assert_with_msg(this.hasParameter(name), "unreachable");
        assert_with_msg(false, "unreachable");
        return &defaultNameTypePair();
    }
    func setReturnAST(&mut this, node: &ParsedTypeExpr) {
        this.retKind = RET_KIND_NODE;
        this.retData = node;
    }
    func setReturnType(&mut this, val: &Type) {
        unsafe {
            let mem: Any = calloc(sizeof Type, 1);
            assert_with_msg(mem != null, "Could not allocate memory in setReturnType");
            memcpy(mem, val, sizeof Type);
            this.retKind = RET_KIND_EVAL;
            this.retData = mem;
        }
    }
}

func newFuncType(node: &ParsedFuncDecl) -> FuncType {
    unsafe {
        let mem: Any = calloc(sizeof NameTypePair, INITIAL_CAPACITY);
        assert_with_msg(mem != null, "Could not allocate memory in newFuncType()");
        let params: &mut NameTypePair = &mut *mem;
        return FuncType {
            node: node,
            params: params,
            paramLen: 0,
            paramCap: INITIAL_CAPACITY,
            retKind: RET_KIND_UNSET,
            retData: null
        };
    }
}

struct StructType {
    fields: &mut NameTypePair;
    fieldLen: usize;
    fieldCap: usize;
    assets: &mut NameTypePair;
    assetLen: usize;
    assetCap: usize;
    func addField(&mut this, span: Span, name: SubStr, field: &Type) {
        if (this.fieldLen >= this.fieldCap) {
            todo_with_msg("Resize StructType");
        }
        let pair: NameTypePair = NameTypePair {
            span: span,
            name: name,
            value: *field
        };
        unsafe {
            *(this.fields + this.fieldLen * sizeof NameTypePair) = pair;
        }
        this.fieldLen = this.fieldLen + 1;
    }
    func addAsset(&mut this, span: Span, name: SubStr, asset: &Type) {
        if (this.assetLen >= this.assetCap) {
            todo_with_msg("Resize StructType");
        }
        let pair: NameTypePair = NameTypePair {
            span: span,
            name: name,
            value: *asset
        };
        unsafe {
            *(this.assets + this.assetLen * sizeof NameTypePair) = pair;
        }
        this.assetLen = this.assetLen + 1;
    }
}

func newStructType() -> StructType {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof NameTypePair);
        assert_with_msg(mem != null, "Could not allocate memory in newStructType()");
        let fields: &mut NameTypePair = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof NameTypePair);
        assert_with_msg(mem != null, "Could not allocate memory in newStructType()");
        let assets: &mut NameTypePair = &mut *mem;
        return StructType {
            fields: fields,
            fieldLen: 0,
            fieldCap: INITIAL_CAPACITY,
            assets: assets,
            assetLen: 0,
            assetCap: INITIAL_CAPACITY
        };
    }
}

struct EnumType {
    variantType: Type;
    variants: &mut NameTypePair;
    variantsLen: usize;
    variantsCap: usize;
    func setVariantType(&mut this, typ: &Type) {
        this.variantType = *typ;
    }

    func addVariant(&mut this, span: Span, name: SubStr, typ: &Type) {
        if (this.variantsLen >= this.variantsCap) {
            todo_with_msg("Resize variants in EnumType");
        }
        let pair: NameTypePair = NameTypePair {
            span: span,
            name: name,
            value: *typ
        };
        unsafe {
            *(this.variants + this.variantsLen * sizeof NameTypePair) = pair;
        }
        this.variantsLen = this.variantsLen + 1;
    }
}

func newEnumType() -> EnumType {
    unsafe {
        let mem: Any = calloc(INITIAL_CAPACITY, sizeof NameTypePair);
        assert_with_msg(mem != null, "Could not allocate memory in newEnumType()");
        let variants: &mut NameTypePair = &mut *mem;
        return EnumType {
            variantType: invalidType(),
            variants: variants,
            variantsLen: 0,
            variantsCap: INITIAL_CAPACITY,
        };
    }
}

comptime TYPE_INVALID: usize = 0;
comptime TYPE_UNRESOLVED: usize = 1;
comptime TYPE_BUILTIN: usize = 2;
comptime TYPE_STRUCT: usize = 3;
comptime TYPE_ENUM: usize = 4;
comptime TYPE_FUNC: usize = 5;
comptime TYPE_INTEGER: usize = 6;
comptime TYPE_FLOAT: usize = 7;
func evalTypeToStr(kind: usize) -> &char {
    if (kind == TYPE_INVALID) return "an invalid type";
    else if (kind == TYPE_UNRESOLVED) return "an unresolved type";
    else if (kind == TYPE_BUILTIN) return "a builtin";
    else if (kind == TYPE_STRUCT) return "a struct";
    else if (kind == TYPE_ENUM) return "an enum";
    else if (kind == TYPE_FUNC) return "a function";
    else if (kind == TYPE_INTEGER) return "an integer";
    else if (kind == TYPE_FLOAT) return "a float";
    assert_with_msg(false, "unreachable code in evalTypeToStr");
    return "";
}

struct Type {
    kind: usize;
    span: Span;
    data: Any;
    value: &ParsedDeclValue;

    func requiresImmutable(&this) -> bool {
        // Values that don't allow reassignment
        // e.g. mut Point = struct {}; is disallowed
        return this.kind == TYPE_STRUCT
            || this.kind == TYPE_ENUM
            || this.kind == TYPE_FUNC
            || this.kind == TYPE_BUILTIN;
    }

    func isValid(&this) -> bool {
        return this.kind != TYPE_INVALID;
    }
    func isUnresolved(&this) -> bool {
        return this.kind == TYPE_UNRESOLVED;
    }

    func isInvalidOrUnresolved(&this) -> bool {
        return this.kind == TYPE_INVALID || this.kind == TYPE_UNRESOLVED;
    }

    func isInteger(&this) -> bool {
        return this.kind == TYPE_INTEGER;
    }

    func isFunc(&this) -> bool {
        return this.kind == TYPE_FUNC;
    }

    func isType(&this) -> bool {
        if (this.kind == TYPE_BUILTIN) unsafe {
            return (this.data as &BuiltinType).isType();
        }
        return this.kind == TYPE_STRUCT
            || this.kind == TYPE_ENUM;
    }

    func isAnytype(&this) -> bool {
        if (this.kind != TYPE_BUILTIN) return false;
        unsafe {
            return (this.data as &BuiltinType).isAnytype();
        }
    }
}

func unresolvedType() -> Type {
    mut typ: Type = invalidType();
    typ.kind = TYPE_UNRESOLVED;
    return typ;
}

func invalidType() -> Type {
    unsafe {
        return blank;
    }
}

func newType(span: Span, kind: usize, size: usize, data: Any) -> Type {
    unsafe {
        let mem: Any = calloc(size, 1);
        assert_with_msg(mem != null, "Could not allocate memory for newType()");
        memcpy(mem, data, size);
        return Type {
            kind: kind,
            span: span,
            data: mem,
            value: null,
        };
    }
}

struct NameTypePair {
    span: Span;
    name: SubStr;
    value: Type;
}

func defaultNameTypePair() -> NameTypePair {
    return NameTypePair {
        span: defaultSpan(),
        name: defaultSubStr(),
        value: invalidType(),
    };
}


struct TypeChecker {
    hadErrorsInLookupStage: bool;
    identLookup: &mut SubStr;
    identLookupLen: usize;
    identLookupCap: usize;
    unresolvedDecls: &mut &ParsedVarDecl;
    unresolvedLen: usize;
    unresolvedCap: usize;
    resolvedDecls: &mut NameTypePair;
    resolvedLen: usize;
    resolvedCap: usize;
    func checkProject(&mut this, parsedProject: &ParsedModule) -> CheckedModule {
        if (!this.fillLookup(parsedProject)) unsafe {
            // Errors are already reported while filling the lookup
            exit(1);
        }
        return this.checkModule(parsedProject);
    }

    func checkModule(&mut this, parsedModule: &ParsedModule) -> CheckedModule {
        todo_with_msg("checkModule");
        return blank;
    }

    func createTypeFromStruct(&mut this, strukt: &ParsedStructDecl) -> Type {
        trace("createTypeFromStruct");
        mut structVal: StructType = newStructType();
        for (mut i: usize = 0; i < strukt.assetCount; i = i + 1) {
            let asset: &ParsedStructAsset = strukt.getAssetAtIndex(i);
            let typ: Type = this.createTypeFrom(&asset.asset.value);
            if (typ.isInvalidOrUnresolved())
                return typ;
            let name: Token = asset.asset.name;
            structVal.addAsset(name.span, name.content, &typ);
        }
        for (mut i: usize = 0; i < strukt.fieldCount; i = i + 1) {
            let field: &ParsedStructField = strukt.getFieldAtIndex(i);
            debug(field.name.toString().chars());
            let typ: Type = this.createTypeFromTypeExpr(&field.typ);
            if (typ.isInvalidOrUnresolved())
                return typ;
            structVal.addField(field.span, field.name, &typ);
        }

        return newType(strukt.span, TYPE_STRUCT, sizeof StructType, &structVal);
    }
    func createTypeFromEnum(&mut this, eenum: &ParsedEnumDecl) -> Type {
        trace("createTypeFromEnum");
        mut enumVal: EnumType = newEnumType();
        if (eenum.hasVariantType) {
            let typ: Type = this.createTypeFromTypeExpr(eenum.variantType);
            if (typ.isInvalidOrUnresolved())
                return typ;
            enumVal.setVariantType(&typ);
        } else {
            // REVIEW: We might get into reference problems here
            // REVIEW: Save space for enums by allocating log2(variantCount) bits instead of always i32
            let _inner: ParsedDeclValueIdent = ParsedDeclValueIdent {
                span: defaultSpan(),
                name: newSubStrOfStrLit("i32")
            };
            let i32_type: Type = this.createTypeFromIdent(&_inner);
            if (i32_type.isInvalidOrUnresolved())
                return i32_type;
            enumVal.setVariantType(&i32_type);
        }
        for (mut i: usize = 0; i < eenum.variantsLen; i = i + 1) unsafe {
            let variant: &ParsedEnumVariant = eenum.getVariantAtIndex(i);
            if (enumVal.variantType.isAnytype()) {
                mut val: Type = this.createTypeFrom(&variant.value);
                if (val.isInvalidOrUnresolved())
                    return val;
                if (!val.isType()) unsafe {
                    let stderr: Any = fdopen(2, "a");
                    let evalType: &char = evalTypeToStr(val.kind);
                    let loc: String = variant.span.toString();
                    let defLoc: String = val.span.toString();
                    fprintf(stderr, "error: %s: Generic enum expected a type for every variant, found %s.\nnote: %s: The given expression evaluates to %s.\n", loc.chars(), evalType, defLoc.chars(), evalType);
                    defLoc.drop();
                    loc.drop();
                    this.hadErrorsInLookupStage = true;
                    return invalidType();
                }
                enumVal.addVariant(variant.span, variant.name, &val);
            } else {
                enumVal.addVariant(variant.span, variant.name, &enumVal.variantType);
            }
        }
        return newType(eenum.span, TYPE_ENUM, sizeof EnumType, &enumVal);
    }
    func createTypeFromFunc(&mut this, funcExpr: &ParsedFuncDecl) -> Type {
        trace("createTypeFromFunc");
        mut funcVal: FuncType = newFuncType(funcExpr);
        for (mut i: usize = 0; i < funcExpr.paramCount; i = i + 1) {
            let param: &ParsedParam = funcExpr.getParamAtIndex(i);
            if (funcVal.hasParameter(&param.name)) unsafe {
                let duplicate: &NameTypePair = funcVal.getParamByName(&param.name);
                let stderr: Any = fdopen(2, "a");
                let name: String = param.name.toString();
                let loc: String = param.span.toString();
                let prevLocStr: String = duplicate.span.toString();
                fprintf(stderr, "error: %s: Redeclaration of variable %s.\nnote: %s: Variable already declared here.\n", loc.chars(), name.chars(), prevLocStr.chars());
                prevLocStr.drop();
                loc.drop();
                name.drop();
                this.hadErrorsInLookupStage = true;
            }
            let typ: Type = this.createTypeFromTypeExpr(&param.typ);
            if (typ.isInvalidOrUnresolved())
                return typ;
            if (!typ.isType()) todo_with_msg("param has value as type");
            funcVal.addParameter(param.span, param.name, &typ);
        }
        // Step 1: Does any parameter occur in return type?
        // > If yes, we can't compute type now, must do later when calling the function, on the fly
        // - Example: func (t: type) -> t {};
        //   - We only know the type of `t` at the call site
        // Step 2: Is return type valid?
        // > If yes, set return type of FuncType
        // - Example: func (i: i32) -> i32 {};
        // - Example: func (t: type) -> i32 {};
        //   - Both examples are trivial, we just know the type. Those are normal functions.
        // Step 3: Is return type anytype?
        // > If yes, we can't compute type now, must do later when calling the function, on the fly
        // - Example: func (t: type) -> type {};
        //   - Return type may have field `t`
        // - Example: func (v: i32) -> type {};
        //   - Return type may be control-flow-dependent on `if v`
        // - Example: func () -> type {};
        //   - Return type may be dependent on other values inside the function
        mut foundMatch: bool = false;
        assert(funcExpr.paramCount == funcVal.paramLen);
        for (mut i: usize = 0; i < funcExpr.paramCount; i = i + 1) {
            let param: &ParsedParam = funcExpr.getParamAtIndex(i);
            let paramType: &NameTypePair = funcVal.getParamAtIndex(i);
            if (this.findIdentInTypeExpr(param.name, &funcExpr.retType)) {
                foundMatch = true;
                break;
            }
        }
        if (foundMatch) {
            // Case 1 - Return type depends on parameter
            funcVal.setReturnAST(&funcExpr.retType);
        } else {
            let typ: Type = this.createTypeFromTypeExpr(&funcExpr.retType);
            if (typ.isInvalidOrUnresolved()) {
                // Return type could not be evaluated
                // May be due to unknown type identifiers
                return typ;
            }
            if (typ.isAnytype()) {
                // Case 3 - Return type is generic
                funcVal.setReturnAST(&funcExpr.retType);
            } else {
                // Case 2 - Return type is known
                funcVal.setReturnType(&typ);
            }
        }
        return newType(funcExpr.span, TYPE_FUNC, sizeof FuncType, &funcVal);
    }
    // FIXME: As we will need better pattern matching soon, we should move this to a separate file
    func findIdentInTypeExpr(&mut this, name: SubStr, node: &ParsedTypeExpr) -> bool {
        return this.findIdentInDeclValue(name, &node.expr);
    }
    func findIdentInDeclValue(&mut this, name: SubStr, node: &ParsedDeclValue) -> bool {
        assert_with_msg(node.kind != DECL_VALUE_INVALID, "Expected valid DeclValue");
        if (node.kind == DECL_VALUE_CALL) {
            let call: &ParsedDeclValueCall = node.asCall();
            if (this.findIdentInDeclValue(name, &call.fn))
                return true;
            for (mut i: usize = 0; i < call.argCount; i = i + 1)
                if (this.findIdentInDeclValue(name, &call.args[i]))
                    return true;
        } else if (node.kind == DECL_VALUE_IDENT) {
            let ident: &ParsedDeclValueIdent = node.asIdent();
            return ident.name.equals(&name);
        } else unsafe {
            printf("[WARN] Unsupported kind in findIdentInDeclValue: %llu\n", node.kind);
        }
        return false;
    }
    func createTypeFromTypeExpr(&mut this, typeExpr: &ParsedTypeExpr) -> Type {
        let typ: Type = this.createTypeFrom(&typeExpr.expr);
        if (typ.isInvalidOrUnresolved())
            return typ;
        if (!typ.isType()) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = typeExpr.expr.span.toString();
            let defLoc: String = typ.span.toString();
            fprintf(stderr, "error: %s: Expected a type value, found %s.\nnote: %s: Value evaluated here.\n", loc.chars(), evalTypeToStr(typ.kind), defLoc.chars());
            defLoc.drop();
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return invalidType();
        }
        return typ;
    }
    func getResolvedAtIndex(&mut this, index: usize) -> &NameTypePair {
        assert_with_msg(index < this.resolvedLen, "Out of bounds for getResolvedAtIndex");
        unsafe {
            return (this.resolvedDecls + index * sizeof NameTypePair) as &NameTypePair;
        }
    }
    func getUnresolvedAtIndex(&mut this, index: usize) -> &ParsedVarDecl {
        assert_with_msg(index < this.unresolvedLen, "Out of bounds for getUnresolvedAtIndex");
        unsafe {
            return *(this.unresolvedDecls + index * sizeof &ParsedVarDecl) as &ParsedVarDecl;
        }
    }
    func createTypeFromIdent(&mut this, ident: &ParsedDeclValueIdent) -> Type {
        trace("createTypeFromIdent");
        let name: SubStr = ident.name;
        if (!this.isKnownIdentifier(&name)) unsafe {
            let loc: String = ident.span.toString();
            let nameLoc: String = name.toString();
            printf("error: %s: Use of unknown identifier %s.\n", loc.chars(), nameLoc.chars());
            nameLoc.drop();
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return invalidType();
        }
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let pair: &NameTypePair = this.getResolvedAtIndex(i);
            if (name.equals(&pair.name)) {
                debug("Match!");
                let s: String = name.toString();
                debug(s.chars());
                s.drop();
                return pair.value;
            }
        }
        return unresolvedType();
    }
    func createTypeFromNumber(&mut this, number: &ParsedDeclValueNumber) -> Type {
        trace("createTypeFromNumber");
        let val: String = number.number.toString();
        assert_with_msg(val.isNumber(), "Could not parse literal into a number");
        let value: i64 = val.toI64();
        val.drop();
        unsafe {
            return newType(number.span, TYPE_INTEGER, sizeof i64, &value);
        }
    }
    func createTypeFromBuiltin(&mut this, builtin: &ParsedDeclValue) -> Type {
        trace("createTypeFromBuiltin");
        assert_with_msg(builtin.kind == DECL_VALUE_CALL, "createTypeFromBuiltin expected DECL_VALUE_CALL");
        let call: &ParsedDeclValueCall = builtin.data;
        let fn: &ParsedDeclValue = &call.fn;
        assert_with_msg(fn.kind == DECL_VALUE_IDENT, "Builtins are expected to be simple ident calls like @builtin()");
        let ident: &ParsedDeclValueIdent = fn.data;
        let name: SubStr = ident.name;
        if (name.equals(&BUILTIN_INTEGER)) {
            if (!verifyBuiltinArgCount(builtin, call, 1, "integer")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            let arg: &ParsedDeclValue = &call.args[0];
            let size: Type = this.createTypeFrom(arg);
            if (size.isInvalidOrUnresolved()) return size;
            if (!verifyBuiltinArgType(builtin, &size, 0, TYPE_INTEGER, "integer")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            let int: StructType = newBuiltinInteger(&size);
            let btn: BuiltinType = newBuiltinType(builtin.span, BUILTIN_KIND_STRUCT, sizeof StructType, &int);
            return newType(builtin.span, TYPE_BUILTIN, sizeof BuiltinType, &btn);
        } else if (name.equals(&BUILTIN_FLOAT)) {
            if (!verifyBuiltinArgCount(builtin, call, 1, "float")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            let arg: &ParsedDeclValue = &call.args[0];
            let size: Type = this.createTypeFrom(arg);
            if (size.isInvalidOrUnresolved()) return size;
            if (!verifyBuiltinArgType(builtin, &size, 0, TYPE_INTEGER, "float")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            let float: StructType = newBuiltinFloat(&size);
            let btn: BuiltinType = newBuiltinType(builtin.span, BUILTIN_KIND_STRUCT, sizeof StructType, &float);
            return newType(builtin.span, TYPE_BUILTIN, sizeof BuiltinType, &btn);
        } else if (name.equals(&BUILTIN_ANYTYPE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "anytype")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            // TODO: Create dedicated newBuiltinAnytype()
            mut anytype: BuiltinType = invalidBuiltin();
            anytype.kind = BUILTIN_KIND_ANYTYPE;
            anytype.span = builtin.span;
            return newType(builtin.span, TYPE_BUILTIN, sizeof BuiltinType, &anytype);
        } else if (name.equals(&BUILTIN_ANYVALUE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "anyvalue")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            // TODO: Create dedicated newBuiltinAnyvalue()
            mut anyvalue: BuiltinType = invalidBuiltin();
            anyvalue.kind = BUILTIN_KIND_ANYVALUE;
            anyvalue.span = builtin.span;
            return newType(builtin.span, TYPE_BUILTIN, sizeof BuiltinType, &anyvalue);
        } else if (name.equals(&BUILTIN_NONE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "none")) {
                this.hadErrorsInLookupStage = true;
                return invalidType();
            }
            // TODO: Create dedicated newBuiltinNone()
            mut none: BuiltinType = invalidBuiltin();
            none.kind = BUILTIN_KIND_NONE;
            none.span = builtin.span;
            return newType(builtin.span, TYPE_BUILTIN, sizeof BuiltinType, &none);
        } else {
            debug(name.toString().chars());
            todo_with_msg("createTypeFromBuiltin");
        }
        return invalidType();
    }
    func createTypeFromCall(&mut this, call: &ParsedDeclValueCall) -> Type {
        trace("createTypeFromCall");
        let typ: Type = this.createTypeFrom(&call.fn);
        if (typ.isInvalidOrUnresolved())
            return typ;
        if (!typ.isFunc()) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = call.fn.span.toString();
            fprintf(stderr, "error: %s: Expected function, got %s instead.\n", loc.chars(), evalTypeToStr(typ.kind));
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return invalidType();
        }
        let fn: &FuncType = typ.data;
        if (fn.retKind == RET_KIND_EVAL) {
            let ret: &Type = fn.retData;
            assert_with_msg(ret.isValid(), "RET_KIND_EVAL is invalid");
            return *ret;
        }
        assert(fn.retKind == RET_KIND_NODE);
        todo_with_msg("createTypeFromCall");
        return invalidType();
    }
    func createTypeFrom(&mut this, value: &ParsedDeclValue) -> Type {
        trace("createTypeFrom");
        let kind: usize = value.kind;
        assert_with_msg(kind != DECL_VALUE_INVALID, "Expected valid ParsedDeclValue");
        mut typ: Type = invalidType();
        if (kind == DECL_VALUE_MODULE) {
            todo_with_msg("Module");
        } else if (kind == DECL_VALUE_STRUCT_DECL) {
            typ = this.createTypeFromStruct(value.data);
        } else if (kind == DECL_VALUE_ENUM_DECL) {
            typ = this.createTypeFromEnum(value.data);
        } else if (kind == DECL_VALUE_UNION_DECL) {
            todo_with_msg("Union");
        } else if (kind == DECL_VALUE_FUNC_DECL) {
            typ = this.createTypeFromFunc(value.data);
        } else if (kind == DECL_VALUE_IDENT) {
            typ = this.createTypeFromIdent(value.data);
        } else if (kind == DECL_VALUE_BUILTIN) {
            typ = this.createTypeFromBuiltin(value.data);
        } else if (kind == DECL_VALUE_NUMBER) {
            typ = this.createTypeFromNumber(value.data);
        } else if (kind == DECL_VALUE_CALL) {
            typ = this.createTypeFromCall(value.data);
        } else {
            todo_with_msg("Other");
        }
        typ.value = value;
        return typ;
    }
    func fillLookup(&mut this, parsedProject: &ParsedModule) -> bool {
        this.collectDeclIdentifiers(parsedProject);
        this.addModuleToLookup(parsedProject);
        this.tryResolveRemaining();
        return !this.hadErrorsInLookupStage;
    }
    func collectDeclIdentifiers(&mut this, parsedModule: &ParsedModule) {
        for (mut i: usize = 0; i < parsedModule.declCount; i = i + 1) {
            let decl: &ParsedGlobalDecl = parsedModule.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL)
                this.collectIdentifier(decl.data);
        }
    }
    func collectIdentifier(&mut this, decl: &ParsedVarDecl) {
        let name: SubStr = decl.name.content;
        if (this.isKnownIdentifier(&name))
            todo_with_msg("Duplicate global ident");
        mut index: usize = 0;
        let result: bool = this.searchForIdentifier(&name, &mut index);
        assert(!result);
        this.insertIdentifierAtIndex(index, name);
    }
    func insertIdentifierAtIndex(&mut this, index: usize, name: SubStr) {
        unsafe {
            if (this.identLookupLen >= this.identLookupCap) {
                let _new: Any = calloc(this.identLookupCap * 2, sizeof SubStr);
                assert_with_msg(_new != null, "Could not resize in TypeChecker.insertIdentifierAtIndex");
                let _old: Any = this.identLookup;
                memcpy(_new, _old, this.identLookupLen * sizeof SubStr);
                free(_old);
                this.identLookupCap = this.identLookupCap * 2;
                this.identLookup = _new;
            }
            for (mut i: usize = this.identLookupLen - 1; i >= index; i = i - 1) {
                *(this.identLookup + (i + 1) * sizeof SubStr) = *(this.identLookup + i * sizeof SubStr);
            }
            *(this.identLookup + index * sizeof SubStr) = name;
            this.identLookupLen = this.identLookupLen + 1;
        }
    }
    func isKnownIdentifier(&mut this, name: &SubStr) -> bool {
        mut _dummy: usize = 0;
        return this.searchForIdentifier(name, &mut _dummy);
    }
    func getIdentifierAtIndex(&mut this, index: i64) -> &SubStr {
        assert_with_msg(index >= 0, "Out of bounds access in TypeChecker.getIdentifierAtIndex");
        let _index: usize = index as usize;
        assert_with_msg(_index < this.identLookupLen, "Out of bounds access in TypeChecker.getIdentifierAtIndex");
        unsafe {
            return (this.identLookup + _index * sizeof SubStr) as &SubStr;
        }
    }
    func searchForIdentifier(&mut this, name: &SubStr, index: &mut usize) -> bool {
        if (this.identLookupLen == 0) return false;
        mut left: i64 = 0;
        mut right: i64 = this.identLookupLen as i64 - 1;
        while (left <= right) {
            let middle: i64 = (left + right) / 2;
            let elem: &SubStr = this.getIdentifierAtIndex(middle);
            let order: u8 = elem.lexOrder(name);
            if (order == ORDER_LESS)
                left = middle + 1;
            else if (order == ORDER_GREATER)
                right = middle - 1;
            else {
                *index = middle as usize;
                return true;
            }
        }
        *index = left as usize;
        return false;
    }
    func addModuleToLookup(&mut this, parsedModule: &ParsedModule) {
        for (mut i: usize = 0; i < parsedModule.declCount; i = i + 1) {
            let decl: &ParsedGlobalDecl = parsedModule.getDeclAtIndex(i);
            if (decl.kind == GLOBAL_VAR_DECL)
                this.addDeclToLookup(decl.data);
            else if (decl.kind == GLOBAL_DIR)
                todo_with_msg("eval global directive");
            else {
                assert_with_msg(false, "Invalid kind for ParsedGlobalDecl");
            }
        }
    }
    func addDeclToLookup(&mut this, parsedDecl: &ParsedVarDecl) -> bool {
        let typ: Type = this.createTypeFrom(&parsedDecl.value);
        if (typ.isUnresolved()) {
            this.addUnresolvedDecl(parsedDecl);
            return false;
        }
        if (typ.isValid()) {
            this.addResolvedDecl(&parsedDecl.name, &typ);
            if (parsedDecl.isMutable && typ.requiresImmutable()) unsafe {
                let stderr: Any = fdopen(2, "a");
                let loc: String = parsedDecl.name.span.toString();
                fprintf(stderr, "error: %s: Variables that store %s type can't be mutable.\n", loc.chars(), evalTypeToStr(typ.kind));
                loc.drop();
                this.hadErrorsInLookupStage = true;
            }
            return true;
        }
        return false;
    }
    func removeUnresolvedAtIndex(&mut this, index: usize) {
        assert_with_msg(index < this.unresolvedLen, "Out of bounds index in removeUnresolvedAtIndex");
        let l: usize = this.unresolvedLen - 1;
        unsafe {
            let last: &ParsedVarDecl = this.getUnresolvedAtIndex(l);
            *(this.unresolvedDecls + index * sizeof &ParsedVarDecl) = last;
            this.unresolvedLen = this.unresolvedLen - 1;

        }
    }
    func isKnownUnresolved(&mut this, decl: &ParsedVarDecl) -> bool {
        for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) {
            let unresolved: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
            if (unresolved == decl) return true;
        }
        return false;
    }
    func addUnresolvedDecl(&mut this, decl: &ParsedVarDecl) {
        debug("Add Unresolved");
        debug(decl.name.span.toString().chars());
        if (this.unresolvedLen >= this.unresolvedCap) unsafe {
            let _new: Any = calloc(this.unresolvedCap * 2, sizeof &ParsedVarDecl);
            assert_with_msg(_new != null, "Could not resize in TypeChecker.addResolvedDecl");
            let _old: Any = this.unresolvedDecls;
            memcpy(_new, _old, this.unresolvedLen * sizeof &ParsedVarDecl);
            free(_old);
            this.unresolvedCap = this.unresolvedCap * 2;
            this.unresolvedDecls = _new;
        }
        if (this.isKnownUnresolved(decl)) return;
        unsafe {
            *(this.unresolvedDecls + this.unresolvedLen * sizeof &ParsedVarDecl) = decl;
        }
        this.unresolvedLen = this.unresolvedLen + 1;
    }
    func getGlobalTypeDeclLoc(&mut this, varName: SubStr) -> Span {
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let decl: &NameTypePair = this.getResolvedAtIndex(i);
            if (decl.name.equals(&varName))
                return decl.value.span;
        }
        assert_with_msg(false, "unreachable: getGlobalTypeDeclLoc() expects a known variable name as input");
        return defaultSpan();
    }
    func addResolvedDecl(&mut this, tkn: &Token, value: &Type) {
        assert(value.isValid());
        // FIXME: This is better placed in addDeclToLookup() before we even evaluate the value
        //        It's easier to lookup the name first
        if (this.isKnownType(tkn.content)) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = tkn.span.toString();
            let name: String = tkn.content.toString();
            let prevLoc: Span = this.getGlobalTypeDeclLoc(tkn.content);
            let prevLocStr: String = prevLoc.toString();
            fprintf(stderr, "error: %s: Redeclaration of variable %s.\nnote: %s: Variable already declared here.\n", loc.chars(), name.chars(), prevLocStr.chars());
            prevLocStr.drop();
            name.drop();
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return;
        }
        debug("Add Resolved");
        debug(tkn.span.toString().chars());
        if (this.resolvedLen >= this.resolvedCap) unsafe {
            let _new: Any = calloc(this.resolvedCap * 2, sizeof NameTypePair);
            assert_with_msg(_new != null, "Could not resize in TypeChecker.addResolvedDecl");
            let _old: Any = this.resolvedDecls;
            memcpy(_new, _old, this.resolvedLen * sizeof NameTypePair);
            free(_old);
            this.resolvedCap = this.resolvedCap * 2;
            this.resolvedDecls = _new;
        }
        let pair: NameTypePair = NameTypePair {
            span: tkn.span,
            name: tkn.content,
            value: *value
        };
        unsafe {
            *(this.resolvedDecls + this.resolvedLen * sizeof NameTypePair) = pair;
        }
        this.resolvedLen = this.resolvedLen + 1;
    }
    func tryResolveRemaining(&mut this) {
        trace("tryResolveRemaining");
        mut currentUnresolved: usize = this.unresolvedLen;
        assert_with_msg(INITIAL_CAPACITY == 64, "Resize newResolved array");
        while (currentUnresolved > 0) {
            debug("Still have types to resolve...");
            mut newResolved: [usize; 64] = blank;
            mut newLen: usize = 0;
            for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) {
                let decl: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
                let success: bool = this.addDeclToLookup(decl);
                if (success) {
                    newResolved[newLen] = i;
                    newLen = newLen + 1;
                }
            }
            for (mut i: usize = newLen - 1; i >= 0; i = i - 1) {
                this.removeUnresolvedAtIndex(newResolved[i]);
            }
            if (currentUnresolved == this.unresolvedLen) {
                // Could not resolve any new type in this iteration
                // which means we would loop infinitely
                break;
            }
            currentUnresolved = this.unresolvedLen;
        }
        for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) unsafe {
            let unresolved: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
            let loc: String = unresolved.name.span.toString();
            let name: String = unresolved.name.content.toString();
            let stderr: Any = fdopen(2, "a");
            fprintf(stderr, "error: %s: Could not resolve type of variable %s.\n", loc.chars(), name.chars());
            this.hadErrorsInLookupStage = true;
        }
    }
    func isKnownType(&mut this, name: SubStr) -> bool {
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let resolved: &NameTypePair = this.getResolvedAtIndex(i);
            if (resolved.name.equals(&name)) return true;
        }
        return false;
    }
}

func newTypeChecker() -> TypeChecker {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof &ParsedVarDecl);
        assert_with_msg(mem != null, "Could not allocate enough memory in newTypeChecker()");
        let unresolvedDecls: &mut &ParsedVarDecl = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof NameTypePair);
        assert_with_msg(mem != null, "Could not allocate enough memory in newTypeChecker()");
        let resolvedDecls: &mut NameTypePair = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof SubStr);
        assert_with_msg(mem != null, "Could not allocate enough memory in newTypeChecker()");
        let identLookup: &mut SubStr = &mut *mem;
        return TypeChecker {
            hadErrorsInLookupStage: false,
            identLookup: identLookup,
            identLookupLen: 0,
            identLookupCap: INITIAL_CAPACITY,
            unresolvedDecls: unresolvedDecls,
            unresolvedLen: 0,
            unresolvedCap: INITIAL_CAPACITY,
            resolvedDecls: resolvedDecls,
            resolvedLen: 0,
            resolvedCap: INITIAL_CAPACITY,

        };
    }
}
