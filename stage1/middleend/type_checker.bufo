import "string.bufo";
import "frontend/nodes.bufo";
import "print.tmp.bufo";
import "util/span.bufo";
import "util/vector.bufo";

func typeErrorRedeclaration(what: &char, errorLoc: Span, struktName: SubStr, existLoc: Span) -> String {
    mut _s1: String = newString();
    mut _s2: String = newString();
    if (errorLoc.comesBefore(&existLoc)) {
        _s1 = existLoc.toString();
        _s2 = errorLoc.toString();
    } else {
        _s1 = errorLoc.toString();
        _s2 = existLoc.toString();
    }
    mut s: String = newString();
    s.pushStr("error: ");
    s.pushString(&_s1);
    _s1.drop();
    s.pushStr(": Redeclaration error. ");
    s.pushStr(what);
    s.pushStr(" `");
    s.pushSubStr(&struktName);
    s.pushStr("` already declared earlier, at bytes ");
    s.pushString(&_s2);
    s.pushStr(".");
    _s2.drop();
    return s;
}

struct Lookup {
    structs: Vec;
    enums: Vec;
    quirks: Vec;
    typeDefs: Vec;
    errors: Vec;

    func checkExisting(&mut this, name: SubStr, loc: &Span, report: bool) -> bool {
        mut exists: bool = false;
        for (mut i: usize = 0; i < this.structs.len(); i = i + 1) {
            let existing: &StructVariant = this.structs.getStructVariant(i);
            if (existing.getName().equals(&name)) {
                if (report) this.errors.pushString(&typeErrorRedeclaration(
                    "Struct", *loc, name, existing.getSpan(),
                ));
                exists = true;
            }
        }
        for (mut i: usize = 0; i < this.enums.len(); i = i + 1) {
            let existing: &Enum = this.enums.getEnum(i);
            if (existing.getName().equals(&name)) {
                if (report) this.errors.pushString(&typeErrorRedeclaration(
                    "Enum", *loc, name, existing.getSpan(),
                ));
                exists = true;
            }
        }
        for (mut i: usize = 0; i < this.quirks.len(); i = i + 1) {
            let existing: &Quirk = this.quirks.getQuirk(i);
            if (existing.getName().equals(&name)) {
                if (report) this.errors.pushString(&typeErrorRedeclaration(
                    "Quirk", *loc, name, existing.getSpan(),
                ));
                exists = true;
            }
        }
        for (mut i: usize = 0; i < this.typeDefs.len(); i = i + 1) {
            let existing: &TypeDef = this.typeDefs.getTypeDef(i);
            if (existing.getName().equals(&name)) {
                if (report) this.errors.pushString(&typeErrorRedeclaration(
                    "TypeDef", *loc, name, existing.getSpan(),
                ));
                exists = true;
            }
        }
        return exists;
    }

    func addStruct(&mut this, strukt: &StructVariant) -> bool {
        let valid: bool = !this.checkExisting(strukt.getName(), &strukt.getSpan(), true);
        if (valid) this.structs.pushStructVariant(strukt);
        return valid;
    }
    func addEnum(&mut this, eenum: &Enum) -> bool {
        let valid: bool = !this.checkExisting(eenum.getName(), &eenum.getSpan(), true);
        if (valid) this.enums.pushEnum(eenum);
        return valid;
    }
    func addQuirk(&mut this, quyrk: &Quirk) -> bool {
        let valid: bool = !this.checkExisting(quyrk.getName(), &quyrk.getSpan(), true);
        if (valid) this.quirks.pushQuirk(quyrk);
        return valid;
    }
    func addTypeDef(&mut this, typeDef: &TypeDef) -> bool {
        let valid: bool = !this.checkExisting(typeDef.getName(), &typeDef.getSpan(), true);
        if (valid) this.typeDefs.pushTypeDef(typeDef);
        return valid;
    }

    func verifyCStruct(&mut this, cStruct: &CStruct) -> bool {
        let typ: &StructType = cStruct.getType().asStruct();
        assert(this.checkExisting(typ.getName(), &typ.getSpan(), false));
        let generics: &Vec = typ.getGenerics();
        let fields: &Vec = cStruct.getFields();
        for (mut i: usize = 0; i < fields.len(); i = i + 1) {
            todo_with_msg("Lookup.verifyCStruct");
        }
        return false;
    }
    func verifyTupleStruct(&mut this, tupleStruct: &TupleStruct) -> bool {
        let typ: &StructType = tupleStruct.getType().asStruct();
        assert(this.checkExisting(typ.getName(), &typ.getSpan(), false));
        todo_with_msg("Lookup.verifyTupleStruct");
        return false;
    }
    func verifyEmptyStruct(&mut this, emptyStruct: &EmptyStruct) -> bool {
        let typ: &StructType = emptyStruct.getType().asStruct();
        assert(this.checkExisting(typ.getName(), &typ.getSpan(), false));
        todo_with_msg("Lookup.verifyEmptyStruct");
        return false;
    }

    func verify(&mut this) -> bool {
        mut valid: bool = true;
        for (mut i: usize = 0; i < this.structs.len(); i = i + 1) {
            let variant: &StructVariant = this.structs.getStructVariant(i);
            if (variant.kind == STRUCT_VARIANT_C)
                valid = valid && this.verifyCStruct(variant.data);
            else if (variant.kind == STRUCT_VARIANT_TUPLE)
                valid = valid && this.verifyTupleStruct(variant.data);
            else if (variant.kind == STRUCT_VARIANT_EMPTY)
                valid = valid && this.verifyEmptyStruct(variant.data);
        }
        for (mut i: usize = 0; i < this.enums.len(); i = i + 1) {
            todo_with_msg("Lookup.verify<Enum>");
        }
        for (mut i: usize = 0; i < this.quirks.len(); i = i + 1) {
            todo_with_msg("Lookup.verify<Quirk>");
        }
        for (mut i: usize = 0; i < this.typeDefs.len(); i = i + 1) {
            todo_with_msg("Lookup.verify<TypeDef>");
        }
        return valid;
    }

    func getErrors(&this) -> &Vec {
        return &this.errors;
    }
}

func newLookup() -> Lookup {
    return Lookup {
        structs: emptyVec(VECTOR_KIND_STRUCT_VARIANT, sizeof StructVariant),
        enums: emptyVec(VECTOR_KIND_ENUM, sizeof Enum),
        quirks: emptyVec(VECTOR_KIND_QUIRK, sizeof Quirk),
        typeDefs: emptyVec(VECTOR_KIND_TYPE_DEF, sizeof TypeDef),
        errors: emptyVec(VECTOR_KIND_STRING, sizeof String),
    };
}

struct Checker {
    module: &mut Module;
    lookup: Lookup;
    errors: Vec;

    func addErrors(&mut this) {
        let errors: &Vec = this.lookup.getErrors();
        this.errors.extend(errors);
        this.lookup.errors.reset();
    }

    func runChecks(&mut this) -> bool {
        this.fillLookup();
        this.verifyLookup();
        if (this.errors.len() > 0) unsafe {
            let stderr: Any = fdopen(2, "w");
            for (mut i: usize = 0; i < this.errors.len(); i = i + 1) {
                fprintf(stderr, "%s\n", this.errors.getString(i).buffer);
            }
            assert(fclose(stderr) == 0);
        }
        return this.errors.len() == 0;
    }

    func fillLookup(&mut this) {
        let m: &mut Module = this.module;
        for (mut i: usize = 0; i < m.structs.len(); i = i + 1) {
            this.addStructToLookup(m.structs.getStructVariant(i));
        }
        for (mut i: usize = 0; i < m.enums.len(); i = i + 1) {
            this.addEnumToLookup(m.enums.getEnum(i));
        }
        for (mut i: usize = 0; i < m.quirks.len(); i = i + 1) {
            this.addQuirkToLookup(m.quirks.getQuirk(i));
        }
        for (mut i: usize = 0; i < m.types.len(); i = i + 1) {
            this.addTypeDefToLookup(m.types.getTypeDef(i));
        }
    }
    func verifyLookup(&mut this) {
        // Now that we have a lookup of all user-created types we can
        // verify quirk-boundaries and such.
        // This function does not care about quirk-implementation, it
        // only does high-level checks of the types.
        // Other functions are then responsible for verifying the
        // implementations.
        if (!this.lookup.verify()) {
            this.addErrors();
        }
    }

    func addStructToLookup(&mut this, strukt: &StructVariant) {
        if (!this.lookup.addStruct(strukt)) {
            this.addErrors();
        }
    }
    func addEnumToLookup(&mut this, eenum: &Enum) {
        if (!this.lookup.addEnum(eenum)) {
            this.addErrors();
        }
    }
    func addQuirkToLookup(&mut this, quyrk: &Quirk) {
        if (!this.lookup.addQuirk(quyrk)) {
            this.addErrors();
        }
    }
    func addTypeDefToLookup(&mut this, typeDef: &TypeDef) {
        if (!this.lookup.addTypeDef(typeDef)) {
            this.addErrors();
        }
    }
}
func newChecker(mod: &mut Module) -> Checker {
    return Checker {
        module: mod,
        lookup: newLookup(),
        errors: emptyVec(VECTOR_KIND_STRING, sizeof String),
    };
}
