import "string.bufo";
import "frontend/nodes.bufo";
import "middleend/nodes.bufo";
import "util/span.bufo";
import "middleend/builtins.bufo";

func verifyBuiltinArgType(builtin: &ParsedDeclValue, size: &EvaluatedValue, argIndex: usize, expected: usize, builtinName: &char) -> bool {
    if (size.kind != expected) unsafe {
        let stderr: Any = fdopen(2, "a");
        fprintf(stderr, "error: %s: Builtin `%s` expects %s as argument %llu, got %s.\n", builtin.span.toString().chars(), builtinName, evalTypeToStr(expected), argIndex, evalTypeToStr(size.kind));
        return false;
    }
    return true;
}

func verifyBuiltinArgCount(builtin: &ParsedDeclValue, call: &ParsedDeclValueCall, expectedArgCount: usize, builtinName: &char) -> bool {
    if (call.argCount != expectedArgCount) unsafe {
        let stderr: Any = fdopen(2, "a");
        fprintf(stderr, "error: %s: Builtin `%s` expects exactly %llu argument(s).\n", builtin.span.toString().chars(), builtinName, expectedArgCount);
        return false;
    }
    return true;
}

func newBuiltinInteger(size: &EvaluatedValue) -> StructValue {
    debug("Creating new integer type");
    mut int: StructValue = newStructValue();
    int.addField(defaultSpan(), newSubStrOfStrLit("bitsize"), size);
    return int;
}
func newBuiltinFloat(size: &EvaluatedValue) -> StructValue {
    debug("Creating new float type");
    mut float: StructValue = newStructValue();
    float.addField(defaultSpan(), newSubStrOfStrLit("bitsize"), size);
    return float;
}

// in tryEvaluateFunc():
// - UNSET means we haven't set the return type yet :) You can expect retData to be null
// - EVAL means that we were able to compute the return type right then and there and
//   store an EvaluatedValue
// - NODE means we are missing information (for example generic parameter) and store
//   the Node for later Interpretation
comptime RET_KIND_UNSET: usize = 0;
comptime RET_KIND_EVAL: usize = 1;
comptime RET_KIND_NODE: usize = 2;
struct FuncValue {
    node: &ParsedFuncDecl;
    params: &mut NameValuePair;
    paramLen: usize;
    paramCap: usize;
    retKind: usize;
    retData: Any;
    func hasParameter(&this, name: &SubStr) -> bool {
        for (mut i: usize = 0; i < this.paramLen; i = i + 1) {
            let param: &NameValuePair = this.getParamAtIndex(i);
            if (param.name.equals(name))
                return true;
        }
        return false;
    }
    func addParameter(&mut this, span: Span, name: SubStr, typ: &EvaluatedValue) {
        if (this.paramLen >= this.paramCap) {
            todo_with_msg("Resize params");
        }
        if ((&*this).hasParameter(&name)) {
            todo_with_msg("Report error: Duplicate param");
        }
        let pair: NameValuePair = NameValuePair {
            span: span,
            name: name,
            value: *typ
        };
        unsafe {
            *(this.params + this.paramLen * sizeof NameValuePair) = pair;
        }
        this.paramLen = this.paramLen + 1;
    }
    func getParamAtIndex(&this, index: usize) -> &NameValuePair {
        assert_with_msg(index < this.paramLen, "Out of bounds ac cess in FuncValue.getParamAtIndex()");
        unsafe {
            let _param: &mut NameValuePair = this.params + index * sizeof NameValuePair;
            return _param as &NameValuePair;
        }
    }
    func getParamByName(&this, name: &SubStr) -> &NameValuePair {
        for (mut i: usize = 0; i < this.paramLen; i = i + 1) {
            let param: &NameValuePair = this.getParamAtIndex(i);
            if (param.name.equals(name))
                return param;
        }
        assert_with_msg(this.hasParameter(name), "unreachable");
        assert_with_msg(false, "unreachable");
        return &defaultNameValuePair();
    }
    func setReturnAST(&mut this, node: &ParsedTypeExpr) {
        this.retKind = RET_KIND_NODE;
        this.retData = node;
    }
    func setReturnType(&mut this, val: &EvaluatedValue) {
        unsafe {
            let mem: Any = calloc(sizeof EvaluatedValue, 1);
            assert_with_msg(mem != null, "Could not allocate memory in setReturnValue");
            memcpy(mem, val, sizeof EvaluatedValue);
            this.retKind = RET_KIND_EVAL;
            this.retData = mem;
        }
    }
}

func newFuncValue(node: &ParsedFuncDecl) -> FuncValue {
    unsafe {
        let mem: Any = calloc(sizeof NameValuePair, INITIAL_CAPACITY);
        assert_with_msg(mem != null, "Could not allocate memory in newFuncValue()");
        let params: &mut NameValuePair = &mut *mem;
        return FuncValue {
            node: node,
            params: params,
            paramLen: 0,
            paramCap: INITIAL_CAPACITY,
            retKind: RET_KIND_UNSET,
            retData: null
        };
    }
}

struct StructValue {
    fields: &mut NameValuePair;
    fieldLen: usize;
    fieldCap: usize;
    assets: &mut NameValuePair;
    assetLen: usize;
    assetCap: usize;
    func addField(&mut this, span: Span, name: SubStr, field: &EvaluatedValue) {
        if (this.fieldLen >= this.fieldCap) {
            todo_with_msg("Resize StructValue");
        }
        let pair: NameValuePair = NameValuePair {
            span: span,
            name: name,
            value: *field
        };
        unsafe {
            *(this.fields + this.fieldLen * sizeof NameValuePair) = pair;
        }
        this.fieldLen = this.fieldLen + 1;
    }
    func addAsset(&mut this, span: Span, name: SubStr, asset: &EvaluatedValue) {
        if (this.assetLen >= this.assetCap) {
            todo_with_msg("Resize StructValue");
        }
        let pair: NameValuePair = NameValuePair {
            span: span,
            name: name,
            value: *asset
        };
        unsafe {
            *(this.assets + this.assetLen * sizeof NameValuePair) = pair;
        }
        this.assetLen = this.assetLen + 1;
    }
}

func newStructValue() -> StructValue {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof NameValuePair);
        assert_with_msg(mem != null, "Could not allocate memory in newStructValue()");
        let fields: &mut NameValuePair = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof NameValuePair);
        assert_with_msg(mem != null, "Could not allocate memory in newStructValue()");
        let assets: &mut NameValuePair = &mut *mem;
        return StructValue {
            fields: fields,
            fieldLen: 0,
            fieldCap: INITIAL_CAPACITY,
            assets: assets,
            assetLen: 0,
            assetCap: INITIAL_CAPACITY
        };
    }
}

struct EnumValue {
    variantType: EvaluatedValue;
    variants: &mut NameValuePair;
    variantsLen: usize;
    variantsCap: usize;
    func setVariantType(&mut this, typ: &EvaluatedValue) {
        this.variantType = *typ;
    }

    func addVariant(&mut this, span: Span, name: SubStr, typ: &EvaluatedValue) {
        if (this.variantsLen >= this.variantsCap) {
            todo_with_msg("Resize variants in EnumValue");
        }
        let pair: NameValuePair = NameValuePair {
            span: span,
            name: name,
            value: *typ
        };
        unsafe {
            *(this.variants + this.variantsLen * sizeof NameValuePair) = pair;
        }
        this.variantsLen = this.variantsLen + 1;
    }
}

func newEnumValue() -> EnumValue {
    unsafe {
        let mem: Any = calloc(INITIAL_CAPACITY, sizeof NameValuePair);
        assert_with_msg(mem != null, "Could not allocate memory in newEnumValue()");
        let variants: &mut NameValuePair = &mut *mem;
        return EnumValue {
            variantType: invalidValue(),
            variants: variants,
            variantsLen: 0,
            variantsCap: INITIAL_CAPACITY,
        };
    }
}

// TODO: new EVAL_UNKNOWN and unknownValue() to differentiate
//       between "we dont know the type" and "there was an error"
comptime EVAL_INVALID: usize = 0;
comptime EVAL_BUILTIN: usize = 1;
comptime EVAL_STRUCT: usize = 2;
comptime EVAL_ENUM: usize = 3;
comptime EVAL_FUNC: usize = 4;
comptime EVAL_INTEGER: usize = 5;
comptime EVAL_FLOAT: usize = 6;
func evalTypeToStr(kind: usize) -> &char {
    if (kind == EVAL_INVALID) return "an invalid value";
    else if (kind == EVAL_BUILTIN) return "a builtin";
    else if (kind == EVAL_STRUCT) return "a struct";
    else if (kind == EVAL_ENUM) return "an enum";
    else if (kind == EVAL_FUNC) return "a function";
    else if (kind == EVAL_INTEGER) return "an integer";
    else if (kind == EVAL_FLOAT) return "a float";
    assert_with_msg(false, "unreachable code in evalTypeToStr");
    return "";
}
// FIXME: This is later the result of any checkXYZ() call
//        We should think of a better name for this.
struct EvaluatedValue {
    kind: usize;
    span: Span;
    data: Any;

    func requiresImmutable(&this) -> bool {
        // Values that don't allow reassignment
        // e.g. mut Point = struct {}; is disallowed
        return this.kind == EVAL_STRUCT
            || this.kind == EVAL_ENUM
            || this.kind == EVAL_BUILTIN;
    }

    func isValid(&this) -> bool {
        return this.kind != EVAL_INVALID;
    }

    func isInteger(&this) -> bool {
        return this.kind == EVAL_INTEGER;
    }

    func isFunc(&this) -> bool {
        return this.kind == EVAL_FUNC;
    }

    func isType(&this) -> bool {
        if (this.kind == EVAL_BUILTIN) unsafe {
            return (this.data as &BuiltinValue).isType();
        }
        return this.kind == EVAL_STRUCT
            || this.kind == EVAL_ENUM;
    }

    func isAnytype(&this) -> bool {
        if (this.kind != EVAL_BUILTIN) return false;
        unsafe {
            return (this.data as &BuiltinValue).isAnytype();
        }
    }
}

func invalidValue() -> EvaluatedValue {
    unsafe {
        return blank;
    }
}

func newEvaluatedValue(span: Span, kind: usize, size: usize, data: Any) -> EvaluatedValue {
    unsafe {
        let mem: Any = calloc(size, 1);
        assert_with_msg(mem != null, "Could not allocate memory for newEvaluatedValue()");
        memcpy(mem, data, size);
        return EvaluatedValue {
            kind: kind,
            span: span,
            data: mem
        };
    }
}

struct NameValuePair {
    span: Span;
    name: SubStr;
    value: EvaluatedValue;
}

func defaultNameValuePair() -> NameValuePair {
    return NameValuePair {
        span: defaultSpan(),
        name: defaultSubStr(),
        value: invalidValue(),
    };
}


struct TypeChecker {
    hadErrorsInLookupStage: bool;
    unresolvedDecls: &mut &ParsedVarDecl;
    unresolvedLen: usize;
    unresolvedCap: usize;
    resolvedDecls: &mut NameValuePair;
    resolvedLen: usize;
    resolvedCap: usize;
    func checkProject(&mut this, parsedProject: &ParsedModule) -> CheckedModule {
        if (!this.fillLookup(parsedProject)) unsafe {
            // Errors are already reported while filling the lookup
            exit(1);
        }
        return this.checkModule(parsedProject);
    }

    func checkModule(&mut this, parsedModule: &ParsedModule) -> CheckedModule {
        todo_with_msg("checkModule");
        return blank;
    }

    func tryEvaluateStruct(&mut this, strukt: &ParsedStructDecl) -> EvaluatedValue {
        trace("tryEvaluateStruct");
        mut structVal: StructValue = newStructValue();
        for (mut i: usize = 0; i < strukt.assetCount; i = i + 1) {
            let asset: &ParsedStructAsset = strukt.getAssetAtIndex(i);
            let typ: EvaluatedValue = this.tryEvaluate(&asset.asset.value);
            if (!typ.isValid())
                return invalidValue();
            let name: Token = asset.asset.name;
            structVal.addAsset(name.span, name.content, &typ);
        }
        for (mut i: usize = 0; i < strukt.fieldCount; i = i + 1) {
            let field: &ParsedStructField = strukt.getFieldAtIndex(i);
            debug(field.name.toString().chars());
            let typ: EvaluatedValue = this.tryEvaluateTypeExpr(&field.typ);
            if (!typ.isValid())
                return invalidValue();
            structVal.addField(field.span, field.name, &typ);
        }

        return newEvaluatedValue(strukt.span, EVAL_STRUCT, sizeof StructValue, &structVal);
    }
    func tryEvaluateEnum(&mut this, eenum: &ParsedEnumDecl) -> EvaluatedValue {
        trace("tryEvaluateEnum");
        mut enumVal: EnumValue = newEnumValue();
        if (eenum.hasVariantType) {
            let typ: EvaluatedValue = this.tryEvaluateTypeExpr(eenum.variantType);
            if (!typ.isValid())
                return invalidValue();
            enumVal.setVariantType(&typ);
        } else {
            // REVIEW: We might get into reference problems here
            // REVIEW: Save space for enums by allocating log2(variantCount) bits instead of always i32
            let _inner: ParsedDeclValueIdent = ParsedDeclValueIdent {
                name: newSubStrOfStrLit("i32")
            };
            let i32_type: EvaluatedValue = this.tryEvaluateIdent(&_inner);
            if (!i32_type.isValid())
                return invalidValue();
            enumVal.setVariantType(&i32_type);
        }
        for (mut i: usize = 0; i < eenum.variantsLen; i = i + 1) unsafe {
            let variant: &ParsedEnumVariant = eenum.getVariantAtIndex(i);
            if (enumVal.variantType.isAnytype()) {
                mut val: EvaluatedValue = this.tryEvaluate(&variant.value);
                if (!val.isValid())
                    return invalidValue();
                if (!val.isType()) unsafe {
                    let stderr: Any = fdopen(2, "a");
                    let evalType: &char = evalTypeToStr(val.kind);
                    let loc: String = variant.span.toString();
                    let defLoc: String = val.span.toString();
                    fprintf(stderr, "error: %s: Generic enum expected a type for every variant, found %s.\nnote: %s: The given expression evaluates to %s.\n", loc.chars(), evalType, defLoc.chars(), evalType);
                    defLoc.drop();
                    loc.drop();
                    this.hadErrorsInLookupStage = true;
                    val = invalidValue();
                }
                enumVal.addVariant(variant.span, variant.name, &val);
            } else {
                enumVal.addVariant(variant.span, variant.name, &enumVal.variantType);
            }
        }
        return newEvaluatedValue(eenum.span, EVAL_ENUM, sizeof EnumValue, &enumVal);
    }
    func tryEvaluateFunc(&mut this, funcExpr: &ParsedFuncDecl) -> EvaluatedValue {
        trace("tryEvaluateFunc");
        mut funcVal: FuncValue = newFuncValue(funcExpr);
        for (mut i: usize = 0; i < funcExpr.paramCount; i = i + 1) {
            let param: &ParsedParam = funcExpr.getParamAtIndex(i);
            if (funcVal.hasParameter(&param.name)) unsafe {
                let duplicate: &NameValuePair = funcVal.getParamByName(&param.name);
                let stderr: Any = fdopen(2, "a");
                let name: String = param.name.toString();
                let loc: String = param.span.toString();
                let prevLocStr: String = duplicate.span.toString();
                fprintf(stderr, "error: %s: Redeclaration of variable %s.\nnote: %s: Variable already declared here.\n", loc.chars(), name.chars(), prevLocStr.chars());
                prevLocStr.drop();
                loc.drop();
                name.drop();
                this.hadErrorsInLookupStage = true;
            }
            let typ: EvaluatedValue = this.tryEvaluateTypeExpr(&param.typ);
            if (!typ.isValid() && !typ.isType())
                return invalidValue();
            funcVal.addParameter(param.span, param.name, &typ);
        }
        // Step 1: Does any parameter occur in return type?
        // > If yes, we can't compute type now, must do later when calling the function, on the fly
        // - Example: func (t: type) -> t {};
        //   - We only know the type of `t` at the call site
        // Step 2: Is return type valid?
        // > If yes, set return type of FuncValue
        // - Example: func (i: i32) -> i32 {};
        // - Example: func (t: type) -> i32 {};
        //   - Both examples are trivial, we just know the type. Those are normal functions.
        // Step 3: Is return type anytype?
        // > If yes, we can't compute type now, must do later when calling the function, on the fly
        // - Example: func (t: type) -> type {};
        //   - Return type may have field `t`
        // - Example: func (v: i32) -> type {};
        //   - Return type may be control-flow-dependent on `if v`
        // - Example: func () -> type {};
        //   - Return type may be dependent on other values inside the function
        mut foundMatch: bool = false;
        assert(funcExpr.paramCount == funcVal.paramLen);
        for (mut i: usize = 0; i < funcExpr.paramCount; i = i + 1) {
            let param: &ParsedParam = funcExpr.getParamAtIndex(i);
            let paramType: &NameValuePair = funcVal.getParamAtIndex(i);
            if (this.findIdentInTypeExpr(param.name, &funcExpr.retType)) {
                foundMatch = true;
                break;
            }
        }
        if (foundMatch) {
            // Case 1 - Return type depends on parameter
            funcVal.setReturnAST(&funcExpr.retType);
        } else {
            let value: EvaluatedValue = this.tryEvaluateTypeExpr(&funcExpr.retType);
            if (value.isValid()) {
                if (value.isAnytype()) {
                    // Case 3 - Return type is generic
                    funcVal.setReturnAST(&funcExpr.retType);
                } else {
                    // Case 2 - Return type is known
                    funcVal.setReturnType(&value);
                }
            } else {
                // Return type could not be evaluated
                // May be due to unknown type identifiers
                return invalidValue();
            }
        }
        return newEvaluatedValue(funcExpr.span, EVAL_FUNC, sizeof FuncValue, &funcVal);
    }
    // FIXME: As we will need better pattern matching soon, we should move this to a separate file
    func findIdentInTypeExpr(&mut this, name: SubStr, node: &ParsedTypeExpr) -> bool {
        return this.findIdentInDeclValue(name, &node.expr);
    }
    func findIdentInDeclValue(&mut this, name: SubStr, node: &ParsedDeclValue) -> bool {
        assert_with_msg(node.kind != DECL_VALUE_INVALID, "Expected valid DeclValue");
        if (node.kind == DECL_VALUE_CALL) {
            let call: &ParsedDeclValueCall = node.asCall();
            if (this.findIdentInDeclValue(name, &call.fn))
                return true;
            for (mut i: usize = 0; i < call.argCount; i = i + 1)
                if (this.findIdentInDeclValue(name, &call.args[i]))
                    return true;
        } else if (node.kind == DECL_VALUE_IDENT) {
            let ident: &ParsedDeclValueIdent = node.asIdent();
            return ident.name.equals(&name);
        } else unsafe {
            printf("[WARN] Unsupported kind in findIdentInDeclValue: %llu\n", node.kind);
        }
        return false;
    }
    func tryEvaluateTypeExpr(&mut this, typeExpr: &ParsedTypeExpr) -> EvaluatedValue {
        let value: EvaluatedValue = this.tryEvaluate(&typeExpr.expr);
        if (!value.isValid())
            return invalidValue();
        if (!value.isType()) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = typeExpr.expr.span.toString();
            let defLoc: String = value.span.toString();
            fprintf(stderr, "error: %s: Expected a type value, found %s.\nnote: %s: Value evaluated here.\n", loc.chars(), evalTypeToStr(value.kind), defLoc.chars());
            defLoc.drop();
            loc.drop();
            this.hadErrorsInLookupStage = true;
        }
        return value;
    }
    func getResolvedAtIndex(&mut this, index: usize) -> &NameValuePair {
        assert_with_msg(index < this.resolvedLen, "Out of bounds for getResolvedAtIndex");
        unsafe {
            return (this.resolvedDecls + index * sizeof NameValuePair) as &NameValuePair;
        }
    }
    func getUnresolvedAtIndex(&mut this, index: usize) -> &ParsedVarDecl {
        assert_with_msg(index < this.unresolvedLen, "Out of bounds for getUnresolvedAtIndex");
        unsafe {
            return *(this.unresolvedDecls + index * sizeof &ParsedVarDecl) as &ParsedVarDecl;
        }
    }
    func tryEvaluateIdent(&mut this, ident: &ParsedDeclValueIdent) -> EvaluatedValue {
        trace("tryEvaluateIdent");
        let name: SubStr = ident.name;
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let pair: &NameValuePair = this.getResolvedAtIndex(i);
            if (name.equals(&pair.name)) {
                debug("Match!");
                let s: String = name.toString();
                debug(s.chars());
                s.drop();
                return pair.value;
            }
        }
        return invalidValue();
    }
    func tryEvaluateNumber(&mut this, number: &ParsedDeclValueNumber) -> EvaluatedValue {
        trace("tryEvaluateNumber");
        let val: String = number.number.toString();
        assert_with_msg(val.isNumber(), "Could not parse literal into a number");
        let value: i64 = val.toI64();
        val.drop();
        unsafe {
            return newEvaluatedValue(number.span, EVAL_INTEGER, sizeof i64, &value);
        }
    }
    func tryEvaluateBuiltin(&mut this, builtin: &ParsedDeclValue) -> EvaluatedValue {
        trace("tryEvaluateBuiltin");
        assert_with_msg(builtin.kind == DECL_VALUE_CALL, "tryEvaluateBuiltin expected DECL_VALUE_CALL");
        let call: &ParsedDeclValueCall = builtin.data;
        let fn: &ParsedDeclValue = &call.fn;
        assert_with_msg(fn.kind == DECL_VALUE_IDENT, "Builtins are expected to be simple ident calls like @builtin()");
        let ident: &ParsedDeclValueIdent = fn.data;
        let name: SubStr = ident.name;
        if (name.equals(&BUILTIN_INTEGER)) {
            if (!verifyBuiltinArgCount(builtin, call, 1, "integer")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            let arg: &ParsedDeclValue = &call.args[0];
            let size: EvaluatedValue = this.tryEvaluate(arg);
            if (!size.isValid()) return invalidValue();
            if (!verifyBuiltinArgType(builtin, &size, 0, EVAL_INTEGER, "integer")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            let int: StructValue = newBuiltinInteger(&size);
            let btn: BuiltinValue = newBuiltinValue(builtin.span, BUILTIN_KIND_STRUCT, sizeof StructValue, &int);
            return newEvaluatedValue(builtin.span, EVAL_BUILTIN, sizeof BuiltinValue, &btn);
        } else if (name.equals(&BUILTIN_FLOAT)) {
            if (!verifyBuiltinArgCount(builtin, call, 1, "float")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            let arg: &ParsedDeclValue = &call.args[0];
            let size: EvaluatedValue = this.tryEvaluate(arg);
            if (!size.isValid()) return invalidValue();
            if (!verifyBuiltinArgType(builtin, &size, 0, EVAL_INTEGER, "float")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            let float: StructValue = newBuiltinFloat(&size);
            let btn: BuiltinValue = newBuiltinValue(builtin.span, BUILTIN_KIND_STRUCT, sizeof StructValue, &float);
            return newEvaluatedValue(builtin.span, EVAL_BUILTIN, sizeof BuiltinValue, &btn);
        } else if (name.equals(&BUILTIN_ANYTYPE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "anytype")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            // TODO: Create dedicated newBuiltinAnytype()
            mut anytype: BuiltinValue = invalidBuiltin();
            anytype.kind = BUILTIN_KIND_ANYTYPE;
            anytype.span = builtin.span;
            return newEvaluatedValue(builtin.span, EVAL_BUILTIN, sizeof BuiltinValue, &anytype);
        } else if (name.equals(&BUILTIN_ANYVALUE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "anyvalue")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            // TODO: Create dedicated newBuiltinAnyvalue()
            mut anyvalue: BuiltinValue = invalidBuiltin();
            anyvalue.kind = BUILTIN_KIND_ANYVALUE;
            anyvalue.span = builtin.span;
            return newEvaluatedValue(builtin.span, EVAL_BUILTIN, sizeof BuiltinValue, &anyvalue);
        } else if (name.equals(&BUILTIN_NONE)) {
            if (!verifyBuiltinArgCount(builtin, call, 0, "none")) {
                this.hadErrorsInLookupStage = true;
                return invalidValue();
            }
            // TODO: Create dedicated newBuiltinNone()
            mut none: BuiltinValue = invalidBuiltin();
            none.kind = BUILTIN_KIND_NONE;
            none.span = builtin.span;
            return newEvaluatedValue(builtin.span, EVAL_BUILTIN, sizeof BuiltinValue, &none);
        } else {
            debug(name.toString().chars());
            todo_with_msg("tryEvaluateBuiltin");
        }
        return invalidValue();
    }
    func tryEvaluateCall(&mut this, call: &ParsedDeclValueCall) -> EvaluatedValue {
        trace("tryEvaluateCall");
        let typ: EvaluatedValue = this.tryEvaluate(&call.fn);
        if (!typ.isValid())
            return invalidValue();
        if (!typ.isFunc()) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = call.fn.span.toString();
            fprintf(stderr, "error: %s: Expected function, got %s instead.\n", loc.chars(), evalTypeToStr(typ.kind));
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return invalidValue();
        }
        let fn: &FuncValue = typ.data;
        if (fn.retKind == RET_KIND_EVAL) {
            let ret: &EvaluatedValue = fn.retData;
            assert_with_msg(ret.isValid(), "RET_KIND_EVAL is invalid");
            return *ret;
        }
        assert(fn.retKind == RET_KIND_NODE);
        todo_with_msg("tryEvaluateCall");
        return invalidValue();
    }
    func tryEvaluate(&mut this, value: &ParsedDeclValue) -> EvaluatedValue {
        trace("tryEvaluate");
        let kind: usize = value.kind;
        assert_with_msg(kind != DECL_VALUE_INVALID, "Expected valid ParsedDeclValue");
        if (kind == DECL_VALUE_MODULE) {
            todo_with_msg("Module");
        } else if (kind == DECL_VALUE_STRUCT_DECL) {
            return this.tryEvaluateStruct(value.data);
        } else if (kind == DECL_VALUE_ENUM_DECL) {
            return this.tryEvaluateEnum(value.data);
        } else if (kind == DECL_VALUE_UNION_DECL) {
            todo_with_msg("Union");
        } else if (kind == DECL_VALUE_FUNC_DECL) {
            return this.tryEvaluateFunc(value.data);
        } else if (kind == DECL_VALUE_IDENT) {
            return this.tryEvaluateIdent(value.data);
        } else if (kind == DECL_VALUE_BUILTIN) {
            return this.tryEvaluateBuiltin(value.data);
        } else if (kind == DECL_VALUE_NUMBER) {
            return this.tryEvaluateNumber(value.data);
        } else if (kind == DECL_VALUE_CALL) {
            return this.tryEvaluateCall(value.data);
        } else {
            todo_with_msg("Other");
        }
        return invalidValue();
    }
    func fillLookup(&mut this, parsedProject: &ParsedModule) -> bool {
        this.addModuleToLookup(parsedProject);
        this.tryResolveRemaining();
        return !this.hadErrorsInLookupStage;
    }
    func addModuleToLookup(&mut this, parsedModule: &ParsedModule) {
        for (mut i: usize = 0; i < parsedModule.declCount; i = i + 1) {
            let decl: &ParsedVarDecl = parsedModule.getDeclAtIndex(i);
            this.addDeclToLookup(decl);
        }
    }
    func addDeclToLookup(&mut this, parsedDecl: &ParsedVarDecl) -> bool {
        let value: EvaluatedValue = this.tryEvaluate(&parsedDecl.value);
        if (value.isValid()) {
            this.addResolvedDecl(&parsedDecl.name, &value);
            if (parsedDecl.isMutable && value.requiresImmutable()) unsafe {
                let stderr: Any = fdopen(2, "a");
                let loc: String = parsedDecl.name.span.toString();
                fprintf(stderr, "error: %s: Variables that store %s value can't be mutable.\n", loc.chars(), evalTypeToStr(value.kind));
                loc.drop();
                this.hadErrorsInLookupStage = true;
            }
            return true;
        } else {
            this.addUnresolvedDecl(parsedDecl);
            return false;
        }
    }
    func removeUnresolvedAtIndex(&mut this, index: usize) {
        assert_with_msg(index < this.unresolvedLen, "Out of bounds index in removeUnresolvedAtIndex");
        let l: usize = this.unresolvedLen - 1;
        unsafe {
            let last: &ParsedVarDecl = this.getUnresolvedAtIndex(l);
            *(this.unresolvedDecls + index * sizeof &ParsedVarDecl) = last;
            this.unresolvedLen = this.unresolvedLen - 1;

        }
    }
    func isKnownUnresolved(&mut this, decl: &ParsedVarDecl) -> bool {
        for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) {
            let unresolved: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
            if (unresolved == decl) return true;
        }
        return false;
    }
    func addUnresolvedDecl(&mut this, decl: &ParsedVarDecl) {
        debug("Add Unresolved");
        debug(decl.name.span.toString().chars());
        if (this.unresolvedLen >= this.unresolvedCap) {
            todo_with_msg("Resize unresolved");
        }
        if (this.isKnownUnresolved(decl)) return;
        unsafe {
            *(this.unresolvedDecls + this.unresolvedLen * sizeof &ParsedVarDecl) = decl;
        }
        this.unresolvedLen = this.unresolvedLen + 1;
    }
    func getGlobalTypeDeclLoc(&mut this, varName: SubStr) -> Span {
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let decl: &NameValuePair = this.getResolvedAtIndex(i);
            if (decl.name.equals(&varName))
                return decl.value.span;
        }
        assert_with_msg(false, "unreachable: getGlobalTypeDeclLoc() expects a known variable name as input");
        return defaultSpan();
    }
    func addResolvedDecl(&mut this, tkn: &Token, value: &EvaluatedValue) {
        assert(value.isValid());
        // FIXME: This is better placed in addDeclToLookup() before we even evaluate the value
        //        It's easier to lookup the name first
        if (this.isKnownType(tkn.content)) unsafe {
            let stderr: Any = fdopen(2, "a");
            let loc: String = tkn.span.toString();
            let name: String = tkn.content.toString();
            let prevLoc: Span = this.getGlobalTypeDeclLoc(tkn.content);
            let prevLocStr: String = prevLoc.toString();
            fprintf(stderr, "error: %s: Redeclaration of variable %s.\nnote: %s: Variable already declared here.\n", loc.chars(), name.chars(), prevLocStr.chars());
            prevLocStr.drop();
            name.drop();
            loc.drop();
            this.hadErrorsInLookupStage = true;
            return;
        }
        debug("Add Resolved");
        debug(tkn.span.toString().chars());
        if (this.resolvedLen >= this.resolvedCap) {
            todo_with_msg("Resize resolved");
        }
        let pair: NameValuePair = NameValuePair {
            span: tkn.span,
            name: tkn.content,
            value: *value
        };
        unsafe {
            *(this.resolvedDecls + this.resolvedLen * sizeof NameValuePair) = pair;
        }
        this.resolvedLen = this.resolvedLen + 1;
    }
    func tryResolveRemaining(&mut this) {
        trace("tryResolveRemaining");
        mut currentUnresolved: usize = this.unresolvedLen;
        assert_with_msg(INITIAL_CAPACITY == 64, "Resize newResolved array");
        while (currentUnresolved > 0) {
            debug("Still have types to resolve...");
            mut newResolved: [usize; 64] = blank;
            mut newLen: usize = 0;
            for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) {
                let decl: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
                let success: bool = this.addDeclToLookup(decl);
                if (success) {
                    newResolved[newLen] = i;
                    newLen = newLen + 1;
                }
            }
            for (mut i: usize = newLen - 1; i >= 0; i = i - 1) {
                this.removeUnresolvedAtIndex(newResolved[i]);
            }
            if (currentUnresolved == this.unresolvedLen) {
                // Could not resolve any new type in this iteration
                // which means we would loop infinitely
                break;
            }
            currentUnresolved = this.unresolvedLen;
        }
        for (mut i: usize = 0; i < this.unresolvedLen; i = i + 1) unsafe {
            let unresolved: &ParsedVarDecl = this.getUnresolvedAtIndex(i);
            let loc: String = unresolved.name.span.toString();
            let name: String = unresolved.name.content.toString();
            // FIXME: We don't actually know which part of the given VarDecl can't be resolved.
            let stderr: Any = fdopen(2, "a");
            fprintf(stderr, "error: %s: Variable %s contains types which could not be resolved.\n", loc.chars(), name.chars());
            this.hadErrorsInLookupStage = true;
        }
    }
    func isKnownType(&mut this, name: SubStr) -> bool {
        for (mut i: usize = 0; i < this.resolvedLen; i = i + 1) {
            let resolved: &NameValuePair = this.getResolvedAtIndex(i);
            if (resolved.name.equals(&name)) return true;
        }
        return false;
    }
}

func newTypeChecker() -> TypeChecker {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof &ParsedVarDecl);
        assert_with_msg(mem != null, "Could not allocate enough memory in newTypeChecker()");
        let unresolvedDecls: &mut &ParsedVarDecl = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof NameValuePair);
        assert_with_msg(mem != null, "Could not allocate enough memory in newTypeChecker()");
        let resolvedDecls: &mut NameValuePair = &mut *mem;
        return TypeChecker {
            hadErrorsInLookupStage: false,
            unresolvedDecls: unresolvedDecls,
            unresolvedLen: 0,
            unresolvedCap: INITIAL_CAPACITY,
            resolvedDecls: resolvedDecls,
            resolvedLen: 0,
            resolvedCap: INITIAL_CAPACITY,

        };
    }
}
