

struct VecChar {
    buffer: &mut char;
    length: usize;
    capacity: usize;

    func with_capacity(cap: usize) -> VecChar {
        unsafe {
            return VecChar {
                buffer: calloc(cap, 1),
                length: 0,
                capacity: cap,
            };
        }
    }

    func resize(&mut this, new_cap: usize) {
        unsafe {
            printf("[DEBUG] Before realloc, old ptr: %p old cap: %d\n", this.buffer, this.capacity);
            let _a: Any = calloc(new_cap, 1);
            let new_buf: &mut char = &mut *_a;
            memcpy(new_buf, this.buffer, this.length);
            free(this.buffer);
            this.buffer = new_buf;
            this.capacity = new_cap;
            printf("[DEBUG] After realloc, new ptr: %p new cap: %d\n", this.buffer, this.capacity);
        }
    }

    func push(&mut this, c: char) {
        if (this.length >= this.capacity) {
            this.resize(2 * this.capacity);
        }
        unsafe {
            *(this.buffer + this.length) = c;
        }
        this.length = this.length + 1;
    }

    func get(&this, index: usize) -> char {
        assert(index >= 0 && index <= this.length, "Index Out Of Bounds for Vector!");
        unsafe {
            return *(this.buffer + index);
        }
    }
}