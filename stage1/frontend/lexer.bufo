import "util/span.bufo";
import "util/substr.bufo";
import "util/string.bufo";
import "frontend/token.bufo";

func BUILD_A_KEYWORD(s: &char) -> SubStr { unsafe { return newSubStr(s, 0, strlen(s)); }}
func KEYWORD_FUNC() -> SubStr { return BUILD_A_KEYWORD("func"); }
func KEYWORD_LET() -> SubStr { return BUILD_A_KEYWORD("let"); }
func KEYWORD_STRUCT() -> SubStr { return BUILD_A_KEYWORD("struct"); }
func KEYWORD_ENUM() -> SubStr { return BUILD_A_KEYWORD("enum"); }
func KEYWORD_QUIRK() -> SubStr { return BUILD_A_KEYWORD("quirk"); }
func KEYWORD_REALIZE() -> SubStr { return BUILD_A_KEYWORD("realize"); }
func KEYWORD_TYPE() -> SubStr { return BUILD_A_KEYWORD("type"); }
func KEYWORD_FOR() -> SubStr { return BUILD_A_KEYWORD("for"); }
func KEYWORD_MUT() -> SubStr { return BUILD_A_KEYWORD("mut"); }
func KEYWORD_SELF_LOWER() -> SubStr { return BUILD_A_KEYWORD("self"); }
func KEYWORD_SELF_UPPER() -> SubStr { return BUILD_A_KEYWORD("Self"); }
struct Lexer {
    content: SubStr;
    ptr: usize;
    len: usize;

    func isKeyword(&mut this, word: &SubStr) -> bool {
        if (word.equals(&KEYWORD_FUNC())) return true;
        if (word.equals(&KEYWORD_LET())) return true;
        if (word.equals(&KEYWORD_STRUCT())) return true;
        if (word.equals(&KEYWORD_ENUM())) return true;
        if (word.equals(&KEYWORD_QUIRK())) return true;
        if (word.equals(&KEYWORD_REALIZE())) return true;
        if (word.equals(&KEYWORD_TYPE())) return true;
        if (word.equals(&KEYWORD_FOR())) return true;
        if (word.equals(&KEYWORD_MUT())) return true;
        if (word.equals(&KEYWORD_SELF_LOWER())) return true;
        if (word.equals(&KEYWORD_SELF_UPPER())) return true;
        return false;
    }

    func advance(&mut this) -> bool {
        this.ptr = this.ptr + 1;
        this.content = this.content.substring(1, this.content.len);
        return this.ptr >= this.len;
    }
    func peek(&mut this) -> Token {
        let ptr: usize = this.ptr;
        let content: SubStr = this.content;
        let len: usize = this.len;
        let tkn: Token = this.next();
        this.ptr = ptr;
        this.content = content;
        this.len = len;
        return tkn;
    }
    func next(&mut this) -> Token {
        if (this.ptr == this.len) {
            return newTokenEOF(this.ptr);
        }
        mut currChar: char = this.content.getChar(0);
        while (isWhitespace(currChar)) {
            if (this.advance()) return newTokenEOF(this.ptr);
            currChar = this.content.getChar(0);
        }
        if (isAlphabetic(currChar)) {
            mut len: usize = 0;
            mut tmp: SubStr = this.content;
            while (isNumeric(tmp.getChar(0)) || isAlphabetic(tmp.getChar(0))) {
                len = len + 1;
                tmp = tmp.substring(1, tmp.len);
            }
            let word: SubStr = this.content.substring(0, len);
            this.ptr = this.ptr + len;
            this.content = tmp;
            if (this.isKeyword(&word)) return newToken(&word, this.ptr - len, TOKEN_KEYWORD());
            return newToken(&word, this.ptr - len, TOKEN_IDENT());
        } else if (isNumeric(currChar)) {
            mut len: usize = 0;
            mut tmp: SubStr = this.content;
            while (isNumeric(tmp.getChar(0))) {
                len = len + 1;
                tmp = newSubStr(tmp.start, 1, tmp.len);
            }
            let word: SubStr = this.content.substring(0, len);
            this.ptr = this.ptr + len;
            this.content = tmp;
            return newToken(&word, this.ptr - len, TOKEN_NUMBER());
        } else if (currChar == '(') {
            this.advance();
            return newToken(&newSubStr("(", 0, 1), this.ptr - 1, TOKEN_PAREN_OPEN());
        } else if (currChar == ')') {
            this.advance();
            return newToken(&newSubStr(")", 0, 1), this.ptr - 1, TOKEN_PAREN_CLOSE());
        } else if (currChar == '{') {
            this.advance();
            return newToken(&newSubStr("{", 0, 1), this.ptr - 1, TOKEN_CURLY_OPEN());
        } else if (currChar == '}') {
            this.advance();
            return newToken(&newSubStr("}", 0, 1), this.ptr - 1, TOKEN_CURLY_CLOSE());
        } else if (currChar == '<') {
            this.advance();
            return newToken(&newSubStr("<", 0, 1), this.ptr - 1, TOKEN_SHARP_OPEN());
        } else if (currChar == '>') {
            this.advance();
            return newToken(&newSubStr(">", 0, 1), this.ptr - 1, TOKEN_SHARP_CLOSE());
        } else if (currChar == ';') {
            this.advance();
            return newToken(&newSubStr(";", 0, 1), this.ptr - 1, TOKEN_SEMI_COLON());
        } else if (currChar == ':') {
            this.advance();
            return newToken(&newSubStr(":", 0, 1), this.ptr - 1, TOKEN_COLON());
        } else if (currChar == '=') {
            this.advance();
            return newToken(&newSubStr("=", 0, 1), this.ptr - 1, TOKEN_EQUAL_SINGLE());
        } else if (currChar == '&') {
            this.advance();
            return newToken(&newSubStr("&", 0, 1), this.ptr - 1, TOKEN_AMPERSAND());
        } else if (currChar == ',') {
            this.advance();
            return newToken(&newSubStr(",", 0, 1), this.ptr - 1, TOKEN_COMMA());
        } else if (currChar == '+') {
            this.advance();
            return newToken(&newSubStr("+", 0, 1), this.ptr - 1, TOKEN_PLUS_SINGLE());
        } else if (currChar == '-') {
            this.advance();
            if (this.ptr < this.len && this.content.getChar(0) == '>') {
                this.advance();
                return newToken(&newSubStr("->", 0, 2), this.ptr - 2, TOKEN_ARROW());
            } else {
                todo_with_msg("normal Minus");
            }
        } else if (currChar == '/' && this.content.getChar(1) == '*') {
            while (true) {
                if (this.advance()) return newTokenEOF(this.ptr);
                currChar = this.content.getChar(0);
                let next: char = this.content.getChar(1);
                if (currChar == '*' && next == '/') break;
            }
            this.advance(); // *
            this.advance(); // /
            return this.next();
        } else if (currChar == '/' && this.content.getChar(1) == '/') {
            while (currChar != '\n') {
                if (this.advance()) return newTokenEOF(this.ptr);
                currChar = this.content.getChar(0);
            }
            return this.next();
        } else {
            unsafe {
                let stderr: Any = fdopen(2, "w");
                fprintf(stderr, "error: %llu: Unknown character `%c`.\n", this.ptr, currChar);
                exit(1);
            }
        }
        assert_with_msg(false, "Unexpected fallthrough in Lexer.next()");
        return defaultToken();
    }
}

func newLexer(content: &SubStr) -> Lexer {
    return Lexer {
        content: *content,
        ptr: 0,
        len: content.len
    };
}
