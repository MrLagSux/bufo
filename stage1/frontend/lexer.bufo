import "substr.bufo";
import "string.bufo";
import "util/span.bufo";
import "frontend/token.bufo";

comptime func BUILD_A_KEYWORD(s: &char) -> SubStr {
    unsafe {
        return SubStr {
            start: s,
            len: comptimeStrlen(s)
        };
    }
}
comptime KEYWORD_LET: SubStr = BUILD_A_KEYWORD("let");
comptime KEYWORD_MUT: SubStr = BUILD_A_KEYWORD("mut");
comptime KEYWORD_FUNC: SubStr = BUILD_A_KEYWORD("func");
comptime KEYWORD_STRUCT: SubStr = BUILD_A_KEYWORD("struct");
comptime KEYWORD_ENUM: SubStr = BUILD_A_KEYWORD("enum");
comptime KEYWORD_UNION: SubStr = BUILD_A_KEYWORD("union");
comptime KEYWORD_RETURN: SubStr = BUILD_A_KEYWORD("return");
struct Lexer {
    content: SubStr;
    ptr: usize;
    len: usize;

    func isKeyword(&mut this, word: &SubStr) -> bool {
        return word.equals(&KEYWORD_LET)
            || word.equals(&KEYWORD_FUNC)
			|| word.equals(&KEYWORD_MUT)
            || word.equals(&KEYWORD_STRUCT)
            || word.equals(&KEYWORD_ENUM)
            || word.equals(&KEYWORD_UNION)
            || word.equals(&KEYWORD_RETURN);
    }

    func advance(&mut this) -> bool {
        this.ptr = this.ptr + 1;
        this.content = this.content.substring(1, this.content.len);
        return this.ptr >= this.len;
    }
    func peek(&mut this) -> Token {
        let ptr: usize = this.ptr;
        let content: SubStr = this.content;
        let len: usize = this.len;
        let tkn: Token = this.next();
        this.ptr = ptr;
        this.content = content;
        this.len = len;
        return tkn;
    }
    func next(&mut this) -> Token {
        if (this.ptr == this.len) {
            return newTokenEOF(this.ptr);
        }
        mut currChar: char = this.content.getChar(0);
        while (isWhitespace(currChar)) {
            if (this.advance()) return newTokenEOF(this.ptr);
            currChar = this.content.getChar(0);
        }
        if (isAlphabetic(currChar)) {
            mut len: usize = 0;
            mut tmp: SubStr = this.content;
            while (isNumeric(tmp.getChar(0)) || isAlphabetic(tmp.getChar(0))) {
                len = len + 1;
                tmp = tmp.substring(1, tmp.len);
            }
            let word: SubStr = this.content.substring(0, len);
            this.ptr = this.ptr + len;
            this.content = tmp;
            if (this.isKeyword(&word)) return newToken(&word, this.ptr - len, TOKEN_KEYWORD);
            return newToken(&word, this.ptr - len, TOKEN_IDENT);
        } else if (isNumeric(currChar)) {
            mut len: usize = 0;
            mut tmp: SubStr = this.content;
            while (isNumeric(tmp.getChar(0))) {
                len = len + 1;
                tmp = newSubStr(tmp.start, 1, tmp.len);
            }
            let word: SubStr = this.content.substring(0, len);
            this.ptr = this.ptr + len;
            this.content = tmp;
            return newToken(&word, this.ptr - len, TOKEN_NUMBER);
        } else if (currChar == '(') {
            this.advance();
            return newToken(&newSubStr("(", 0, 1), this.ptr - 1, TOKEN_PAREN_OPEN);
        } else if (currChar == ')') {
            this.advance();
            return newToken(&newSubStr(")", 0, 1), this.ptr - 1, TOKEN_PAREN_CLOSE);
        } else if (currChar == '{') {
            this.advance();
            return newToken(&newSubStr("{", 0, 1), this.ptr - 1, TOKEN_CURLY_OPEN);
        } else if (currChar == '}') {
            this.advance();
            return newToken(&newSubStr("}", 0, 1), this.ptr - 1, TOKEN_CURLY_CLOSE);
        } else if (currChar == '<') {
            this.advance();
            return newToken(&newSubStr("<", 0, 1), this.ptr - 1, TOKEN_SHARP_OPEN);
        } else if (currChar == '>') {
            this.advance();
            return newToken(&newSubStr(">", 0, 1), this.ptr - 1, TOKEN_SHARP_CLOSE);
        } else if (currChar == ';') {
            this.advance();
            return newToken(&newSubStr(";", 0, 1), this.ptr - 1, TOKEN_SEMI_COLON);
        } else if (currChar == ':') {
            this.advance();
            return newToken(&newSubStr(":", 0, 1), this.ptr - 1, TOKEN_COLON);
        } else if (currChar == '=') {
            this.advance();
            return newToken(&newSubStr("=", 0, 1), this.ptr - 1, TOKEN_EQUAL_SINGLE);
        } else if (currChar == '&') {
            this.advance();
            return newToken(&newSubStr("&", 0, 1), this.ptr - 1, TOKEN_AMPERSAND);
        } else if (currChar == '_') {
            this.advance();
            return newToken(&newSubStr("_", 0, 1), this.ptr - 1, TOKEN_UNDERSCORE);
        } else if (currChar == '.') {
            this.advance();
            return newToken(&newSubStr(".", 0, 1), this.ptr - 1, TOKEN_DOT);
        } else if (currChar == ',') {
            this.advance();
            return newToken(&newSubStr(",", 0, 1), this.ptr - 1, TOKEN_COMMA);
        } else if (currChar == '+') {
            this.advance();
            return newToken(&newSubStr("+", 0, 1), this.ptr - 1, TOKEN_PLUS_SINGLE);
        } else if (currChar == '@') {
            this.advance();
            return newToken(&newSubStr("@", 0, 1), this.ptr - 1, TOKEN_AT);
        } else if (currChar == '-') {
            this.advance();
            if (this.ptr < this.len && this.content.getChar(0) == '>') {
                this.advance();
                return newToken(&newSubStr("->", 0, 2), this.ptr - 2, TOKEN_ARROW);
            } else {
                todo_with_msg("normal Minus");
            }
        } else if (currChar == '/' && this.content.getChar(1) == '*') {
            while (true) {
                if (this.advance()) return newTokenEOF(this.ptr);
                currChar = this.content.getChar(0);
                let next: char = this.content.getChar(1);
                if (currChar == '*' && next == '/') break;
            }
            this.advance(); // *
            this.advance(); // /
            return this.next();
        } else if (currChar == '/' && this.content.getChar(1) == '/') {
            while (currChar != '\n') {
                if (this.advance()) return newTokenEOF(this.ptr);
                currChar = this.content.getChar(0);
            }
            return this.next();
        } else {
            unsafe {
                let stderr: Any = fdopen(2, "w");
                fprintf(stderr, "error: %llu: Unknown character `%c`.\n", this.ptr, currChar);
                exit(1);
            }
        }
        assert_with_msg(false, "Unexpected fallthrough in Lexer.next()");
        return defaultToken();
    }
}

func newLexer(content: &SubStr) -> Lexer {
    return Lexer {
        content: *content,
        ptr: 0,
        len: content.len
    };
}
