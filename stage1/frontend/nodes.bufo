import "substr.bufo";
import "string.bufo";
import "util/span.bufo";
import "frontend/token.bufo";

comptime INITIAL_CAPACITY: usize = 64;

struct ParsedModule {
    span: Span;
    decls: &mut ParsedVarDecl;
    declCap: usize;
    declCount: usize;
    dirs: &mut ParsedDeclValue;
    dirCap: usize;
    dirCount: usize;

    func addVarDecl(&mut this, varDecl: ParsedVarDecl) {
        if (this.declCount >= this.declCap) {
            todo_with_msg("idk");
        }
        unsafe {
            *(this.decls + this.declCount * sizeof ParsedVarDecl) = varDecl;
        }
        this.declCount = this.declCount + 1;
    }
    func addDirective(&mut this, dir: ParsedDeclValue) {
        if (this.dirCount >= this.declCap) {
            todo_with_msg("idk");
        }
        unsafe {
            *(this.dirs + this.declCount * sizeof ParsedDeclValue) = dir;
        }
        this.dirCount = this.declCount + 1;
    }

    func getDeclAtIndex(&this, index: usize) -> &ParsedVarDecl {
        assert(index < this.declCount);
        unsafe {
            let _decl: &mut ParsedVarDecl = this.decls + index * sizeof ParsedVarDecl;
            return _decl as &ParsedVarDecl;
        }
    }
}

func defaultModule() -> ParsedModule {
    unsafe {
        let span: Span = defaultSpan();
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof ParsedVarDecl);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultModule()");
        let decls: &mut ParsedVarDecl = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof ParsedDeclValue);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultModule()");
        let dirs: &mut ParsedDeclValue = &mut *mem;
        return ParsedModule {
            span: span,
            decls: decls,
            declCap: INITIAL_CAPACITY,
            declCount: 0,
            dirs: dirs,
            dirCap: INITIAL_CAPACITY,
            dirCount: 0
        };
    }
}

struct ParsedVarDecl {
    name: Token;
    value: ParsedDeclValue;
    isMutable: bool;
}

func createVarDecl(name: Token, value: ParsedDeclValue, mutable: bool) -> ParsedVarDecl {
    return ParsedVarDecl {
        name: name,
        value: value,
        isMutable: mutable
    };
}

comptime DECL_VALUE_INVALID: usize = 0;
comptime DECL_VALUE_MODULE: usize = 1;
comptime DECL_VALUE_FUNC_DECL: usize = 2;
comptime DECL_VALUE_STRUCT_DECL: usize = 3;
comptime DECL_VALUE_ENUM_DECL: usize = 4;
comptime DECL_VALUE_UNION_DECL: usize = 5;
comptime DECL_VALUE_BUILTIN: usize = 6;
comptime DECL_VALUE_CALL: usize = 7;
comptime DECL_VALUE_IDENT: usize = 8;
comptime DECL_VALUE_BINARY: usize = 9;
comptime DECL_VALUE_NUMBER: usize = 10;
struct ParsedDeclValue {
    kind: usize;
    span: Span;
    data: Any;

    func asModule(&this) -> &ParsedModule {
        assert(this.kind == DECL_VALUE_MODULE);
        unsafe {
            return this.data as &ParsedModule;
        }
    }
    func asStruct(&this) -> &ParsedStructDecl {
        assert(this.kind == DECL_VALUE_STRUCT_DECL);
        unsafe {
            return this.data as &ParsedStructDecl;
        }
    }
    func asEnum(&this) -> &ParsedEnumDecl {
        assert(this.kind == DECL_VALUE_ENUM_DECL);
        unsafe {
            return this.data as &ParsedEnumDecl;
        }
    }
    func asUnion(&this) -> &ParsedUnionDecl {
        assert(this.kind == DECL_VALUE_UNION_DECL);
        unsafe {
            return this.data as &ParsedUnionDecl;
        }
    }
    func asFunc(&this) -> &ParsedFuncDecl {
        assert(this.kind == DECL_VALUE_FUNC_DECL);
        unsafe {
            return this.data as &ParsedFuncDecl;
        }
    }
    func asIdent(&this) -> &ParsedDeclValueIdent {
        assert(this.kind == DECL_VALUE_IDENT);
        unsafe {
            return this.data as &ParsedDeclValueIdent;
        }
    }
    func asCall(&this) -> &ParsedDeclValueCall {
        assert(this.kind == DECL_VALUE_CALL);
        unsafe {
            return this.data as &ParsedDeclValueCall;
        }
    }
}

func defaultDeclValue() -> ParsedDeclValue {
    unsafe {
        return ParsedDeclValue {
            kind: DECL_VALUE_INVALID,
            span: defaultSpan(),
            data: null
        };
    }
}

func createDeclValue(kind: usize, span: Span, size: usize, data: Any) -> ParsedDeclValue {
    unsafe {
        mut mem: Any = calloc(1, size);
        assert(mem != null);
        memcpy(mem, data, size);
        return ParsedDeclValue {
            kind: kind,
            span: span,
            data: mem
        };
    }
}

struct ParsedDeclValueCall {
    fn: ParsedDeclValue;
    args: [ParsedDeclValue; 8];
    argCount: usize;
}

struct ParsedDeclValueIdent {
    name: SubStr;
}
struct ParsedDeclValueNumber {
    span: Span;
    number: SubStr;
}

comptime BINARY_OP_DOT: usize = 0;
comptime BINARY_OP_PAREN: usize = 1;
comptime BINARY_OP_PLUS: usize = 2;
comptime BINARY_OP_MINUS: usize = 3;
func createBinaryOp(op: &SubStr) -> usize {
    comptime DOT: SubStr = BUILD_A_KEYWORD(".");
    comptime PAREN: SubStr = BUILD_A_KEYWORD("(");
    comptime PLUS: SubStr = BUILD_A_KEYWORD("+");
    comptime MINUS: SubStr = BUILD_A_KEYWORD("-");
    if (op.equals(&DOT)) return BINARY_OP_DOT;
    if (op.equals(&PAREN)) return BINARY_OP_PAREN;
    if (op.equals(&PLUS)) return BINARY_OP_PLUS;
    if (op.equals(&MINUS)) return BINARY_OP_MINUS;
    todo_with_msg("createBinaryOp for invalid op");
    return 0;
}
struct ParsedDeclValueBinary {
    op: usize;
    lhs: ParsedDeclValue;
    rhs: ParsedDeclValue;
}

struct ParsedEnumVariant {
    span: Span;
    name: SubStr;
    value: ParsedDeclValue;

    func setName(&mut this, nameToken: &Token) {
        this.name = nameToken.content;
        this.span = nameToken.span;
    }
    func setValue(&mut this, value: &ParsedDeclValue) {
        assert_with_msg(!this.name.equals(&defaultSubStr()), "Name of EnumVariant must be set before setting value");
        this.value = *value;
        this.span = newSpanBetween(&this.span, &value.span);
    }
}

func defaultEnumVariant() -> ParsedEnumVariant {
    return ParsedEnumVariant {
        span: defaultSpan(),
        name: defaultSubStr(),
        value: defaultDeclValue()
    };
}

struct ParsedEnumDecl {
    span: Span;
    hasVariantType: bool;
    variantType: &ParsedTypeExpr;
    variants: &mut ParsedEnumVariant;
    variantsLen: usize;
    variantsCap: usize;

    func setVariantType(&mut this, variant: &ParsedTypeExpr) {
        unsafe {
            assert_with_msg(!this.hasVariantType, "Can only call ParsedEnumDecl.setVariantType once");
            assert_with_msg(this.variantType == null, "Can only call ParsedEnumDecl.setVariantType once");
            this.variantType = calloc(sizeof ParsedTypeExpr, 1);
            assert_with_msg(this.variantType != null, "Could not allocate memory in ParsedEnumDecl.setVariantType");
            memcpy(this.variantType, variant, sizeof ParsedTypeExpr);
            this.hasVariantType = true;
        }
    }

    func addVariant(&mut this, variant: &ParsedEnumVariant) {
        if (this.variantsLen >= this.variantsCap) {
            todo_with_msg("Resize variants");
        }
        unsafe {
            *(this.variants + this.variantsLen * sizeof ParsedEnumVariant) = *variant;
        }
        this.variantsLen = this.variantsLen + 1;
    }

    func getVariantAtIndex(&this, index: usize) -> &ParsedEnumVariant {
        assert_with_msg(index < this.variantsLen, "Out of bounds access for getVariantAtIndex");
        unsafe {
            return (this.variants + index * sizeof ParsedEnumVariant) as &ParsedEnumVariant;
        }
    }
}

func defaultEnumDecl() -> ParsedEnumDecl {
    unsafe {
        let mem: Any = calloc(sizeof ParsedEnumVariant, INITIAL_CAPACITY);
        assert_with_msg(mem != null, "Could not allocate memory in defaultEnumDecl()");
        let variants: &mut ParsedEnumVariant = &mut *mem;
        return ParsedEnumDecl {
            span: defaultSpan(),
            hasVariantType: false,
            variantType: null,
            variants: variants,
            variantsLen: 0,
            variantsCap: INITIAL_CAPACITY
        };
    }
}

struct ParsedUnionDecl {
}

func defaultUnionDecl() -> ParsedUnionDecl {
    return blank;
}

struct ParsedStructDecl {
    span: Span;
    fields: &mut ParsedStructField;
    fieldCap: usize;
    fieldCount: usize;
    assets: &mut ParsedStructAsset;
    assetCap: usize;
    assetCount: usize;
    func addField(&mut this, field: ParsedStructField) {
        if (this.fieldCount >= this.fieldCap) {
            todo_with_msg("resize fields");
        }
        unsafe {
            *(this.fields + this.fieldCount * sizeof ParsedStructField) = field;
        }
        this.fieldCount = this.fieldCount + 1;
    }
    func addAsset(&mut this, asset: ParsedStructAsset) {
        if (this.assetCount >= this.assetCap) {
            todo_with_msg("resize assets");
        }
        unsafe {
            *(this.assets + this.assetCount * sizeof ParsedStructAsset) = asset;
        }
        this.assetCount = this.assetCount + 1;
    }
    func getFieldAtIndex(&this, index: usize) -> &ParsedStructField {
        assert(index < this.fieldCount);
        unsafe {
            return (this.fields + index * sizeof ParsedStructField) as &ParsedStructField;
        }
    }
    func getAssetAtIndex(&this, index: usize) -> &ParsedStructAsset {
        assert(index < this.assetCount);
        unsafe {
            return (this.assets + index * sizeof ParsedStructAsset) as &ParsedStructAsset;
        }
    }
}

func defaultStructDecl() -> ParsedStructDecl {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof ParsedStructField);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultStructDecl()");
        let fields: &mut ParsedStructField = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof ParsedStructAsset);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultStructDecl()");
        let assets: &mut ParsedStructAsset = &mut *mem;
        return ParsedStructDecl {
            span: defaultSpan(),
            fields: fields,
            fieldCap: INITIAL_CAPACITY,
            fieldCount: 0,
            assets: assets,
            assetCap: INITIAL_CAPACITY,
            assetCount: 0
        };
    }
}

struct ParsedStructField {
    span: Span;
    name: SubStr;
    typ: ParsedTypeExpr;
}

struct ParsedStructAsset {
    asset: ParsedVarDecl;
}

struct ParsedFuncDecl {
    span: Span;
    params: &mut ParsedParam;
    paramCap: usize;
    paramCount: usize;
    stmts: &mut ParsedStmt;
    stmtCap: usize;
    stmtCount: usize;
    retType: ParsedTypeExpr;
    func addParam(&mut this, param: ParsedParam) {
        if (this.paramCount >= this.paramCap) {
            todo_with_msg("resize params");
        }
        unsafe {
            *(this.params + this.paramCount * sizeof ParsedParam) = param;
        }
        this.paramCount = this.paramCount + 1;
    }
    func addStmt(&mut this, stmt: ParsedStmt) {
        if (this.stmtCount >= this.stmtCap) {
            todo_with_msg("resize stmts");
        }
        unsafe {
            *(this.stmts + this.stmtCount * sizeof ParsedStmt) = stmt;
        }
        this.stmtCount = this.stmtCount + 1;
    }
    func setReturnType(&mut this, retType: ParsedTypeExpr) {
        this.retType = retType;
    }

    func getParamAtIndex(&this, index: usize) -> &ParsedParam {
        assert_with_msg(index < this.paramCount, "Out of bounds ac cess in ParsedFuncDecl.getParamAtIndex()");
        unsafe {
            let _param: &mut ParsedParam = this.params + index * sizeof ParsedParam;
            return _param as &ParsedParam;
        }
    }
}
func defaultFuncDecl() -> ParsedFuncDecl {
    unsafe {
        mut mem: Any = calloc(INITIAL_CAPACITY, sizeof ParsedParam);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultFuncDecl()");
        let params: &mut ParsedParam = &mut *mem;
        mem = calloc(INITIAL_CAPACITY, sizeof ParsedStmt);
        assert_with_msg(mem != null, "Could not allocate enough memory in defaultFuncDecl()");
        let stmts: &mut ParsedStmt = &mut *mem;
        let retType: ParsedTypeExpr = defaultTypeExpr();
        return ParsedFuncDecl {
            span: defaultSpan(),
            params: params,
            paramCap: INITIAL_CAPACITY,
            paramCount: 0,
            stmts: stmts,
            stmtCap: INITIAL_CAPACITY,
            stmtCount: 0,
            retType: retType
        };
    }
}
struct ParsedParam {
    span: Span;
    name: SubStr;
    typ: ParsedTypeExpr;
}

struct ParsedTypeExpr {
    expr: ParsedDeclValue;
}

func defaultTypeExpr() -> ParsedTypeExpr {
    let noneIdent: ParsedDeclValueIdent = ParsedDeclValueIdent {
        name: newSubStrOfStrLit("none")
    };
    let dummySpan: Span = defaultSpan();
    let none: ParsedDeclValue = createDeclValue(DECL_VALUE_IDENT, dummySpan, sizeof ParsedDeclValueIdent, &noneIdent);
    return ParsedTypeExpr {
        expr: none
    };
}

comptime STMT_VAR_DECL: usize = 0;
comptime STMT_RETURN: usize = 1;
struct ParsedStmt {
    kind: usize;
    data: Any;
}

func createStmt(kind: usize, size: usize, data: Any) -> ParsedStmt {
    unsafe {
        mut mem: Any = calloc(1, size);
        assert(mem != null);
        memcpy(mem, data, size);
        return ParsedStmt {
            kind: kind,
            data: mem
        };
    }
}
