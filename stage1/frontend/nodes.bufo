import "substr.bufo";
import "string.bufo";
import "util/span.bufo";
import "frontend/token.bufo";

struct Module {

}

struct VarDecl {

}

comptime DECL_VALUE_INVALID: usize = 0;
comptime DECL_VALUE_BUILTIN: usize = 1;
comptime DECL_VALUE_CALL: usize = 2;
comptime DECL_VALUE_IDENT: usize = 3;
comptime DECL_VALUE_BINARY: usize = 4;
comptime DECL_VALUE_NUMBER: usize = 5;
struct DeclValue {
	kind: usize;
	data: Any;
}

func defaultDeclValue() -> DeclValue {
	unsafe {
		return DeclValue {
			kind: DECL_VALUE_INVALID,
			data: null
		};
	}
}

func createDeclValue(kind: usize, size: usize, data: Any) -> DeclValue {
	unsafe {
		mut mem: Any = calloc(1, size);
		assert(mem != null);
		memcpy(mem, data, size);
		return DeclValue {
			kind: kind,
			data: mem
		};
	}
}

struct DeclValueCall {
	fn: DeclValue;
	args: [DeclValue; 8];
	argCount: usize;
}

struct DeclValueIdent {
	name: SubStr;
}
struct DeclValueNumber {
	number: SubStr;
}

comptime BINARY_OP_DOT: usize = 0;
comptime BINARY_OP_PAREN: usize = 1;
comptime BINARY_OP_PLUS: usize = 2;
func createBinaryOp(op: &SubStr) -> usize {
	comptime DOT: SubStr = BUILD_A_KEYWORD(".");
	comptime PAREN: SubStr = BUILD_A_KEYWORD("(");
	comptime PLUS: SubStr = BUILD_A_KEYWORD("+");
	if (op.equals(&DOT)) return BINARY_OP_DOT;
	if (op.equals(&PAREN)) return BINARY_OP_PAREN;
	if (op.equals(&PLUS)) return BINARY_OP_PLUS;
	todo_with_msg("createBinaryOp for invalid op");
	return 0;
}
struct DeclValueBinary {
	op: usize;
	lhs: DeclValue;
	rhs: DeclValue;
}

struct StructDecl {
	func addField(&mut this, field: StructField) {
	}
	func addAsset(&mut this, asset: StructAsset) {
	}
}

struct StructField {
	name: SubStr;
	typ: TypeExpr;

}

struct StructAsset {
	asset: VarDecl;
}

struct Param {

}

struct TypeExpr {
	expr: DeclValue;
}

func defaultTypeExpr() -> TypeExpr {
	let noneCall: DeclValueCall = DeclValueCall {
		fn: defaultDeclValue(),
		args: blank,
		argCount: 0
	};
	let none: DeclValue = createDeclValue(DECL_VALUE_BUILTIN, sizeof DeclValueCall, &noneCall);
	return TypeExpr {
		expr: none
	};
}

comptime STMT_VAR_DECL: usize = 0;
comptime STMT_RETURN: usize = 1;
struct Stmt {
	kind: usize;
	data: Any;
}

func createStmt(kind: usize, size: usize, data: Any) -> Stmt {
	unsafe {
		mut mem: Any = calloc(1, size);
		assert(mem != null);
		memcpy(mem, data, size);
		return Stmt {
			kind: kind,
			data: mem
		};
	}
}
