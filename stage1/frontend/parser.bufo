
comptime ASSOC_LEFT: usize = 0;
comptime ASSOC_RIGHT: usize = 1;
struct Parser {
    lexer: &mut Lexer;

    func next(&mut this) -> Token {
        return this.lexer.next();
    }
    func peek(&mut this) -> Token {
        return this.lexer.peek();
    }
    func eat(&mut this, kind: usize) -> bool {
        if (this.at(kind)) {
            this.lexer.next();
            return true;
        }
        return false;
    }
    func at(&mut this, kind: usize) -> bool {
        let tkn: Token = this.lexer.peek();
        return tkn.kind == kind;
    }
    func atEOF(&mut this) -> bool {
        return this.at(TOKEN_EOF);
    }
    func expect(&mut this, kind: usize) -> Token {
        let tkn: Token = this.lexer.next();
        if (tkn.kind != kind) unsafe {
            let stderr: Any = fdopen(2, "w");
            let s: String = tkn.toString();
            let l: String = tkn.span.toString();
            fprintf(stderr, "error: %s: Expected %s, found `%s`.\n", l.buffer, tokenKindToString(kind), s.buffer);
            exit(1);
        }
        return tkn;
    }
    func expectIdent(&mut this) -> Token {
        return this.expect(TOKEN_IDENT);
    }
    func expectKeyword(&mut this, keyword: &SubStr) -> Token {
        let tkn: Token = this.expect(TOKEN_KEYWORD);
        if (!tkn.content.equals(keyword)) unsafe {
            let stderr: Any = fdopen(2, "w");
            let ts: String = tkn.toString();
            let ls: String = tkn.span.toString();
            let ks: String = keyword.toString();
            fprintf(stderr, "error: %s: Expected keyword `%s`, found `%s`.\n", ls.buffer, ks.buffer, ts.buffer);
            exit(1);
        }
        return tkn;
    }

	func parseModule(&mut this, name: &SubStr) -> Module {
		while (!this.atEOF()) {
			let decl: VarDecl = this.parseVarDecl();
		}
		return Module {};
	}
	func parseVarDecl(&mut this) -> VarDecl {
		let mutToken: Token = this.expect(TOKEN_KEYWORD);
		mut mutable: bool = false;
		if (mutToken.content.equals(&KEYWORD_LET))
			mutable = false;
		else if (mutToken.content.equals(&KEYWORD_MUT))
			mutable = true;
		else unsafe {
            let ls: String = mutToken.span.toString();
			let stderr: Any = fdopen(2, "w");
			fprintf(stderr, "error: %s: Expected `let` or `mut`, found `%.*s`.\n", ls.buffer, mutToken.content.len, mutToken.content.start);
			fclose(stderr);
			exit(1);
		}
		let name: Token = this.expect(TOKEN_IDENT);
		this.expect(TOKEN_EQUAL_SINGLE);
		let value: DeclValue = this.parseDeclValue();
        this.expect(TOKEN_SEMI_COLON);
		return VarDecl {};
	}
	func parseDeclValue(&mut this) -> DeclValue {
		if (this.at(TOKEN_KEYWORD))
			return this.parseDeclValueKeyword();
		else
            return this.parseDeclValueExpr();
	}
    func parseDeclValueKeyword(&mut this) -> DeclValue {
        let kw: Token = this.expect(TOKEN_KEYWORD);
        if (kw.content.equals(&KEYWORD_STRUCT))
            return this.parseDeclValueStruct();
        else if (kw.content.equals(&KEYWORD_FUNC))
            return this.parseDeclValueFunc();
        else if (kw.content.equals(&KEYWORD_ENUM))
            return this.parseDeclValueEnum();
        else if (kw.content.equals(&KEYWORD_UNION))
            return this.parseDeclValueUnion();
        else unsafe {
            let ls: String = kw.span.toString();
            let stderr: Any = fdopen(2, "w");
            fprintf(stderr, "error: %s: Expected one of `struct` or `func`, found `%.*s`.\n", ls.buffer, kw.content.len, kw.content.start);
            fclose(stderr);
            exit(1);
        }
        return defaultDeclValue();
    }
    func parseDeclValueStruct(&mut this) -> DeclValue {
        this.expect(TOKEN_CURLY_OPEN);
        mut structDecl: StructDecl = StructDecl {};
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            if (this.at(TOKEN_IDENT)) {
                let structField: StructField = this.parseStructField();
                structDecl.addField(structField);
            } else if (this.at(TOKEN_KEYWORD)) {
                let structAsset: StructAsset = this.parseStructAsset();
                structDecl.addAsset(structAsset);
            } else unsafe {
                let next: Token = this.next();
                let ls: String = next.span.toString();
                let stderr: Any = fdopen(2, "w");
                fprintf(stderr, "error: %s: Expected identifier or `func`, got `%.*s`.\n", ls.buffer, next.content.len, next.content.start);
                fclose(stderr);
                exit(1);
            }
        }
        this.expect(TOKEN_CURLY_CLOSE);
        return defaultDeclValue();
    }
    func parseStructField(&mut this) -> StructField {
        let name: Token = this.expect(TOKEN_IDENT);
        this.expect(TOKEN_COLON);
        let typ: TypeExpr = this.parseTypeExpr();
        this.expect(TOKEN_SEMI_COLON);
        return StructField {
            name: name.content,
            typ: typ
        };
    }
    func parseStructAsset(&mut this) -> StructAsset {
        let decl: VarDecl = this.parseVarDecl();
        return StructAsset {
            asset: decl
        };
    }
    func parseDeclValueEnum(&mut this) -> DeclValue {
        mut fieldType: TypeExpr = defaultTypeExpr();
        if (this.eat(TOKEN_PAREN_OPEN)) {
            fieldType = this.parseTypeExpr();
            this.expect(TOKEN_PAREN_CLOSE);
        }
        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let tkn: Token = this.next();
        }
        this.expect(TOKEN_CURLY_CLOSE);
        return defaultDeclValue();
    }
    func parseDeclValueUnion(&mut this) -> DeclValue {
        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let tkn: Token = this.next();
        }
        this.expect(TOKEN_CURLY_CLOSE);
        return defaultDeclValue();
    }
    func parseDeclValueFunc(&mut this) -> DeclValue {
        this.expect(TOKEN_PAREN_OPEN);
        mut args: [Param; 8] = blank;
        mut argCount: usize = 0;
        while (!this.at(TOKEN_PAREN_CLOSE)) {
            let param: Param = this.parseFuncParam();
            args[argCount] = param;
            argCount = argCount + 1;
            if (!this.at(TOKEN_PAREN_CLOSE)) this.expect(TOKEN_COMMA);
        }
        this.expect(TOKEN_PAREN_CLOSE);

        mut retType: TypeExpr = defaultTypeExpr();
        if (this.eat(TOKEN_ARROW)) {
            retType = this.parseTypeExpr();
        }

        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let expr: Stmt = this.parseStmt();
        }
        this.expect(TOKEN_CURLY_CLOSE);

        return defaultDeclValue();
    }
    func parseFuncParam(&mut this) -> Param {
        let name: Token = this.expect(TOKEN_IDENT);
        this.expect(TOKEN_COLON);
        let typ: TypeExpr = this.parseTypeExpr();
        return Param {};
    }
    func parseDeclValueExpr(&mut this) -> DeclValue {
        return this.__parseDeclValueExpr(0, ASSOC_LEFT);
    }
    func __parseDeclValueExpr(&mut this, minPrecedence: usize, associativity: usize) -> DeclValue {
        mut expr: DeclValue = this.parseDeclValueExprPrimary();
        while (this.matchesBinaryExpression()) {
            let kind: usize = this.peek().kind;
            let newPrecedence: usize = this.getBinaryPrecedence(kind);
            if (newPrecedence < minPrecedence) break;
            if (newPrecedence == minPrecedence && associativity == ASSOC_LEFT) break;
            let newAssociativity: usize = this.getAssociativity(kind);
            let result: DeclValue = this.parseDeclValueExprSecondary(expr, newPrecedence, newAssociativity);
            expr = result;
        }
        return expr;
    }
    func getBinaryPrecedence(&mut this, kind: usize) -> usize {
        if (kind == TOKEN_DOT) return 17;
        if (kind == TOKEN_PAREN_OPEN) return 16;
        if (kind == TOKEN_PLUS_SINGLE) return 11;
        todo_with_msg("getBinaryPrecedence");
        return 0;
    }
    func getAssociativity(&mut this, kind: usize) -> usize {
        if (kind == TOKEN_EQUAL_SINGLE) return ASSOC_RIGHT;
        return ASSOC_LEFT;
    }
    func parseDeclValueExprSecondary(&mut this, lhs: DeclValue, precedence: usize, associativity: usize) -> DeclValue {
        let opTkn: Token = this.peek();
        let op: usize = createBinaryOp(&opTkn.content);
        if (op == BINARY_OP_PAREN) {
            return this.parseDeclValueCall(lhs);
        }
        this.next();
        let rhs: DeclValue = this.__parseDeclValueExpr(precedence, associativity);
        let bin: DeclValueBinary = DeclValueBinary {
            op: op,
            lhs: lhs,
            rhs: rhs
        };
        return createDeclValue(DECL_VALUE_BINARY, sizeof DeclValueBinary, &bin);
    }
    func parseDeclValueExprPrimary(&mut this) -> DeclValue {
        if (this.at(TOKEN_KEYWORD))
            return this.parseDeclValueKeyword();
        else if (this.at(TOKEN_AT))
            return this.parseDeclValueBuiltin();
        if (this.matchesUnaryExpression())
            return this.parseDeclValueExprUnary();
        let tkn: Token = this.peek();
        if (tkn.kind == TOKEN_NUMBER)
            return this.parseDeclValueExprIntLiteral();
        else if (tkn.kind == TOKEN_IDENT)
            return this.parseDeclValueExprIdentifier();
        todo_with_msg("primary");
        return defaultDeclValue();
    }
    func parseDeclValueExprIntLiteral(&mut this) -> DeclValue {
        let number: Token = this.expect(TOKEN_NUMBER);
        let numbah: DeclValueNumber = DeclValueNumber {
            number: number.content
        };
        return createDeclValue(DECL_VALUE_NUMBER, sizeof DeclValueNumber, &numbah);
    }
    func parseDeclValueExprIdentifier(&mut this) -> DeclValue {
        let ident: Token = this.expect(TOKEN_IDENT);
        let id: DeclValueIdent = DeclValueIdent {
            name: ident.content
        };
        return createDeclValue(DECL_VALUE_IDENT, sizeof DeclValueIdent, &id);
    }
    func matchesBinaryExpression(&mut this) -> bool {
        let tkn: Token = this.peek();
        let kind: usize = tkn.kind;
        return kind == TOKEN_PLUS_SINGLE
            || kind == TOKEN_DOT
            || kind == TOKEN_PAREN_OPEN;
    }
    func matchesUnaryExpression(&mut this) -> bool {
        let tkn: Token = this.peek();
        let kind: usize = tkn.kind;
        return kind == TOKEN_AMPERSAND;
    }
    func parseDeclValueExprUnary(&mut this) -> DeclValue {
        todo_with_msg("unary");
        return defaultDeclValue();
    }
    func parseDeclValueBuiltin(&mut this) -> DeclValue {
        // TODO: Instead of assert, report an error
        //       We don't want to let unknown builtin calls through
        this.expect(TOKEN_AT);
        let builtinFn: DeclValue = this.parseDeclValueExpr();
        assert(builtinFn.kind == DECL_VALUE_CALL);
        unsafe {
            let fnName: DeclValue = (builtinFn.data as &DeclValueCall).fn;
            assert(fnName.kind == DECL_VALUE_IDENT);
        }
        return createDeclValue(DECL_VALUE_BUILTIN, sizeof DeclValue, &builtinFn);
    }
    func parseDeclValueCall(&mut this, name: DeclValue) -> DeclValue {
        mut args: [DeclValue; 8] = blank;
        mut argCount: usize = 0;
        this.expect(TOKEN_PAREN_OPEN);
        while (!this.at(TOKEN_PAREN_CLOSE)) {
            let arg: DeclValue = this.parseDeclValueExpr();
            args[argCount] = arg;
            argCount = argCount + 1;
            if (!this.at(TOKEN_PAREN_CLOSE)) this.expect(TOKEN_COMMA);
        }
        this.expect(TOKEN_PAREN_CLOSE);
        unsafe {
            let call: DeclValueCall = DeclValueCall {
                fn: name,
                args: args,
                argCount: argCount
            };
            return createDeclValue(DECL_VALUE_CALL, sizeof DeclValueCall, &call);
        }
    }
    func parseTypeExpr(&mut this) -> TypeExpr {
        let expr: DeclValue = this.parseDeclValueExpr();
        return TypeExpr {
            expr: expr
        };
    }
    func parseStmt(&mut this) -> Stmt {
        mut stmt: Stmt = blank;
        if (this.at(TOKEN_KEYWORD)) {
            let kw: Token = this.peek();
            if (kw.content.equals(&KEYWORD_RETURN))
                stmt = this.parseStmtReturn();
            else if (kw.content.equals(&KEYWORD_LET))
                stmt = this.parseStmtVarDecl();
            else unsafe {
                let ls: String = kw.span.toString();
                let stderr: Any = fdopen(2, "w");
                fprintf(stderr, "error: %s: Expected one of `return` or `let`, found `%.*s`.\n", ls.buffer, kw.content.len, kw.content.start);
                fclose(stderr);
                exit(1);
            }
        } else {
            todo_with_msg("not kw stmt");
        }
        return stmt;
    }
    func parseStmtReturn(&mut this) -> Stmt {
        let kw: Token = this.expectKeyword(&KEYWORD_RETURN);
        let expr: DeclValue = this.parseDeclValueExpr();
        this.expect(TOKEN_SEMI_COLON);
        return createStmt(STMT_RETURN, sizeof DeclValue, &expr);
    }
    func parseStmtVarDecl(&mut this) -> Stmt {
        let decl: VarDecl = this.parseVarDecl();
        return createStmt(STMT_VAR_DECL, sizeof VarDecl, &decl);
    }
}

func newParser(lexer: &mut Lexer) -> Parser {
    return Parser {
        lexer: lexer
    };
}
