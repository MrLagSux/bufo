
comptime ASSOC_LEFT: usize = 0;
comptime ASSOC_RIGHT: usize = 1;
struct Parser {
    lexer: &mut Lexer;

    func next(&mut this) -> Token {
        return this.lexer.next();
    }
    func peek(&mut this) -> Token {
        return this.lexer.peek();
    }
    func eat(&mut this, kind: usize) -> bool {
        if (this.at(kind)) {
            this.lexer.next();
            return true;
        }
        return false;
    }
    func at(&mut this, kind: usize) -> bool {
        let tkn: Token = this.lexer.peek();
        return tkn.kind == kind;
    }
    func atEOF(&mut this) -> bool {
        return this.at(TOKEN_EOF);
    }
    func expect(&mut this, kind: usize) -> Token {
        let tkn: Token = this.lexer.next();
        if (tkn.kind != kind) unsafe {
            let stderr: Any = fdopen(2, "a");
            let s: String = tkn.toString();
            let l: String = tkn.span.toString();
            fprintf(stderr, "error: %s: Expected %s, found `%s`.\n", l.buffer, tokenKindToString(kind), s.buffer);
            exit(1);
        }
        return tkn;
    }
    func expectIdent(&mut this) -> Token {
        return this.expect(TOKEN_IDENT);
    }
    func expectKeyword(&mut this, keyword: &SubStr) -> Token {
        let tkn: Token = this.expect(TOKEN_KEYWORD);
        if (!tkn.content.equals(keyword)) unsafe {
            let stderr: Any = fdopen(2, "a");
            let ts: String = tkn.toString();
            let ls: String = tkn.span.toString();
            let ks: String = keyword.toString();
            fprintf(stderr, "error: %s: Expected keyword `%s`, found `%s`.\n", ls.buffer, ks.buffer, ts.buffer);
            exit(1);
        }
        return tkn;
    }

    func parseModule(&mut this) -> ParsedModule {
        mut module: ParsedModule = defaultModule();
        while (!this.atEOF() && !this.at(TOKEN_CURLY_CLOSE)) {
            if (this.at(TOKEN_AT)) {
                let dir: ParsedDeclValue = this.parseDeclValueBuiltin();
                this.expect(TOKEN_SEMI_COLON);
                module.addDirective(dir);
            } else {
                let decl: ParsedVarDecl = this.parseVarDecl();
                module.addVarDecl(decl);
            }
        }
        return module;
    }
    func parseVarDecl(&mut this) -> ParsedVarDecl {
        let mutToken: Token = this.expect(TOKEN_KEYWORD);
        mut mutable: bool = false;
        if (mutToken.content.equals(&KEYWORD_LET))
            mutable = false;
        else if (mutToken.content.equals(&KEYWORD_MUT))
            mutable = true;
        else unsafe {
            let ls: String = mutToken.span.toString();
            let stderr: Any = fdopen(2, "a");
            fprintf(stderr, "error: %s: Expected `let` or `mut`, found `%.*s`.\n", ls.buffer, mutToken.content.len, mutToken.content.start);
            exit(1);
        }
        let name: Token = this.expect(TOKEN_IDENT);
        this.expect(TOKEN_EQUAL_SINGLE);
        let value: ParsedDeclValue = this.parseDeclValue();
        this.expect(TOKEN_SEMI_COLON);
        return createVarDecl(name, value, mutable);
    }
    func parseDeclValue(&mut this) -> ParsedDeclValue {
        if (this.at(TOKEN_KEYWORD))
            return this.parseDeclValueKeyword();
        else
            return this.parseDeclValueExpr();
    }
    func parseDeclValueKeyword(&mut this) -> ParsedDeclValue {
        let kw: Token = this.expect(TOKEN_KEYWORD);
        if (kw.content.equals(&KEYWORD_STRUCT))
            return this.parseDeclValueStruct();
        else if (kw.content.equals(&KEYWORD_FUNC))
            return this.parseDeclValueFunc();
        else if (kw.content.equals(&KEYWORD_ENUM))
            return this.parseDeclValueEnum();
        else if (kw.content.equals(&KEYWORD_UNION))
            return this.parseDeclValueUnion();
        else if (kw.content.equals(&KEYWORD_MODULE))
            return this.parseDeclValueModule();
        else unsafe {
            let ls: String = kw.span.toString();
            let stderr: Any = fdopen(2, "a");
            fprintf(stderr, "error: %s: Expected one of `struct`, `func`, `enum`, `union` or `module`, found `%.*s`.\n", ls.buffer, kw.content.len, kw.content.start);
            exit(1);
        }
        return defaultDeclValue();
    }
    func parseDeclValueModule(&mut this) -> ParsedDeclValue {
        this.expect(TOKEN_CURLY_OPEN);
        let module: ParsedModule = this.parseModule();
        this.expect(TOKEN_CURLY_CLOSE);
        return createDeclValue(DECL_VALUE_MODULE, module.span, sizeof ParsedModule, &module);
    }
    func parseDeclValueStruct(&mut this) -> ParsedDeclValue {
        let start: Token = this.expect(TOKEN_CURLY_OPEN);
        mut structDecl: ParsedStructDecl = defaultStructDecl();
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            if (this.at(TOKEN_IDENT)) {
                let structField: ParsedStructField = this.parseStructField();
                structDecl.addField(structField);
            } else if (this.at(TOKEN_KEYWORD)) {
                let structAsset: ParsedStructAsset = this.parseStructAsset();
                structDecl.addAsset(structAsset);
            } else unsafe {
                let next: Token = this.next();
                let ls: String = next.span.toString();
                let stderr: Any = fdopen(2, "a");
                fprintf(stderr, "error: %s: Expected identifier or `func`, got `%.*s`.\n", ls.buffer, next.content.len, next.content.start);
                exit(1);
            }
        }
        let end: Token = this.expect(TOKEN_CURLY_CLOSE);
        let span: Span = newSpanBetween(&start.span, &end.span);
        structDecl.span = span;
        return createDeclValue(DECL_VALUE_STRUCT_DECL, span, sizeof ParsedStructDecl, &structDecl);
    }
    func parseStructField(&mut this) -> ParsedStructField {
        let name: Token = this.expect(TOKEN_IDENT);
        this.expect(TOKEN_COLON);
        let typ: ParsedTypeExpr = this.parseTypeExpr();
        this.expect(TOKEN_SEMI_COLON);
        return ParsedStructField {
            name: name.content,
            typ: typ
        };
    }
    func parseStructAsset(&mut this) -> ParsedStructAsset {
        let decl: ParsedVarDecl = this.parseVarDecl();
        return ParsedStructAsset {
            asset: decl
        };
    }
    func parseDeclValueEnum(&mut this) -> ParsedDeclValue {
        unsafe {
            printf("TODO: Properly parse enum\n");
        }
        mut enumDecl: ParsedEnumDecl = defaultEnumDecl();
        mut fieldType: ParsedTypeExpr = defaultTypeExpr();
        if (this.eat(TOKEN_PAREN_OPEN)) {
            fieldType = this.parseTypeExpr();
            this.expect(TOKEN_PAREN_CLOSE);
        }
        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let tkn: Token = this.next();
        }
        let end: Token = this.expect(TOKEN_CURLY_CLOSE);
        return createDeclValue(DECL_VALUE_ENUM_DECL, end.span, sizeof ParsedEnumDecl, &enumDecl);
    }
    func parseDeclValueUnion(&mut this) -> ParsedDeclValue {
        unsafe {
            printf("TODO: Properly parse union\n");
        }
        mut unionDecl: ParsedUnionDecl = defaultUnionDecl();
        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let tkn: Token = this.next();
        }
        let end: Token = this.expect(TOKEN_CURLY_CLOSE);
        return createDeclValue(DECL_VALUE_UNION_DECL, end.span, sizeof ParsedUnionDecl, &unionDecl);
    }
    func parseDeclValueFunc(&mut this) -> ParsedDeclValue {
        let start: Token = this.expect(TOKEN_PAREN_OPEN);
        mut funcDecl: ParsedFuncDecl = defaultFuncDecl();
        while (!this.at(TOKEN_PAREN_CLOSE)) {
            let param: ParsedParam = this.parseFuncParam();
            funcDecl.addParam(param);
            if (!this.at(TOKEN_PAREN_CLOSE)) this.expect(TOKEN_COMMA);
        }
        this.expect(TOKEN_PAREN_CLOSE);

        mut retType: ParsedTypeExpr = defaultTypeExpr();
        if (this.eat(TOKEN_ARROW)) {
            retType = this.parseTypeExpr();
        }
        funcDecl.setReturnType(retType);

        this.expect(TOKEN_CURLY_OPEN);
        while (!this.at(TOKEN_CURLY_CLOSE)) {
            let stmt: ParsedStmt = this.parseStmt();
            funcDecl.addStmt(stmt);
        }
        let end: Token = this.expect(TOKEN_CURLY_CLOSE);
        let span: Span = newSpanBetween(&start.span, &end.span);
        return createDeclValue(DECL_VALUE_FUNC_DECL, span, sizeof ParsedFuncDecl, &funcDecl);
    }
    func parseFuncParam(&mut this) -> ParsedParam {
        let name: Token = this.expect(TOKEN_IDENT);
        this.expect(TOKEN_COLON);
        let typ: ParsedTypeExpr = this.parseTypeExpr();
        return ParsedParam {};
    }
    func parseDeclValueExpr(&mut this) -> ParsedDeclValue {
        return this.__parseDeclValueExpr(0, ASSOC_LEFT);
    }
    func __parseDeclValueExpr(&mut this, minPrecedence: usize, associativity: usize) -> ParsedDeclValue {
        mut expr: ParsedDeclValue = this.parseDeclValueExprPrimary();
        while (this.matchesBinaryExpression()) {
            let kind: usize = this.peek().kind;
            let newPrecedence: usize = this.getBinaryPrecedence(kind);
            if (newPrecedence < minPrecedence) break;
            if (newPrecedence == minPrecedence && associativity == ASSOC_LEFT) break;
            let newAssociativity: usize = this.getAssociativity(kind);
            let result: ParsedDeclValue = this.parseDeclValueExprSecondary(expr, newPrecedence, newAssociativity);
            expr = result;
        }
        return expr;
    }
    func getBinaryPrecedence(&mut this, kind: usize) -> usize {
        if (kind == TOKEN_DOT) return 17;
        if (kind == TOKEN_PAREN_OPEN) return 16;
        if (kind == TOKEN_PLUS_SINGLE) return 11;
        if (kind == TOKEN_MINUS_SINGLE) return 11;
        todo_with_msg("getBinaryPrecedence");
        return 0;
    }
    func getAssociativity(&mut this, kind: usize) -> usize {
        if (kind == TOKEN_EQUAL_SINGLE) return ASSOC_RIGHT;
        return ASSOC_LEFT;
    }
    func parseDeclValueExprSecondary(&mut this, lhs: ParsedDeclValue, precedence: usize, associativity: usize) -> ParsedDeclValue {
        let opTkn: Token = this.peek();
        let op: usize = createBinaryOp(&opTkn.content);
        if (op == BINARY_OP_PAREN) {
            return this.parseDeclValueCall(lhs);
        }
        this.next();
        let rhs: ParsedDeclValue = this.__parseDeclValueExpr(precedence, associativity);
        let span: Span = newSpanBetween(&lhs.span, &rhs.span);
        let bin: ParsedDeclValueBinary = ParsedDeclValueBinary {
            op: op,
            lhs: lhs,
            rhs: rhs
        };
        return createDeclValue(DECL_VALUE_BINARY, span, sizeof ParsedDeclValueBinary, &bin);
    }
    func parseDeclValueExprPrimary(&mut this) -> ParsedDeclValue {
        if (this.at(TOKEN_KEYWORD))
            return this.parseDeclValueKeyword();
        else if (this.at(TOKEN_AT))
            return this.parseDeclValueBuiltin();
        if (this.matchesUnaryExpression())
            return this.parseDeclValueExprUnary();
        let tkn: Token = this.peek();
        if (tkn.kind == TOKEN_NUMBER)
            return this.parseDeclValueExprIntLiteral();
        else if (tkn.kind == TOKEN_IDENT)
            return this.parseDeclValueExprIdentifier();
        todo_with_msg("primary");
        return defaultDeclValue();
    }
    func parseDeclValueExprIntLiteral(&mut this) -> ParsedDeclValue {
        let number: Token = this.expect(TOKEN_NUMBER);
        let numbah: ParsedDeclValueNumber = ParsedDeclValueNumber {
            span: number.span,
            number: number.content,
        };
        return createDeclValue(DECL_VALUE_NUMBER, number.span, sizeof ParsedDeclValueNumber, &numbah);
    }
    func parseDeclValueExprIdentifier(&mut this) -> ParsedDeclValue {
        let ident: Token = this.expect(TOKEN_IDENT);
        let id: ParsedDeclValueIdent = ParsedDeclValueIdent {
            name: ident.content
        };
        return createDeclValue(DECL_VALUE_IDENT, ident.span, sizeof ParsedDeclValueIdent, &id);
    }
    func matchesBinaryExpression(&mut this) -> bool {
        let tkn: Token = this.peek();
        let kind: usize = tkn.kind;
        return kind == TOKEN_PLUS_SINGLE
            || kind == TOKEN_DOT
            || kind == TOKEN_PAREN_OPEN
            || kind == TOKEN_MINUS_SINGLE;
    }
    func matchesUnaryExpression(&mut this) -> bool {
        let tkn: Token = this.peek();
        let kind: usize = tkn.kind;
        return kind == TOKEN_AMPERSAND;
    }
    func parseDeclValueExprUnary(&mut this) -> ParsedDeclValue {
        todo_with_msg("unary");
        return defaultDeclValue();
    }
    func parseDeclValueBuiltin(&mut this) -> ParsedDeclValue {
        // TODO: Instead of assert, report an error
        //       We don't want to let unknown builtin calls through
        this.expect(TOKEN_AT);
        let builtinFn: ParsedDeclValue = this.parseDeclValueExpr();
        assert(builtinFn.kind == DECL_VALUE_CALL);
        unsafe {
            let fnName: ParsedDeclValue = (builtinFn.data as &ParsedDeclValueCall).fn;
            assert(fnName.kind == DECL_VALUE_IDENT);
        }
        return createDeclValue(DECL_VALUE_BUILTIN, builtinFn.span, sizeof ParsedDeclValue, &builtinFn);
    }
    func parseDeclValueCall(&mut this, name: ParsedDeclValue) -> ParsedDeclValue {
        mut args: [ParsedDeclValue; 8] = blank;
        mut argCount: usize = 0;
        this.expect(TOKEN_PAREN_OPEN);
        while (!this.at(TOKEN_PAREN_CLOSE)) {
            assert(argCount < 8);
            let arg: ParsedDeclValue = this.parseDeclValueExpr();
            args[argCount] = arg;
            argCount = argCount + 1;
            if (!this.at(TOKEN_PAREN_CLOSE)) this.expect(TOKEN_COMMA);
        }
        let end: Token = this.expect(TOKEN_PAREN_CLOSE);
        unsafe {
            let call: ParsedDeclValueCall = ParsedDeclValueCall {
                fn: name,
                args: args,
                argCount: argCount
            };
            let span: Span = newSpanBetween(&name.span, &end.span);
            return createDeclValue(DECL_VALUE_CALL, span, sizeof ParsedDeclValueCall, &call);
        }
    }
    func parseTypeExpr(&mut this) -> ParsedTypeExpr {
        let expr: ParsedDeclValue = this.parseDeclValueExpr();
        return ParsedTypeExpr {
            expr: expr
        };
    }
    func parseStmt(&mut this) -> ParsedStmt {
        mut stmt: ParsedStmt = blank;
        if (this.at(TOKEN_KEYWORD)) {
            let kw: Token = this.peek();
            if (kw.content.equals(&KEYWORD_RETURN))
                stmt = this.parseStmtReturn();
            else if (kw.content.equals(&KEYWORD_LET))
                stmt = this.parseStmtVarDecl();
            else unsafe {
                let ls: String = kw.span.toString();
                let stderr: Any = fdopen(2, "a");
                fprintf(stderr, "error: %s: Expected one of `return` or `let`, found `%.*s`.\n", ls.buffer, kw.content.len, kw.content.start);
                exit(1);
            }
        } else {
            todo_with_msg("not kw stmt");
        }
        return stmt;
    }
    func parseStmtReturn(&mut this) -> ParsedStmt {
        let kw: Token = this.expectKeyword(&KEYWORD_RETURN);
        let expr: ParsedDeclValue = this.parseDeclValueExpr();
        this.expect(TOKEN_SEMI_COLON);
        return createStmt(STMT_RETURN, sizeof ParsedDeclValue, &expr);
    }
    func parseStmtVarDecl(&mut this) -> ParsedStmt {
        let decl: ParsedVarDecl = this.parseVarDecl();
        return createStmt(STMT_VAR_DECL, sizeof ParsedVarDecl, &decl);
    }
}

func newParser(lexer: &mut Lexer) -> Parser {
    return Parser {
        lexer: lexer
    };
}
